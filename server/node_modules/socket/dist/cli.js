#!/usr/bin/env node
'use strict'

const process$1 = require('node:process')
const require$$0 = require('node:url')
const vendor = require('./vendor.js')
const debug = require('../external/@socketsecurity/registry/lib/debug')
const logger = require('../external/@socketsecurity/registry/lib/logger')
const constants = require('./constants.js')
const strings = require('../external/@socketsecurity/registry/lib/strings')
const shadowNpmInject = require('./shadow-npm-inject.js')
const fs = require('node:fs/promises')
const path$1 = require('node:path')
const objects = require('../external/@socketsecurity/registry/lib/objects')
const path = require('../external/@socketsecurity/registry/lib/path')
const regexps = require('../external/@socketsecurity/registry/lib/regexps')
const prompts = require('../external/@socketsecurity/registry/lib/prompts')
const words = require('../external/@socketsecurity/registry/lib/words')
const fs$1 = require('node:fs')
const shadowBin = require('./shadow-bin.js')
const shadowNpmPaths = require('./shadow-npm-paths.js')
const util = require('node:util')
const arrays = require('../external/@socketsecurity/registry/lib/arrays')
const registry = require('../external/@socketsecurity/registry')
const npm = require('../external/@socketsecurity/registry/lib/npm')
const packages = require('../external/@socketsecurity/registry/lib/packages')
const spawn = require('../external/@socketsecurity/registry/lib/spawn')
const sorts = require('../external/@socketsecurity/registry/lib/sorts')
const registryConstants = require('../external/@socketsecurity/registry/lib/constants')
const promises = require('../external/@socketsecurity/registry/lib/promises')

function failMsgWithBadge(badge, msg) {
  return `${vendor.yoctocolorsCjsExports.bgRed(vendor.yoctocolorsCjsExports.bold(vendor.yoctocolorsCjsExports.white(` ${badge}${msg ? ': ' : ''}`)))}${msg ? ' ' + vendor.yoctocolorsCjsExports.bold(msg) : ''}`
}

const { API_V0_URL } = constants
function handleUnsuccessfulApiResponse(_name, { cause, error, status }) {
  const message = `${error || 'No error message returned'}${cause ? ` (reason: ${cause})` : ''}`
  if (status === 401 || status === 403) {
    // Lazily access constants.spinner.
    const { spinner } = constants
    spinner.stop()
    throw new shadowNpmInject.AuthError(message)
  }
  logger.logger.fail(failMsgWithBadge('Socket API returned an error', message))
  // eslint-disable-next-line n/no-process-exit
  process$1.exit(1)
}
function handleFailedApiResponse(_name, { cause, error }) {
  process$1.exitCode = 1
  const message = `${error || 'No error message returned'}`
  // logger.error(failMsgWithBadge('Socket API returned an error', message))
  return {
    ok: false,
    message: 'Socket API returned an error',
    data: `${message}${cause ? ` ( Reason: ${cause} )` : ''}`
  }
}
async function handleApiCall(value, description) {
  let result
  try {
    result = await value
  } catch (e) {
    debug.debugLog(`handleApiCall[${description}] error:\n`, e)
    throw new Error(`Failed ${description}`, {
      cause: e
    })
  }
  return result
}
async function handleApiError(code) {
  if (code === 400) {
    return 'One of the options passed might be incorrect'
  }
  if (code === 403) {
    return 'Your API token may not have the required permissions for this command or you might be trying to access (data from) an organization that is not linked to the API key you are logged in with'
  }
  if (code === 404) {
    return 'The requested Socket API endpoint was not found (404) or there was no result for the requested parameters. This could be a temporary problem caused by an incident or a bug in the CLI. If the problem persists please let us know.'
  }
  return `Server responded with status code ${code}`
}
function getLastFiveOfApiToken(token) {
  // Get the last 5 characters of the API token before the trailing "_api".
  return token.slice(-9, -4)
}

// The API server that should be used for operations.
function getDefaultApiBaseUrl() {
  const baseUrl =
    // Lazily access constants.ENV.SOCKET_SECURITY_API_BASE_URL.
    constants.ENV.SOCKET_SECURITY_API_BASE_URL ||
    shadowNpmInject.getConfigValue('apiBaseUrl')
  return strings.isNonEmptyString(baseUrl) ? baseUrl : API_V0_URL
}
async function queryApi(path, apiToken) {
  const baseUrl = getDefaultApiBaseUrl() || ''
  if (!baseUrl) {
    logger.logger.warn(
      'API endpoint is not set and default was empty. Request is likely to fail.'
    )
  }
  return await fetch(`${baseUrl}${baseUrl.endsWith('/') ? '' : '/'}${path}`, {
    method: 'GET',
    headers: {
      Authorization: `Basic ${btoa(`${apiToken}:`)}`
    }
  })
}

async function fetchOrgAnalyticsData(time) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start(`Requesting analytics data from API...`)
  const result = await handleApiCall(
    sockSdk.getOrgAnalytics(time.toString()),
    'fetching analytics data'
  )
  spinner.successAndStop(`Received API response.`)
  if (result.success === false) {
    return handleFailedApiResponse('getOrgAnalytics', result)
  }
  if (!result.data.length) {
    return {
      ok: true,
      message: 'No analytics data is available for this organization yet.',
      data: []
    }
  }
  return {
    ok: true,
    data: result.data
  }
}

async function fetchRepoAnalyticsData(repo, time) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start(`Requesting analytics data from API...`)
  const result = await handleApiCall(
    sockSdk.getRepoAnalytics(repo, time.toString()),
    'fetching analytics data'
  )
  spinner.successAndStop(`Received API response.`)
  if (result.success === false) {
    return handleFailedApiResponse('getRepoAnalytics', result)
  }
  if (!result.data.length) {
    return {
      ok: true,
      message: 'No analytics data is available for this repository yet.',
      data: []
    }
  }
  return {
    ok: true,
    data: result.data
  }
}

function mdTableStringNumber(title1, title2, obj) {
  // | Date        | Counts |
  // | ----------- | ------ |
  // | Header      | 201464 |
  // | Paragraph   |     18 |
  let mw1 = title1.length
  let mw2 = title2.length
  for (const [key, value] of Object.entries(obj)) {
    mw1 = Math.max(mw1, key.length)
    mw2 = Math.max(mw2, String(value ?? '').length)
  }
  const lines = []
  lines.push(`| ${title1.padEnd(mw1, ' ')} | ${title2.padEnd(mw2)} |`)
  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`)
  for (const [key, value] of Object.entries(obj)) {
    lines.push(
      `| ${key.padEnd(mw1, ' ')} | ${String(value ?? '').padStart(mw2, ' ')} |`
    )
  }
  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`)
  return lines.join('\n')
}
function mdTable(
  logs,
  // This is saying "an array of strings and the strings are a valid key of elements of T"
  // In turn, T is defined above as the audit log event type from our OpenAPI docs.
  cols,
  titles = cols
) {
  // Max col width required to fit all data in that column
  const cws = cols.map(col => col.length)
  for (const log of logs) {
    for (let i = 0, { length } = cols; i < length; i += 1) {
      // @ts-ignore
      const val = log[cols[i] ?? ''] ?? ''
      cws[i] = Math.max(
        cws[i] ?? 0,
        String(val).length,
        (titles[i] || '').length
      )
    }
  }
  let div = '|'
  for (const cw of cws) {
    div += ' ' + '-'.repeat(cw) + ' |'
  }
  let header = '|'
  for (let i = 0, { length } = titles; i < length; i += 1) {
    header += ' ' + String(titles[i]).padEnd(cws[i] ?? 0, ' ') + ' |'
  }
  let body = ''
  for (const log of logs) {
    body += '|'
    for (let i = 0, { length } = cols; i < length; i += 1) {
      // @ts-ignore
      const val = log[cols[i] ?? ''] ?? ''
      body += ' ' + String(val).padEnd(cws[i] ?? 0, ' ') + ' |'
    }
    body += '\n'
  }
  return [div, header, div, body.trim(), div].filter(s => !!s.trim()).join('\n')
}
function mdTableOfPairs(
  arr,
  // This is saying "an array of strings and the strings are a valid key of elements of T"
  // In turn, T is defined above as the audit log event type from our OpenAPI docs.
  cols
) {
  // Max col width required to fit all data in that column
  const cws = cols.map(col => col.length)
  for (const [key, val] of arr) {
    cws[0] = Math.max(cws[0] ?? 0, String(key).length)
    cws[1] = Math.max(cws[1] ?? 0, String(val ?? '').length)
  }
  let div = '|'
  for (const cw of cws) {
    div += ' ' + '-'.repeat(cw) + ' |'
  }
  let header = '|'
  for (let i = 0, { length } = cols; i < length; i += 1) {
    header += ' ' + String(cols[i]).padEnd(cws[i] ?? 0, ' ') + ' |'
  }
  let body = ''
  for (const [key, val] of arr) {
    body += '|'
    body += ' ' + String(key).padEnd(cws[0] ?? 0, ' ') + ' |'
    body += ' ' + String(val ?? '').padEnd(cws[1] ?? 0, ' ') + ' |'
    body += '\n'
  }
  return [div, header, div, body.trim(), div].filter(s => !!s.trim()).join('\n')
}

// Serialize the final result object before printing it
// All commands that support the --json flag should call this before printing
function serializeResultJson(data) {
  if (typeof data !== 'object' || !data) {
    process.exitCode = 1
    // We should not allow to expect the json value to be "null", or a boolean/number/string, even if they are valid "json".
    const msg =
      'There was a problem converting the data set to JSON. The JSON was not an object. Please try again without --json'
    debug.debugLog('typeof data=', typeof data)
    if (typeof data !== 'object' && data) {
      debug.debugLog('data:', data)
    }
    return JSON.stringify({
      ok: false,
      message: 'Unable to serialize JSON',
      data: msg
    })
  }
  try {
    return JSON.stringify(data, null, 2)
  } catch (e) {
    debug.debugLog('Error:')
    logger.logger.log('wtf?', e)
    process.exitCode = 1
    // This could be caused by circular references, which is an "us" problem
    const msg =
      'There was a problem converting the data set to JSON. Please try again without --json'
    logger.logger.error(msg)
    return JSON.stringify({
      ok: false,
      message: 'Unable to serialize JSON',
      data: msg
    })
  }
}

// Note: Widgets does not seem to actually work as code :'(

const METRICS = [
  'total_critical_alerts',
  'total_high_alerts',
  'total_medium_alerts',
  'total_low_alerts',
  'total_critical_added',
  'total_medium_added',
  'total_low_added',
  'total_high_added',
  'total_critical_prevented',
  'total_high_prevented',
  'total_medium_prevented',
  'total_low_prevented'
]

// Note: This maps `new Date(date).getMonth()` to English three letters
const Months = [
  'Jan',
  'Feb',
  'Mar',
  'Apr',
  'May',
  'Jun',
  'Jul',
  'Aug',
  'Sep',
  'Oct',
  'Nov',
  'Dec'
]
async function outputAnalytics(
  result,
  { filePath, outputKind, repo, scope, time }
) {
  if (outputKind === 'json') {
    const serialized = serializeResultJson(result)

    // TODO: do we want to write to file even if there was an error...?
    if (filePath && filePath !== '-') {
      try {
        await fs.writeFile(filePath, serialized, 'utf8')
        logger.logger.log(`Data successfully written to ${filePath}`)
      } catch (e) {
        process.exitCode = 1
        logger.logger.fail(
          'There was an error trying to write the json to disk'
        )
        logger.logger.error(e)
      }
    } else {
      logger.logger.log(serialized)
    }
    return
  }
  if (!result.ok) {
    // Note: We're not in json mode so just print the error badge
    logger.logger.fail(failMsgWithBadge(result.message, result.data))
    return
  }
  const fdata =
    scope === 'org' ? formatDataOrg(result.data) : formatDataRepo(result.data)
  if (outputKind === 'markdown') {
    const serialized = renderMarkdown(fdata, time, repo)

    // TODO: do we want to write to file even if there was an error...?
    if (filePath && filePath !== '-') {
      try {
        await fs.writeFile(filePath, serialized, 'utf8')
        logger.logger.log(`Data successfully written to ${filePath}`)
      } catch (e) {
        logger.logger.error(e)
      }
    } else {
      logger.logger.log(serialized)
    }
  } else {
    displayAnalyticsScreen(fdata)
  }
}
function renderMarkdown(data, days, repoSlug) {
  return (
    `
# Socket Alert Analytics

These are the Socket.dev analytics for the ${repoSlug ? `${repoSlug} repo` : 'org'} of the past ${days} days

${[
  [
    'Total critical alerts',
    mdTableStringNumber('Date', 'Counts', data['total_critical_alerts'])
  ],
  [
    'Total high alerts',
    mdTableStringNumber('Date', 'Counts', data['total_high_alerts'])
  ],
  [
    'Total critical alerts added to the main branch',
    mdTableStringNumber('Date', 'Counts', data['total_critical_added'])
  ],
  [
    'Total high alerts added to the main branch',
    mdTableStringNumber('Date', 'Counts', data['total_high_added'])
  ],
  [
    'Total critical alerts prevented from the main branch',
    mdTableStringNumber('Date', 'Counts', data['total_critical_prevented'])
  ],
  [
    'Total high alerts prevented from the main branch',
    mdTableStringNumber('Date', 'Counts', data['total_high_prevented'])
  ],
  [
    'Total medium alerts prevented from the main branch',
    mdTableStringNumber('Date', 'Counts', data['total_medium_prevented'])
  ],
  [
    'Total low alerts prevented from the main branch',
    mdTableStringNumber('Date', 'Counts', data['total_low_prevented'])
  ]
]
  .map(([title, table]) =>
    `
## ${title}

${table}
`.trim()
  )
  .join('\n\n')}

## Top 5 alert types

${mdTableStringNumber('Name', 'Counts', data['top_five_alert_types'])}
`.trim() + '\n'
  )
}
function displayAnalyticsScreen(data) {
  const ScreenWidget = require('../external/blessed/lib/widgets/screen.js')
  // Lazily access constants.blessedOptions.
  const screen = new ScreenWidget({
    ...constants.blessedOptions
  })
  const GridLayout = require('../external/blessed-contrib/lib/layout/grid.js')
  const grid = new GridLayout({
    rows: 5,
    cols: 4,
    screen
  })
  renderLineCharts(
    grid,
    screen,
    'Total critical alerts',
    [0, 0, 1, 2],
    data['total_critical_alerts']
  )
  renderLineCharts(
    grid,
    screen,
    'Total high alerts',
    [0, 2, 1, 2],
    data['total_high_alerts']
  )
  renderLineCharts(
    grid,
    screen,
    'Total critical alerts added to the main branch',
    [1, 0, 1, 2],
    data['total_critical_added']
  )
  renderLineCharts(
    grid,
    screen,
    'Total high alerts added to the main branch',
    [1, 2, 1, 2],
    data['total_high_added']
  )
  renderLineCharts(
    grid,
    screen,
    'Total critical alerts prevented from the main branch',
    [2, 0, 1, 2],
    data['total_critical_prevented']
  )
  renderLineCharts(
    grid,
    screen,
    'Total high alerts prevented from the main branch',
    [2, 2, 1, 2],
    data['total_high_prevented']
  )
  renderLineCharts(
    grid,
    screen,
    'Total medium alerts prevented from the main branch',
    [3, 0, 1, 2],
    data['total_medium_prevented']
  )
  renderLineCharts(
    grid,
    screen,
    'Total low alerts prevented from the main branch',
    [3, 2, 1, 2],
    data['total_low_prevented']
  )
  const BarChart = require('../external/blessed-contrib/lib/widget/charts/bar.js')
  const bar = grid.set(4, 0, 1, 2, BarChart, {
    label: 'Top 5 alert types',
    barWidth: 10,
    barSpacing: 17,
    xOffset: 0,
    maxHeight: 9,
    barBgColor: 'magenta'
  })
  screen.append(bar) //must append before setting data

  bar.setData({
    titles: Object.keys(data.top_five_alert_types),
    data: Object.values(data.top_five_alert_types)
  })
  screen.render()
  // eslint-disable-next-line n/no-process-exit
  screen.key(['escape', 'q', 'C-c'], () => process.exit(0))
}
function formatDataRepo(data) {
  const sortedTopFiveAlerts = {}
  const totalTopAlerts = {}
  const formattedData = {}
  for (const metric of METRICS) {
    formattedData[metric] = {}
  }
  for (const entry of data) {
    const topFiveAlertTypes = entry['top_five_alert_types']
    for (const type of Object.keys(topFiveAlertTypes)) {
      const count = topFiveAlertTypes[type] ?? 0
      if (!totalTopAlerts[type]) {
        totalTopAlerts[type] = count
      } else if (count > (totalTopAlerts[type] ?? 0)) {
        totalTopAlerts[type] = count
      }
    }
  }
  for (const entry of data) {
    for (const metric of METRICS) {
      formattedData[metric][formatDate(entry['created_at'])] = entry[metric]
    }
  }
  const topFiveAlertEntries = Object.entries(totalTopAlerts)
    .sort(([_keya, a], [_keyb, b]) => b - a)
    .slice(0, 5)
  for (const [key, value] of topFiveAlertEntries) {
    sortedTopFiveAlerts[key] = value
  }
  return {
    ...formattedData,
    top_five_alert_types: sortedTopFiveAlerts
  }
}
function formatDataOrg(data) {
  const sortedTopFiveAlerts = {}
  const totalTopAlerts = {}
  const formattedData = {}
  for (const metric of METRICS) {
    formattedData[metric] = {}
  }
  for (const entry of data) {
    const topFiveAlertTypes = entry['top_five_alert_types']
    for (const type of Object.keys(topFiveAlertTypes)) {
      const count = topFiveAlertTypes[type] ?? 0
      if (!totalTopAlerts[type]) {
        totalTopAlerts[type] = count
      } else {
        totalTopAlerts[type] += count
      }
    }
  }
  for (const metric of METRICS) {
    const formatted = formattedData[metric]
    for (const entry of data) {
      const date = formatDate(entry['created_at'])
      if (!formatted[date]) {
        formatted[date] = entry[metric]
      } else {
        formatted[date] += entry[metric]
      }
    }
  }
  const topFiveAlertEntries = Object.entries(totalTopAlerts)
    .sort(([_keya, a], [_keyb, b]) => b - a)
    .slice(0, 5)
  for (const [key, value] of topFiveAlertEntries) {
    sortedTopFiveAlerts[key] = value
  }
  return {
    ...formattedData,
    top_five_alert_types: sortedTopFiveAlerts
  }
}
function formatDate(date) {
  return `${Months[new Date(date).getMonth()]} ${new Date(date).getDate()}`
}
function renderLineCharts(grid, screen, title, coords, data) {
  const LineChart = require('../external/blessed-contrib/lib/widget/charts/line.js')
  const line = grid.set(...coords, LineChart, {
    style: {
      line: 'cyan',
      text: 'cyan',
      baseline: 'black'
    },
    xLabelPadding: 0,
    xPadding: 0,
    xOffset: 0,
    wholeNumbersOnly: true,
    legend: {
      width: 1
    },
    label: title
  })
  screen.append(line)
  const lineData = {
    x: Object.keys(data),
    y: Object.values(data)
  }
  line.setData([lineData])
}

async function handleAnalytics({ filePath, outputKind, repo, scope, time }) {
  let result
  if (scope === 'org') {
    result = await fetchOrgAnalyticsData(time)
  } else if (repo) {
    result = await fetchRepoAnalyticsData(repo, time)
  } else {
    result = {
      ok: false,
      message: 'Missing repository name in command',
      data: undefined
    }
  }
  await outputAnalytics(result, {
    filePath,
    outputKind,
    repo,
    scope,
    time
  })
}

// TODO: not sure if I'm missing something but meow doesn't seem to expose this?

// Note: we use this description in getFlagListOutput, meow doesn't care

const commonFlags = {
  config: {
    type: 'string',
    default: '',
    hidden: true,
    description: 'Override the local config with this JSON'
  },
  dryRun: {
    type: 'boolean',
    default: false,
    hidden: true,
    // Only show in root command
    description: 'Do input validation for a command and exit 0 when input is ok'
  },
  help: {
    type: 'boolean',
    default: false,
    shortFlag: 'h',
    description: 'Print this help'
  },
  silent: {
    type: 'boolean',
    default: false,
    hidden: true,
    shortFlag: 's',
    description: 'Make the CLI less chatty'
  }
}
const outputFlags = {
  json: {
    type: 'boolean',
    shortFlag: 'j',
    default: false,
    description: 'Output result as json'
  },
  markdown: {
    type: 'boolean',
    shortFlag: 'm',
    default: false,
    description: 'Output result as markdown'
  }
}
const validationFlags = {
  all: {
    type: 'boolean',
    default: false,
    description: 'Include all issues'
  },
  strict: {
    type: 'boolean',
    default: false,
    description: 'Exits with an error code if any matching issues are found'
  }
}

function getOutputKind(json, markdown) {
  if (json) {
    return 'json'
  }
  if (markdown) {
    return 'markdown'
  }
  return 'text'
}

function checkCommandInput(outputKind, ...checks) {
  if (checks.every(d => d.test)) {
    return false
  }
  const msg = ['Please review the input requirements and try again', '']
  for (const d of checks) {
    // If nook, then ignore when test is ok
    if (d.nook && d.test) {
      continue
    }
    const lines = d.message.split('\n')

    // If the message has newlines then format the first line with the input
    // expectation and teh rest indented below it
    msg.push(
      `  - ${lines[0]} (${d.test ? vendor.yoctocolorsCjsExports.green(d.pass) : vendor.yoctocolorsCjsExports.red(d.fail)})`
    )
    if (lines.length > 1) {
      msg.push(...lines.slice(1).map(str => `    ${str}`))
    }
    msg.push('')
  }

  // Use exit status of 2 to indicate incorrect usage, generally invalid
  // options or missing arguments.
  // https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html
  process.exitCode = 2
  if (outputKind === 'json') {
    logger.logger.log(
      serializeResultJson({
        ok: false,
        message: 'Input error',
        data: msg.join('\n')
      })
    )
  } else {
    logger.logger.fail(failMsgWithBadge('Input error', msg.join('\n')))
  }
  return true
}
function handleBadInput(...checks) {
  return checkCommandInput('text', ...checks)
}

function getFlagListOutput(list, indent, { keyPrefix = '--', padName } = {}) {
  return getHelpListOutput(
    {
      ...list
    },
    indent,
    {
      keyPrefix,
      padName
    }
  )
}
function getHelpListOutput(
  list,
  indent,
  { keyPrefix = '', padName = 18 } = {}
) {
  let result = ''
  const names = Object.keys(list).sort()
  for (const name of names) {
    const entry = list[name]
    if (entry && 'hidden' in entry && entry?.hidden) {
      continue
    }
    const description =
      (typeof entry === 'object' ? entry.description : entry) || ''
    result +=
      ''.padEnd(indent) +
      (keyPrefix + name).padEnd(padName) +
      description +
      '\n'
  }
  return result.trim() || '(none)'
}

async function meowWithSubcommands(subcommands, options) {
  const {
    aliases = {},
    argv,
    defaultSub,
    importMeta,
    name,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  }
  const [commandOrAliasName_, ...rawCommandArgv] = argv
  let commandOrAliasName = commandOrAliasName_
  if (!commandOrAliasName && defaultSub) {
    commandOrAliasName = defaultSub
  }
  const flags = {
    ...commonFlags,
    ...additionalOptions.flags
  }

  // No further args or first arg is a flag (shrug)
  if (
    name === 'socket' &&
    (!commandOrAliasName || commandOrAliasName?.startsWith('-'))
  ) {
    flags['dryRun'] = {
      type: 'boolean',
      default: false,
      hidden: false,
      // Only show on root
      description:
        'Do input validation for a command and exit 0 when input is ok. Every command should support this flag (not shown on help screens)'
    }
  }
  const cli = vendor.meow(
    `
    Usage
      $ ${name} <command>

    Commands
      ${getHelpListOutput(
        {
          ...objects.toSortedObject(
            Object.fromEntries(
              Object.entries(subcommands).filter(
                ({ 1: subcommand }) => !subcommand.hidden
              )
            )
          ),
          ...objects.toSortedObject(
            Object.fromEntries(
              Object.entries(aliases).filter(({ 1: alias }) => {
                const { hidden } = alias
                const cmdName = hidden ? '' : alias.argv[0]
                const subcommand = cmdName ? subcommands[cmdName] : undefined
                return subcommand && !subcommand.hidden
              })
            )
          )
        },
        6
      )}

    Options
      ${getFlagListOutput(flags, 6)}

    Examples
      $ ${name} --help
  `,
    {
      argv,
      importMeta,
      ...additionalOptions,
      flags,
      // Do not strictly check for flags here.
      allowUnknownFlags: true,
      // We will emit help when we're ready
      // Plus, if we allow this then meow() can just exit here.
      autoHelp: false
    }
  )

  // Hard override the config if instructed to do so.
  // The env var overrides the --flag, which overrides the persisted config
  // Also, when either of these are used, config updates won't persist.
  let configOverrideResult
  // Lazily access constants.ENV.SOCKET_CLI_CONFIG.
  if (constants.ENV.SOCKET_CLI_CONFIG) {
    configOverrideResult = shadowNpmInject.overrideCachedConfig(
      // Lazily access constants.ENV.SOCKET_CLI_CONFIG.
      constants.ENV.SOCKET_CLI_CONFIG
    )
  } else if (cli.flags['config']) {
    configOverrideResult = shadowNpmInject.overrideCachedConfig(
      String(cli.flags['config'] || '')
    )
  }

  // Lazily access constants.ENV.SOCKET_CLI_NO_API_TOKEN.
  if (constants.ENV.SOCKET_CLI_NO_API_TOKEN) {
    // This overrides the config override and even the explicit token env var.
    // The config will be marked as readOnly to prevent persisting it.
    shadowNpmInject.overrideConfigApiToken(undefined)
  } else {
    // Lazily access constants.ENV.SOCKET_SECURITY_API_TOKEN.
    const tokenOverride = constants.ENV.SOCKET_SECURITY_API_TOKEN
    if (tokenOverride) {
      // This will set the token (even if there was a config override) and
      // set it to readOnly, making sure the temp token won't be persisted.
      shadowNpmInject.overrideConfigApiToken(tokenOverride)
    }
  }
  if (configOverrideResult?.ok === false) {
    emitBanner(name)
    logger.logger.fail(configOverrideResult.message)
    process$1.exitCode = 2
    return
  }

  // If we got at least some args, then lets find out if we can find a command.
  if (commandOrAliasName) {
    const alias = aliases[commandOrAliasName]
    // First: Resolve argv data from alias if its an alias that's been given.
    const [commandName, ...commandArgv] = alias
      ? [...alias.argv, ...rawCommandArgv]
      : [commandOrAliasName, ...rawCommandArgv]
    // Second: Find a command definition using that data.
    const commandDefinition = commandName ? subcommands[commandName] : undefined
    // Third: If a valid command has been found, then we run it...
    if (commandDefinition) {
      return await commandDefinition.run(commandArgv, importMeta, {
        parentName: name
      })
    }
  }

  // ...else we provide basic instructions and help.
  if (!cli.flags['silent']) {
    emitBanner(name)
  }
  if (!cli.flags['help'] && cli.flags['dryRun']) {
    process$1.exitCode = 0
    // Lazily access constants.DRY_RUN_LABEL.
    logger.logger.log(
      `${constants.DRY_RUN_LABEL}: No-op, call a sub-command; ok`
    )
  } else {
    cli.showHelp()
  }
}

/**
 * Note: meow will exit immediately if it calls its .showHelp()
 */
function meowOrExit({
  allowUnknownFlags,
  // commands that pass-through args need to allow this
  argv,
  config,
  importMeta,
  parentName
}) {
  const command = `${parentName} ${config.commandName}`

  // This exits if .printHelp() is called either by meow itself or by us.
  const cli = vendor.meow({
    argv,
    description: config.description,
    help: config.help(command, config),
    importMeta,
    flags: config.flags,
    allowUnknownFlags: Boolean(allowUnknownFlags),
    autoHelp: false // otherwise we can't exit(0)
  })
  if (!cli.flags['silent']) {
    emitBanner(command)
  }
  if (cli.flags['help']) {
    cli.showHelp()
  }
  return cli
}
function emitBanner(name) {
  // Print a banner at the top of each command.
  // This helps with brand recognition and marketing.
  // It also helps with debugging since it contains version and command details.
  // Note: print over stderr to preserve stdout for flags like --json and
  //       --markdown. If we don't do this, you can't use --json in particular
  //       and pipe the result to other tools. By emitting the banner over stderr
  //       you can do something like `socket scan view xyz | jq | process`.
  //       The spinner also emits over stderr for example.
  logger.logger.error(getAsciiHeader(name))
}
function getAsciiHeader(command) {
  // Note: In tests we return <redacted> because otherwise snapshots will fail.
  const { REDACTED } = constants
  // Lazily access constants.ENV.VITEST.
  const redacting = constants.ENV.VITEST
  const cliVersion = redacting
    ? REDACTED
    : // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH.
      constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH
  const nodeVersion = redacting ? REDACTED : process$1.version
  const apiToken = shadowNpmInject.getDefaultToken()
  const defaultOrg = shadowNpmInject.getConfigValue('defaultOrg')
  const readOnlyConfig = shadowNpmInject.isReadOnlyConfig() ? '*' : '.'
  const v1test = shadowNpmInject.isTestingV1() ? ' (is testing v1)' : ''
  const feedback = shadowNpmInject.isTestingV1()
    ? vendor.yoctocolorsCjsExports.green(
        '   (Thank you for testing the v1 bump! Please send us any feedback you might have!)\n'
      )
    : ''
  const shownToken = redacting
    ? REDACTED
    : apiToken
      ? getLastFiveOfApiToken(apiToken)
      : 'no'
  const relCwd = redacting
    ? REDACTED
    : path.normalizePath(
        process$1
          .cwd()
          .replace(
            new RegExp(
              `^${regexps.escapeRegExp(constants.homePath)}(?:${path$1.sep}|$)`,
              'i'
            ),
            '~/'
          )
      )
  let nodeVerWarn = ''
  if ((vendor.semverExports.parse(constants.NODE_VERSION)?.major ?? 0) < 20) {
    nodeVerWarn += vendor.yoctocolorsCjsExports.bold(
      `   ${vendor.yoctocolorsCjsExports.red('Warning:')} NodeJS version 19 and lower will be ${vendor.yoctocolorsCjsExports.red('unsupported')} after April 30th, 2025.`
    )
    nodeVerWarn += '\n'
    nodeVerWarn +=
      '            Soon after the Socket CLI will require NodeJS version 20 or higher.'
    nodeVerWarn += '\n'
  }
  const body = `
   _____         _       _        /---------------
  |   __|___ ___| |_ ___| |_      | Socket.dev CLI ver ${cliVersion}${v1test}
  |__   | ${readOnlyConfig} |  _| '_| -_|  _|     | Node: ${nodeVersion}, API token set: ${shownToken}${defaultOrg ? `, default org: ${redacting ? REDACTED : defaultOrg}` : ''}
  |_____|___|___|_,_|___|_|.dev   | Command: \`${command}\`, cwd: ${relCwd}`.trimStart()
  return `   ${body}\n${nodeVerWarn}${feedback}`
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$J } = constants
const config$M = {
  commandName: 'analytics',
  description: `Look up analytics data`,
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    file: {
      type: 'string',
      shortFlag: 'f',
      default: '-',
      description:
        'Filepath to save output. Only valid with --json/--markdown. Defaults to stdout.'
    },
    repo: {
      type: 'string',
      shortFlag: 'r',
      default: '',
      description: 'Name of the repository. Only valid when scope=repo'
    },
    scope: {
      type: 'string',
      shortFlag: 's',
      default: 'org',
      description:
        "Scope of the analytics data - either 'org' or 'repo', default: org"
    },
    time: {
      type: 'number',
      shortFlag: 't',
      default: 7,
      description: 'Time filter - either 7, 30 or 90, default: 7'
    }
  },
  help: (command, { flags }) =>
    `
    Usage
      $ ${command} ${shadowNpmInject.isTestingV1() ? '[ org | repo <reponame>] [time]' : '--scope=<scope> --time=<time filter>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: report:write

    ${shadowNpmInject.isTestingV1() ? '' : 'Default parameters are set to show the organization-level analytics over the'}
    ${shadowNpmInject.isTestingV1() ? '' : 'last 7 days.'}

    ${shadowNpmInject.isTestingV1() ? 'The scope is either org or repo level, defaults to org.' : ''}

    ${shadowNpmInject.isTestingV1() ? 'When scope is repo, a repo slug must be given as well.' : ''}

    ${shadowNpmInject.isTestingV1() ? 'The time argument must be number 7, 30, or 90 and defaults to 7.' : ''}

    Options
      ${getFlagListOutput(flags, 6)}

    Examples
      $ ${command} ${shadowNpmInject.isTestingV1() ? 'org 7' : '--scope=org --time=7'}
      $ ${command} ${shadowNpmInject.isTestingV1() ? 'repo test-repo 30' : '--scope=org --time=30'}
      $ ${command} ${shadowNpmInject.isTestingV1() ? '90' : '--scope=repo --repo=test-repo --time=30'}
  `
      // Drop consecutive empty lines. Temporarily necessary to deal with v1 prep.
      .replace(/\n(?: *\n)+/g, '\n\n')
}
const cmdAnalytics = {
  description: config$M.description,
  hidden: config$M.hidden,
  run: run$M
}
async function run$M(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$M,
    importMeta,
    parentName
  })
  const { file, json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)

  // In v1 mode support:
  // - []        (no args)
  // - ['org']
  // - ['org', '30']
  // - ['repo', 'name']
  // - ['repo', 'name', '30']
  // - ['30']
  // Validate final values in the next step
  let scope = 'org'
  let time = shadowNpmInject.isTestingV1() ? '7' : 7
  let repoName = ''
  if (shadowNpmInject.isTestingV1()) {
    if (cli.input[0] === 'org') {
      if (cli.input[1]) {
        time = cli.input[1]
      }
    } else if (cli.input[0] === 'repo') {
      scope = 'repo'
      if (cli.input[1]) {
        repoName = cli.input[1]
      }
      if (cli.input[2]) {
        time = cli.input[2]
      }
    } else if (cli.input[0]) {
      time = cli.input[0]
    }
  } else {
    if (cli.flags['scope']) {
      scope = String(cli.flags['scope'] || '')
    }
    if (scope === 'repo') {
      repoName = String(cli.flags['repoName'] || '')
    }
    if (cli.flags['time']) {
      time = Number(cli.flags['time'] || 7)
    }
  }
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      // In v1 this can't go wrong anymore since the unknown value goes to time
      nook: !shadowNpmInject.isTestingV1(),
      test: scope === 'org' || scope === 'repo',
      message: 'Scope must be "repo" or "org"',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: scope === 'org' || !!repoName,
      message: shadowNpmInject.isTestingV1()
        ? 'When scope=repo, repo name should be the second argument'
        : 'When scope=repo, repo name should be set through --repo',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test:
        scope === 'org' ||
        (shadowNpmInject.isTestingV1() &&
          repoName !== '7' &&
          repoName !== '30' &&
          repoName !== '90'),
      message: 'Missing the repo name as second argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      test: shadowNpmInject.isTestingV1()
        ? time === '7' || time === '30' || time === '90'
        : time === 7 || time === 30 || time === 90,
      message: 'The time filter must either be 7, 30 or 90',
      pass: 'ok',
      fail: shadowNpmInject.isTestingV1()
        ? 'invalid range set, see --help for command arg details.'
        : 'bad'
    },
    {
      nook: true,
      test: file === '-' || !!json || !!markdown,
      message:
        'The `--file` flag is only valid when using `--json` or `--markdown`',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$J)
    return
  }
  return await handleAnalytics({
    scope,
    time: time === '90' ? 90 : time === '30' ? 30 : 7,
    repo: repoName,
    outputKind,
    filePath: String(file || '')
  })
}

async function fetchAuditLog({ logType, orgSlug, outputKind, page, perPage }) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start(`Looking up audit log for ${orgSlug}`)
  const result = await handleApiCall(
    sockSdk.getAuditLogEvents(orgSlug, {
      // I'm not sure this is used at all.
      outputJson: String(outputKind === 'json'),
      // I'm not sure this is used at all.
      outputMarkdown: String(outputKind === 'markdown'),
      orgSlug,
      type: logType,
      page: String(page),
      per_page: String(perPage)
    }),
    `Looking up audit log for ${orgSlug}\n`
  )
  spinner.successAndStop(`Received API response.`)
  if (!result.success) {
    return handleFailedApiResponse('getAuditLogEvents', result)
  }
  return {
    ok: true,
    data: result.data
  }
}

const { REDACTED } = constants
async function outputAuditLog(
  auditLogs,
  { logType, orgSlug, outputKind, page, perPage }
) {
  if (outputKind === 'json') {
    logger.logger.log(
      await outputAsJson(auditLogs, {
        logType,
        orgSlug,
        page,
        perPage
      })
    )
  } else if (outputKind !== 'markdown' && !auditLogs.ok) {
    logger.logger.fail(failMsgWithBadge(auditLogs.message, auditLogs.data))
  } else {
    logger.logger.log(
      await outputAsMarkdown(auditLogs, {
        logType,
        orgSlug,
        page,
        perPage
      })
    )
  }
}
async function outputAsJson(auditLogs, { logType, orgSlug, page, perPage }) {
  if (!auditLogs.ok) {
    return serializeResultJson(auditLogs)
  }
  return serializeResultJson({
    ok: true,
    data: {
      desc: 'Audit logs for given query',
      // Lazily access constants.ENV.VITEST.
      generated: constants.ENV.VITEST ? REDACTED : new Date().toISOString(),
      org: orgSlug,
      logType,
      page,
      nextPage: auditLogs.data.nextPage,
      perPage,
      logs: auditLogs.data.results.map(log => {
        // Note: The subset is pretty arbitrary
        const {
          created_at,
          event_id,
          ip_address,
          type,
          user_agent,
          user_email
        } = log
        return {
          event_id,
          created_at,
          ip_address,
          type,
          user_agent,
          user_email
        }
      })
    }
  })
}
async function outputAsMarkdown(
  auditLogs,
  { logType, orgSlug, page, perPage }
) {
  if (!auditLogs.ok) {
    return `
# Socket Audit Logs

There was a problem fetching the audit logs:

> ${auditLogs.message}
${
  auditLogs.data
    ? '>\n' +
      auditLogs.data
        .split('\n')
        .map(s => `> ${s}\n`)
        .join('')
    : ''
}
Parameters:

- org: ${orgSlug}
- type filter: ${logType || '(none)'}
- page: ${page}
- per page: ${perPage}
`
  }
  try {
    const table = mdTable(auditLogs.data.results, [
      'event_id',
      'created_at',
      'type',
      'user_email',
      'ip_address',
      'user_agent'
    ])
    return `
# Socket Audit Logs

These are the Socket.dev audit logs as per requested query.
- org: ${orgSlug}
- type filter: ${logType || '(none)'}
- page: ${page}
- next page: ${auditLogs.data.nextPage}
- per page: ${perPage}
- generated: ${constants.ENV.VITEST ? REDACTED : new Date().toISOString()}

${table}
`
  } catch (e) {
    process$1.exitCode = 1
    logger.logger.fail(
      'There was a problem converting the logs to Markdown, please try the `--json` flag'
    )
    if (debug.isDebug()) {
      debug.debugLog('Error:\n', e)
    }
    // logger.error(e)
    return ''
  }
}

async function handleAuditLog({ logType, orgSlug, outputKind, page, perPage }) {
  const auditLogs = await fetchAuditLog({
    orgSlug,
    outputKind,
    page,
    perPage,
    logType
  })
  await outputAuditLog(auditLogs, {
    logType,
    orgSlug,
    outputKind,
    page,
    perPage
  })
}

async function suggestOrgSlug() {
  const sockSdk = await shadowNpmInject.setupSdk()
  const result = await handleApiCall(
    sockSdk.getOrganizations(),
    'looking up organizations'
  )
  // Ignore a failed request here. It was not the primary goal of
  // running this command and reporting it only leads to end-user confusion.
  if (result.success) {
    const proceed = await prompts.select({
      message:
        'Missing org name; do you want to use any of these orgs for this scan?',
      choices: [
        ...Object.values(result.data.organizations).map(org => {
          const slug = org.name ?? 'undefined'
          return {
            name: `Yes [${slug}]`,
            value: slug,
            description: `Use "${slug}" as the organization`
          }
        }),
        {
          name: 'No',
          value: '',
          description:
            'Do not use any of these organizations (will end in a no-op)'
        }
      ]
    })
    if (proceed) {
      return proceed
    }
  } else {
    logger.logger.fail(
      'Failed to lookup organization list from API, unable to suggest'
    )
  }
}

async function determineOrgSlug(orgFlag, firstArg, interactive, dryRun) {
  const defaultOrgSlug = shadowNpmInject.getConfigValue('defaultOrg') || ''
  let orgSlug = String(orgFlag || defaultOrgSlug || '')
  if (!orgSlug) {
    if (shadowNpmInject.isTestingV1()) {
      // ask from server
      logger.logger.error(
        'Missing the org slug and no --org flag set. Trying to auto-discover the org now...'
      )
      logger.logger.error(
        'Note: you can set the default org slug to prevent this issue. You can also override all that with the --org flag.'
      )
      if (dryRun) {
        logger.logger.fail('Skipping auto-discovery of org in dry-run mode')
      } else if (!interactive) {
        logger.logger.fail(
          'Skipping auto-discovery of org when interactive = false'
        )
      } else {
        orgSlug = (await suggestOrgSlug()) || ''
      }
    } else {
      orgSlug = firstArg || ''
    }
  }
  return [orgSlug, defaultOrgSlug]
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$I } = constants
const config$L = {
  commandName: 'audit-log',
  description: 'Look up the audit log for an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    type: {
      type: 'string',
      shortFlag: 't',
      default: '',
      description: 'Type of log event'
    },
    perPage: {
      type: 'number',
      shortFlag: 'pp',
      default: 30,
      description: 'Results per page - default is 30'
    },
    page: {
      type: 'number',
      shortFlag: 'p',
      default: 1,
      description: 'Page number - default is 1'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} ${shadowNpmInject.isTestingV1() ? '<repo>' : '<org slug>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: audit-log:list

    This feature requires an Enterprise Plan. To learn more about getting access
    to this feature and many more, please visit https://socket.dev/pricing

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} ${shadowNpmInject.isTestingV1() ? '' : 'FakeOrg'}
  `
}
const cmdAuditLog = {
  description: config$L.description,
  hidden: config$L.hidden,
  run: run$L
}
async function run$L(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$L,
    importMeta,
    parentName
  })
  const {
    dryRun,
    interactive,
    json,
    markdown,
    org: orgFlag,
    page,
    perPage,
    type
  } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const logType = String(type || '')
  const [orgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$I)
    return
  }
  await handleAuditLog({
    orgSlug,
    outputKind,
    page: Number(page || 0),
    perPage: Number(perPage || 0),
    logType: logType.charAt(0).toUpperCase() + logType.slice(1)
  })
}

const {
  NPM: NPM$g,
  NPX: NPX$3,
  PACKAGE_LOCK_JSON,
  PNPM: PNPM$a,
  YARN: YARN$1,
  YARN_LOCK
} = constants
const nodejsPlatformTypes = new Set([
  'javascript',
  'js',
  'nodejs',
  NPM$g,
  PNPM$a,
  'ts',
  'tsx',
  'typescript'
])
async function runCycloneDX(yargvWithYes) {
  let cleanupPackageLock = false
  const { yes, ...yargv } = {
    __proto__: null,
    ...yargvWithYes
  }
  const yesArgs = yes ? ['--yes'] : []
  if (
    yargv.type !== YARN$1 &&
    nodejsPlatformTypes.has(yargv.type) &&
    fs$1.existsSync(`./${YARN_LOCK}`)
  ) {
    if (fs$1.existsSync(`./${PACKAGE_LOCK_JSON}`)) {
      yargv.type = NPM$g
    } else {
      // Use synp to create a package-lock.json from the yarn.lock,
      // based on the node_modules folder, for a more accurate SBOM.
      try {
        await shadowBin(NPX$3, [
          ...yesArgs,
          // Lazily access constants.ENV.INLINED_SYNP_VERSION.
          `synp@${constants.ENV.INLINED_SYNP_VERSION}`,
          '--source-file',
          `./${YARN_LOCK}`
        ])
        yargv.type = NPM$g
        cleanupPackageLock = true
      } catch {}
    }
  }
  await shadowBin(NPX$3, [
    ...yesArgs,
    // Lazily access constants.ENV.INLINED_CYCLONEDX_CDXGEN_VERSION.
    `@cyclonedx/cdxgen@${constants.ENV.INLINED_CYCLONEDX_CDXGEN_VERSION}`,
    ...argvToArray(yargv)
  ])
  if (cleanupPackageLock) {
    try {
      await fs$1.promises.rm(`./${PACKAGE_LOCK_JSON}`)
    } catch {}
  }
  const fullOutputPath = path$1.join(process$1.cwd(), yargv.output)
  if (fs$1.existsSync(fullOutputPath)) {
    logger.logger.log(
      vendor.yoctocolorsCjsExports.cyanBright(`${yargv.output} created!`)
    )
  }
}
function argvToArray(argv) {
  if (argv['help']) {
    return ['--help']
  }
  const result = []
  for (const { 0: key, 1: value } of Object.entries(argv)) {
    if (key === '_' || key === '--') {
      continue
    }
    if (key === 'babel' || key === 'install-deps' || key === 'validate') {
      // cdxgen documents no-babel, no-install-deps, and no-validate flags so
      // use them when relevant.
      result.push(`--${value ? key : `no-${key}`}`)
    } else if (value === true) {
      result.push(`--${key}`)
    } else if (typeof value === 'string') {
      result.push(`--${key}`, String(value))
    } else if (Array.isArray(value)) {
      result.push(`--${key}`, ...value.map(String))
    }
  }
  if (argv['--']) {
    result.push('--', ...argv['--'])
  }
  return result
}

const helpFlags = new Set(['--help', '-h'])
function cmdFlagsToString(args) {
  const result = []
  for (let i = 0, { length } = args; i < length; i += 1) {
    if (args[i].startsWith('--')) {
      // Check if the next item exists and is NOT another flag.
      if (i + 1 < length && !args[i + 1].startsWith('--')) {
        result.push(`${args[i]}=${args[i + 1]}`)
        i += 1
      } else {
        result.push(args[i])
      }
    }
  }
  return result.join(' ')
}
function cmdPrefixMessage(cmdName, text) {
  const cmdPrefix = cmdName ? `${cmdName}: ` : ''
  return `${cmdPrefix}${text}`
}
function isHelpFlag(cmdArg) {
  return helpFlags.has(cmdArg)
}

// import { meowOrExit } from '../../utils/meow-with-subcommands'
const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$H } = constants

// TODO: convert yargs to meow. Or convert all the other things to yargs.
const toLower = arg => arg.toLowerCase()
const arrayToLower = arg => arg.map(toLower)
const yargsConfig = {
  configuration: {
    'camel-case-expansion': false,
    'strip-aliased': true,
    'parse-numbers': false,
    'populate--': true,
    'unknown-options-as-args': true
  },
  coerce: {
    author: arrayToLower,
    filter: arrayToLower,
    only: arrayToLower,
    profile: toLower,
    standard: arrayToLower,
    type: arrayToLower
  },
  default: {
    //author: ['OWASP Foundation'],
    //'auto-compositions': true,
    //babel: true,
    //evidence: false,
    //'include-crypto': false,
    //'include-formulation': false,

    // Default 'install-deps' to `false` and 'lifecycle' to 'pre-build' to
    // sidestep arbitrary code execution during a cdxgen scan.
    // https://github.com/CycloneDX/cdxgen/issues/1328
    'install-deps': false,
    lifecycle: 'pre-build',
    //output: 'bom.json',
    //profile: 'generic',
    //'project-version': '',
    //recurse: true,
    //'server-host': '127.0.0.1',
    //'server-port': '9090',
    //'spec-version': '1.5',
    type: ['js']
    //validate: true,
  },
  alias: {
    help: ['h'],
    output: ['o'],
    print: ['p'],
    recurse: ['r'],
    'resolve-class': ['c'],
    type: ['t'],
    version: ['v'],
    yes: ['y']
  },
  array: [
    {
      key: 'author',
      type: 'string'
    },
    {
      key: 'exclude',
      type: 'string'
    },
    {
      key: 'filter',
      type: 'string'
    },
    {
      key: 'only',
      type: 'string'
    },
    {
      key: 'standard',
      type: 'string'
    },
    {
      key: 'type',
      type: 'string'
    }
  ],
  boolean: [
    'auto-compositions',
    'babel',
    'deep',
    'evidence',
    'fail-on-error',
    'generate-key-and-sign',
    'help',
    'include-formulation',
    'include-crypto',
    'install-deps',
    'print',
    'required-only',
    'server',
    'validate',
    'version',
    // The --yes flag and -y alias map to the corresponding flag and alias of npx.
    // https://docs.npmjs.com/cli/v7/commands/npx#compatibility-with-older-npx-versions
    'yes'
  ],
  string: [
    'api-key',
    'lifecycle',
    'output',
    'parent-project-id',
    'profile',
    'project-group',
    'project-name',
    'project-version',
    'project-id',
    'server-host',
    'server-port',
    'server-url',
    'spec-version'
  ]
}
const config$K = {
  commandName: 'cdxgen',
  description: 'Create an SBOM with CycloneDX generator (cdxgen)',
  hidden: false,
  flags: {
    // TODO: convert from yargsConfig
  },
  help: (command, config) => `
    Usage
      $ ${command} [options]

    Options
      ${getFlagListOutput(config.flags, 6)}
  `
}
const cmdCdxgen = {
  description: config$K.description,
  hidden: config$K.hidden,
  run: run$K
}
async function run$K(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    allowUnknownFlags: true,
    // Don't let meow take over --help.
    argv: argv.filter(a => !isHelpFlag(a)),
    config: config$K,
    importMeta,
    parentName
  })

  // TODO: Convert to meow.
  const yargv = {
    ...vendor.yargsParser(argv, yargsConfig)
  }
  const unknown = yargv._
  const { length: unknownLength } = unknown
  if (unknownLength) {
    // Use exit status of 2 to indicate incorrect usage, generally invalid
    // options or missing arguments.
    // https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html
    process.exitCode = 2
    logger.logger.fail(
      `Unknown ${words.pluralize('argument', unknownLength)}: ${yargv._.join(', ')}`
    )
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$H)
    return
  }
  if (yargv.output === undefined) {
    yargv.output = 'socket-cdx.json'
  }
  await runCycloneDX(yargv)
}

// Use the config defaultOrg when set, otherwise discover from remote
async function getDefaultOrgSlug() {
  let defaultOrg = shadowNpmInject.getConfigValue('defaultOrg')
  if (defaultOrg) {
    logger.logger.info(`Using default org: ${defaultOrg}`)
  } else {
    const sockSdk = await shadowNpmInject.setupSdk()
    const result = await handleApiCall(
      sockSdk.getOrganizations(),
      'looking up organizations'
    )
    // Ignore a failed request here. It was not the primary goal of
    // running this command and reporting it only leads to end-user confusion.
    if (!result.success) {
      process.exitCode = 1
      return {
        ok: false,
        message: result.error,
        data: `Failed to fetch default organization from API. Unable to continue.${result.cause ? ` ( Reason given: ${result.cause} )` : ''}`
      }
    }
    const orgs = result.data.organizations
    const keys = Object.keys(orgs)
    if (!keys[0]) {
      process.exitCode = 1
      return {
        ok: false,
        message: 'Failed to establish identity',
        data: `API did not return any organization associated with the current API token. Unable to continue.`
      }
    }
    const slug = (keys[0] in orgs && orgs?.[keys[0]]?.name) ?? undefined
    if (slug) {
      defaultOrg = slug
      debug.debugLog(`Resolved org to: ${defaultOrg}`)
    }
  }
  if (!defaultOrg) {
    process.exitCode = 1
    return {
      ok: false,
      message: 'Failed to establish identity',
      data: `Was unable to determine the default organization for the current API token. Unable to continue.`
    }
  }
  return {
    ok: true,
    data: defaultOrg
  }
}

async function fetchCreateOrgFullScan(
  packagePaths,
  orgSlug,
  defaultBranch,
  pendingHead,
  tmp,
  cwd,
  { branchName, commitHash, commitMessage, committers, pullRequest, repoName }
) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start(
    `Sending request to create a scan with ${packagePaths.length} packages...`
  )
  const result = await handleApiCall(
    sockSdk.createOrgFullScan(
      orgSlug,
      {
        ...(branchName
          ? {
              branch: branchName
            }
          : {}),
        ...(commitHash
          ? {
              commit_hash: commitHash
            }
          : {}),
        ...(commitMessage
          ? {
              commit_message: commitMessage
            }
          : {}),
        ...(committers
          ? {
              committers
            }
          : {}),
        make_default_branch: String(defaultBranch),
        ...(pullRequest
          ? {
              pull_request: String(pullRequest)
            }
          : {}),
        repo: repoName || 'socket-default-repository',
        // mandatory, this is server default for repo
        set_as_pending_head: String(pendingHead),
        tmp: String(tmp)
      },
      packagePaths,
      cwd
    ),
    'Creating scan'
  )
  spinner.successAndStop('Completed request to create a new scan.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('CreateOrgFullScan', result)
  }
  return result.data
}

async function fetchSupportedScanFileNames() {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Requesting supported scan file types from API...')
  const result = await handleApiCall(
    sockSdk.getReportSupportedFiles(),
    'fetching supported scan file types'
  )
  spinner.stop()
  logger.logger.success(
    'Received response while fetched supported scan file types.'
  )
  if (!result.success) {
    handleUnsuccessfulApiResponse('getReportSupportedFiles', result)
  }
  return result.data
}

/**
 * This fetches all the relevant pieces of data to generate a report, given a
 * full scan ID.
 */
async function fetchReportData(orgSlug, scanId, includeLicensePolicy) {
  const apiToken = shadowNpmInject.getDefaultToken()
  if (!apiToken) {
    throw new shadowNpmInject.AuthError(
      'User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.'
    )
  }
  const sockSdk = await shadowNpmInject.setupSdk(apiToken)
  let scanStatus = 'requested..'
  let policyStatus = 'requested..'
  let finishedFetching = false

  // Lazily access constants.spinner.
  const { spinner } = constants
  function updateScan(desc) {
    scanStatus = desc
    updateProgress()
  }
  function updatePolicy(desc) {
    policyStatus = desc
    updateProgress()
  }
  function updateProgress() {
    if (finishedFetching) {
      spinner.stop()
      logger.logger.info(
        `Scan result: ${scanStatus}. Security policy: ${policyStatus}.`
      )
    } else {
      spinner.start(
        `Scan result: ${scanStatus}. Security policy: ${policyStatus}.`
      )
    }
  }
  async function fetchScanResult(apiToken) {
    const response = await queryApi(
      `orgs/${orgSlug}/full-scans/${encodeURIComponent(scanId)}${includeLicensePolicy ? '?include_license_details=true' : ''}`,
      apiToken
    )
    updateScan('received response')
    if (!response.ok) {
      spinner.stop()
      const err = await handleApiError(response.status)
      logger.logger.fail(
        failMsgWithBadge(response.statusText, `Fetch error: ${err}`)
      )
      debug.debugLog(err)
      updateScan(`request resulted in status code ${response.status}`)
      return undefined
    }
    updateScan(`ok, downloading response..`)
    const jsons = await response.text()
    updateScan(`received`)
    const lines = jsons.split('\n').filter(Boolean)
    const data = lines.map(line => {
      try {
        return JSON.parse(line)
      } catch {
        scanStatus = `received invalid JSON response`
        spinner.stop()
        logger.logger.error(
          'Response was not valid JSON but it ought to be (please report if this persists)'
        )
        debug.debugLog(line)
        updateProgress()
        return
      }
    })
    return data
  }
  async function fetchSecurityPolicy() {
    const r = await sockSdk.getOrgSecurityPolicy(orgSlug)
    updatePolicy('received response')
    const s = await handleApiCall(
      r,
      "looking up organization's security policy"
    )
    updatePolicy('received')
    return s
  }
  updateProgress()
  const [scan, securityPolicyMaybe] = await Promise.all([
    fetchScanResult(apiToken).catch(e => {
      updateScan(`failure; unknown blocking problem occurred`)
      throw e
    }),
    fetchSecurityPolicy().catch(e => {
      updatePolicy(`failure; unknown blocking problem occurred`)
      throw e
    })
  ]).finally(() => {
    finishedFetching = true
    updateProgress()
  })
  if (!Array.isArray(scan)) {
    logger.logger.error('Was unable to fetch scan result, bailing')
    process.exitCode = 1
    return {
      ok: false,
      scan: undefined,
      securityPolicy: undefined
    }
  }
  if (!securityPolicyMaybe?.success) {
    logger.logger.error('Was unable to fetch security policy, bailing')
    process.exitCode = 1
    return {
      ok: false,
      scan: undefined,
      securityPolicy: undefined
    }
  }
  return {
    ok: true,
    scan,
    securityPolicy: securityPolicyMaybe
  }
}

function generateReport(
  scan,
  securityPolicy,
  { fold, orgSlug, reportLevel, scanId, short, spinner }
) {
  const now = Date.now()
  spinner?.start('Generating report...')

  // Create an object that includes:
  //   healthy: boolean
  //   worst violation level;
  //   per eco
  //     per package
  //       per version
  //         per offending file
  //           reported issue -> policy action

  // In the context of a report;
  // - the alert.severity is irrelevant
  // - the securityPolicyDefault is irrelevant
  // - the report defaults to healthy:true with no alerts
  // - the appearance of an alert will trigger the policy action;
  //   - error: healthy will end up as false, add alerts to report
  //   - warn: healthy unchanged, add alerts to report
  //   - monitor/ignore: no action
  //   - defer: unknown (no action)

  // Note: the server will emit alerts for license policy violations but
  //       those are only included if you set the flag when requesting the scan
  //       data. The alerts map to a single security policy key that determines
  //       what to do with any violation, regardless of the concrete license.
  //       That rule is called "License Policy Violation".
  // The license policy part is implicitly handled here. Either they are
  // included and may show up, or they are not and won't show up.

  const violations = new Map()
  let healthy = true
  const securityRules = securityPolicy.data.securityPolicyRules
  if (securityRules) {
    // Note: reportLevel: error > warn > monitor > ignore > defer
    scan.forEach(artifact => {
      const {
        alerts,
        name: pkgName = '<unknown>',
        type: ecosystem,
        version = '<unknown>'
      } = artifact
      alerts?.forEach(alert => {
        const alertName = alert.type // => policy[type]
        const action = securityRules[alertName]?.action || ''
        switch (action) {
          case 'error': {
            healthy = false
            if (!short) {
              addAlert(
                artifact,
                violations,
                fold,
                ecosystem,
                pkgName,
                version,
                alert,
                action
              )
            }
            break
          }
          case 'warn': {
            if (!short && reportLevel !== 'error') {
              addAlert(
                artifact,
                violations,
                fold,
                ecosystem,
                pkgName,
                version,
                alert,
                action
              )
            }
            break
          }
          case 'monitor': {
            if (!short && reportLevel !== 'warn' && reportLevel !== 'error') {
              addAlert(
                artifact,
                violations,
                fold,
                ecosystem,
                pkgName,
                version,
                alert,
                action
              )
            }
            break
          }
          case 'ignore': {
            if (
              !short &&
              reportLevel !== 'warn' &&
              reportLevel !== 'error' &&
              reportLevel !== 'monitor'
            ) {
              addAlert(
                artifact,
                violations,
                fold,
                ecosystem,
                pkgName,
                version,
                alert,
                action
              )
            }
            break
          }
          case 'defer': {
            // Not sure but ignore for now. Defer to later ;)
            if (!short && reportLevel === 'defer') {
              addAlert(
                artifact,
                violations,
                fold,
                ecosystem,
                pkgName,
                version,
                alert,
                action
              )
            }
            break
          }
        }
      })
    })
  }
  spinner?.successAndStop(`Generated reported in ${Date.now() - now} ms`)
  const report = short
    ? {
        healthy
      }
    : {
        healthy,
        orgSlug,
        scanId,
        options: {
          fold,
          reportLevel
        },
        alerts: violations
      }
  return report
}
function createLeaf(art, alert, policyAction) {
  const leaf = {
    type: alert.type,
    policy: policyAction,
    url: `https://socket.dev/${art.type}/package/${art.name}/${art.version}`,
    manifest: art.manifestFiles?.map(obj => obj.file) ?? []
  }
  return leaf
}
function addAlert(
  art,
  violations,
  foldSetting,
  ecosystem,
  pkgName,
  version,
  alert,
  policyAction
) {
  if (!violations.has(ecosystem)) {
    violations.set(ecosystem, new Map())
  }
  const ecomap = violations.get(ecosystem)
  if (foldSetting === 'pkg') {
    const existing = ecomap.get(pkgName)
    if (!existing || isStricterPolicy(existing.policy, policyAction)) {
      ecomap.set(pkgName, createLeaf(art, alert, policyAction))
    }
  } else {
    if (!ecomap.has(pkgName)) {
      ecomap.set(pkgName, new Map())
    }
    const pkgmap = ecomap.get(pkgName)
    if (foldSetting === 'version') {
      const existing = pkgmap.get(version)
      if (!existing || isStricterPolicy(existing.policy, policyAction)) {
        pkgmap.set(version, createLeaf(art, alert, policyAction))
      }
    } else {
      if (!pkgmap.has(version)) {
        pkgmap.set(version, new Map())
      }
      const file = alert.file || '<unknown>'
      const vermap = pkgmap.get(version)
      if (foldSetting === 'file') {
        const existing = vermap.get(file)
        if (!existing || isStricterPolicy(existing.policy, policyAction)) {
          vermap.set(file, createLeaf(art, alert, policyAction))
        }
      } else {
        if (!vermap.has(file)) {
          vermap.set(file, new Map())
        }
        const key = `${alert.type} at ${alert.start}:${alert.end}`
        const filemap = vermap.get(file)
        const existing = filemap.get(key)
        if (!existing || isStricterPolicy(existing.policy, policyAction)) {
          filemap.set(key, createLeaf(art, alert, policyAction))
        }
      }
    }
  }
}
function isStricterPolicy(was, is) {
  // error > warn > monitor > ignore > defer > {unknown}
  if (was === 'error') {
    return false
  }
  if (is === 'error') {
    return true
  }
  if (was === 'warn') {
    return false
  }
  if (is === 'warn') {
    return false
  }
  if (was === 'monitor') {
    return false
  }
  if (is === 'monitor') {
    return false
  }
  if (was === 'ignore') {
    return false
  }
  if (is === 'ignore') {
    return false
  }
  if (was === 'defer') {
    return false
  }
  if (is === 'defer') {
    return false
  }
  // unreachable?
  return false
}

/**
 * Convert a Map<string, Map|string> to a nested object of similar shape.
 * The goal is to serialize it with JSON.stringify, which Map can't do.
 */
function mapToObject(map) {
  return Object.fromEntries(
    Array.from(map.entries()).map(([k, v]) => [
      k,
      v instanceof Map ? mapToObject(v) : v
    ])
  )
}

function* walkNestedMap(map, keys = []) {
  for (const [key, value] of map.entries()) {
    if (value instanceof Map) {
      yield* walkNestedMap(value, keys.concat(key))
    } else {
      yield {
        keys: keys.concat(key),
        value: value
      }
    }
  }
}

async function outputScanReport(
  scan,
  securityPolicy,
  {
    filePath,
    fold,
    includeLicensePolicy,
    orgSlug,
    outputKind,
    reportLevel,
    scanId,
    short
  }
) {
  const scanReport = generateReport(scan, securityPolicy, {
    orgSlug,
    scanId,
    fold,
    reportLevel,
    short,
    // Lazily access constants.spinner.
    spinner: constants.spinner
  })
  if (!scanReport.healthy) {
    process.exitCode = 1
  }
  if (
    outputKind === 'json' ||
    (outputKind === 'text' && filePath && filePath.endsWith('.json'))
  ) {
    const json = short
      ? JSON.stringify(scanReport)
      : toJsonReport(scanReport, includeLicensePolicy)
    if (filePath && filePath !== '-') {
      logger.logger.log('Writing json report to', filePath)
      return await fs.writeFile(filePath, json)
    }
    logger.logger.log(json)
    return
  }
  if (outputKind === 'markdown' || (filePath && filePath.endsWith('.md'))) {
    const md = short
      ? `healthy = ${scanReport.healthy}`
      : toMarkdownReport(scanReport, includeLicensePolicy)
    if (filePath && filePath !== '-') {
      logger.logger.log('Writing markdown report to', filePath)
      return await fs.writeFile(filePath, md)
    }
    logger.logger.log(md)
    return
  }
  if (short) {
    logger.logger.log(scanReport.healthy ? 'OK' : 'ERR')
  } else {
    logger.logger.dir(scanReport, {
      depth: null
    })
  }
}
function toJsonReport(report, includeLicensePolicy) {
  const obj = mapToObject(report.alerts)
  const json = JSON.stringify(
    {
      includeLicensePolicy,
      ...report,
      alerts: obj
    },
    null,
    2
  )
  return json
}
function toMarkdownReport(report, includeLicensePolicy) {
  const flatData = Array.from(walkNestedMap(report.alerts)).map(
    ({ keys, value }) => {
      const { manifest, policy, type, url } = value
      return {
        'Alert Type': type,
        Package: keys[1] || '<unknown>',
        'Introduced by': keys[2] || '<unknown>',
        url,
        'Manifest file': manifest.join(', '),
        Policy: policy
      }
    }
  )
  const md =
    `
# Scan Policy Report

This report tells you whether the results of a Socket scan results violate the
security${includeLicensePolicy ? ' or license' : ''} policy set by your organization.

## Health status

${report.healthy ? `The scan *PASSES* all requirements set by your security${includeLicensePolicy ? ' and license' : ''} policy.` : 'The scan *VIOLATES* one or more policies set to the "error" level.'}

## Settings

Configuration used to generate this report:

- Organization: ${report.orgSlug}
- Scan ID: ${report.scanId}
- Alert folding: ${report.options.fold === 'none' ? 'none' : `up to ${report.options.fold}`}
- Minimal policy level for alert to be included in report: ${report.options.reportLevel === 'defer' ? 'everything' : report.options.reportLevel}
- Include license alerts: ${includeLicensePolicy ? 'yes' : 'no'}

## Alerts

${report.alerts.size ? `All the alerts from the scan with a policy set to at least "${report.options.reportLevel}"}.` : `The scan contained no alerts for with a policy set to at least "${report.options.reportLevel}".`}

${!report.alerts.size ? '' : mdTable(flatData, ['Policy', 'Alert Type', 'Package', 'Introduced by', 'url', 'Manifest file'])}
  `.trim() + '\n'
  return md
}

async function handleScanReport({
  filePath,
  fold,
  includeLicensePolicy,
  orgSlug,
  outputKind,
  reportLevel,
  scanId,
  short
}) {
  const { ok, scan, securityPolicy } = await fetchReportData(
    orgSlug,
    scanId,
    includeLicensePolicy
  )
  if (!ok) {
    return
  }
  await outputScanReport(scan, securityPolicy, {
    filePath,
    fold,
    scanId: scanId,
    includeLicensePolicy,
    orgSlug,
    outputKind,
    reportLevel,
    short
  })
}

async function outputCreateNewScan(data, outputKind, interactive) {
  if (!data.id) {
    logger.logger.fail('Did not receive a scan ID from the API...')
    process.exitCode = 1
  }
  if (outputKind === 'json') {
    const json = data.id
      ? {
          success: true,
          data
        }
      : {
          success: false,
          message: 'No scan ID received'
        }
    logger.logger.log(JSON.stringify(json, null, 2))
    logger.logger.log('')
    return
  }
  if (outputKind === 'markdown') {
    logger.logger.log('# Create New Scan')
    logger.logger.log('')
    if (data.id) {
      logger.logger.log(
        `A [new Scan](${data.html_report_url}) was created with ID: ${data.id}`
      )
      logger.logger.log('')
    } else {
      logger.logger.log(
        `The server did not return a Scan ID while trying to create a new Scan. This could be an indication something went wrong.`
      )
    }
    logger.logger.log('')
    return
  }
  const link = vendor.yoctocolorsCjsExports.underline(
    vendor.yoctocolorsCjsExports.cyan(`${data.html_report_url}`)
  )
  logger.logger.log(`Available at: ${link}`)
  if (
    interactive &&
    (await prompts.confirm({
      message: 'Would you like to open it in your browser?',
      default: false
    }))
  ) {
    await vendor.open(`${data.html_report_url}`)
  }
}

async function handleCreateNewScan({
  branchName,
  commitHash,
  commitMessage,
  committers,
  cwd,
  defaultBranch,
  interactive,
  orgSlug,
  outputKind,
  pendingHead,
  pullRequest,
  readOnly,
  repoName,
  report,
  targets,
  tmp
}) {
  const supportedFileNames = await fetchSupportedScanFileNames()
  if (!supportedFileNames) {
    return
  }
  const packagePaths = await shadowNpmPaths.getPackageFilesForScan(
    cwd,
    targets,
    supportedFileNames
  )
  if (
    handleBadInput({
      nook: true,
      test: packagePaths.length > 0,
      pass: 'ok',
      fail: 'found no eligible files to scan',
      message:
        'TARGET (file/dir) must contain matching / supported file types for a scan'
    })
  ) {
    return
  }
  if (readOnly) {
    logger.logger.log('[ReadOnly] Bailing now')
    return
  }
  const data = await fetchCreateOrgFullScan(
    packagePaths,
    orgSlug,
    defaultBranch,
    pendingHead,
    tmp,
    cwd,
    {
      commitHash,
      commitMessage,
      committers,
      pullRequest,
      repoName,
      branchName
    }
  )
  if (!data) {
    return
  }
  if (report) {
    if (data?.id) {
      await handleScanReport({
        filePath: '-',
        fold: 'version',
        includeLicensePolicy: true,
        orgSlug,
        outputKind,
        reportLevel: 'error',
        scanId: data.id,
        short: false
      })
    } else {
      logger.logger.fail('Failure: Server did not respond with a scan ID')
      process.exitCode = 1
    }
  } else {
    await outputCreateNewScan(data, outputKind, interactive)
  }
}

async function handleCI() {
  // ci: {
  //   description: 'Alias for "report create --view --strict"',
  //     argv: ['report', 'create', '--view', '--strict']
  // }
  const result = await getDefaultOrgSlug()
  if (!result.ok) {
    // Always assume json mode
    logger.logger.log(serializeResultJson(result))
    return
  }

  // TODO: does it make sense to discover the commit details from local git?
  // TODO: does it makes sense to use custom branch/repo names here? probably socket.yml, right
  await handleCreateNewScan({
    branchName: 'socket-default-branch',
    commitMessage: '',
    commitHash: '',
    committers: '',
    cwd: process.cwd(),
    defaultBranch: false,
    interactive: false,
    orgSlug: result.data,
    outputKind: 'json',
    pendingHead: true,
    // when true, requires branch name set, tmp false
    pullRequest: 0,
    repoName: 'socket-default-repository',
    readOnly: false,
    report: true,
    targets: ['.'],
    tmp: false // don't set when pendingHead is true
  })
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$G } = constants
const config$J = {
  commandName: 'ci',
  description:
    'Create a new scan and report whether it passes your security policy',
  hidden: true,
  flags: {
    ...commonFlags
  },
  help: (parentName, _config) => `
    Usage
      $ ${parentName}

    This command is intended to use in CI runs to allow automated systems to
    accept or reject a current build. When the scan does not pass your security
    policy, the exit code will be non-zero.

    It will use the default org for the set API token.
  `
}
const cmdCI = {
  description: config$J.description,
  hidden: config$J.hidden,
  run: run$J
}
async function run$J(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$J,
    importMeta,
    parentName
  })
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$G)
    return
  }
  await handleCI()
}

async function discoverConfigValue(key) {
  // This will have to be a specific implementation per key because certain
  // keys should request information from particular API endpoints while
  // others should simply return their default value, like endpoint URL.

  if (!shadowNpmInject.supportedConfigKeys.has(key)) {
    return {
      success: false,
      value: undefined,
      message: 'Requested key is not a valid config key.'
    }
  }
  if (key === 'apiBaseUrl') {
    // Return the default value
    return {
      success: false,
      value: undefined,
      message:
        "If you're unsure about the base endpoint URL then simply unset it."
    }
  }
  if (key === 'apiProxy') {
    // I don't think we can auto-discover this with any order of reliability..?
    return {
      success: false,
      value: undefined,
      message:
        'When uncertain, unset this key. Otherwise ask your network administrator'
    }
  }
  if (key === 'apiToken') {
    return {
      success: false,
      value: undefined,
      message:
        'You can find/create your API token in your Socket dashboard > settings > API tokens.\nYou should then use `socket login` to login instead of this command.'
    }
  }
  if (key === 'defaultOrg') {
    const apiToken = shadowNpmInject.getDefaultToken()
    if (!apiToken) {
      return {
        success: false,
        value: undefined,
        message:
          'No API token set, must have a token to resolve its default org.'
      }
    }
    const org = await getDefaultOrgFromToken()
    if (!org?.length) {
      return {
        success: false,
        value: undefined,
        message:
          'Was unable to determine default org for the current API token.'
      }
    }
    if (Array.isArray(org)) {
      return {
        success: true,
        value: org,
        message: 'These are the orgs that the current API token can access.'
      }
    }
    return {
      success: true,
      value: org,
      message: 'This is the org that belongs to the current API token.'
    }
  }
  if (key === 'enforcedOrgs') {
    const apiToken = shadowNpmInject.getDefaultToken()
    if (!apiToken) {
      return {
        success: false,
        value: undefined,
        message:
          'No API token set, must have a token to resolve orgs to enforce.'
      }
    }
    const orgs = await getEnforceableOrgsFromToken()
    if (!orgs?.length) {
      return {
        success: false,
        value: undefined,
        message:
          'Was unable to determine any orgs to enforce for the current API token.'
      }
    }
    return {
      success: true,
      value: orgs,
      message: 'These are the orgs whose security policy you can enforce.'
    }
  }
  if (key === 'test') {
    return {
      success: false,
      value: undefined,
      message: ''
    }
  }

  // Mostly to please TS, because we're not telling it `key` is keyof LocalConfig
  return {
    success: false,
    value: undefined,
    message: 'unreachable?'
  }
}
async function getDefaultOrgFromToken() {
  const sockSdk = await shadowNpmInject.setupSdk()
  const result = await handleApiCall(
    sockSdk.getOrganizations(),
    'looking up organizations'
  )
  if (result.success) {
    const arr = Array.from(Object.values(result.data.organizations)).map(
      ({ slug }) => slug
    )
    if (arr.length === 0) {
      return undefined
    }
    if (arr.length === 1) {
      return arr[0]
    }
    return arr
  }
  return undefined
}
async function getEnforceableOrgsFromToken() {
  const sockSdk = await shadowNpmInject.setupSdk()
  const result = await handleApiCall(
    sockSdk.getOrganizations(),
    'looking up organizations'
  )
  if (result.success) {
    const arr = Array.from(Object.values(result.data.organizations)).map(
      ({ slug }) => slug
    )
    if (arr.length === 0) {
      return undefined
    }
    return arr
  }
  return undefined
}

async function outputConfigAuto(key, { message, success, value }, outputKind) {
  if (outputKind === 'json') {
    logger.logger.log(
      JSON.stringify({
        success,
        message,
        result: {
          key,
          value
        }
      })
    )
  } else if (outputKind === 'markdown') {
    logger.logger.log(`# Auto discover config value`)
    logger.logger.log('')
    logger.logger.log(
      `Attempted to automatically discover the value for config key: "${key}"`
    )
    logger.logger.log('')
    if (success) {
      logger.logger.log(`The discovered value is: "${value}"`)
      if (message) {
        logger.logger.log('')
        logger.logger.log(message)
      }
    } else {
      logger.logger.log(`The discovery failed: ${message}`)
    }
    logger.logger.log('')
  } else {
    if (message) {
      logger.logger.log(message)
      logger.logger.log('')
    }
    logger.logger.log(`- ${key}: ${value}`)
    logger.logger.log('')
    if (success) {
      if (key === 'defaultOrg') {
        const proceed = await prompts.select({
          message:
            'Would you like to update the default org in local config to this value?',
          choices: (Array.isArray(value) ? value : [value])
            .map(slug => ({
              name: 'Yes [' + slug + ']',
              value: slug,
              description: `Use "${slug}" as the default organization`
            }))
            .concat({
              name: 'No',
              value: '',
              description: 'Do not use any of these organizations'
            })
        })
        if (proceed) {
          logger.logger.log(
            `OK. Setting defaultOrg to "${proceed}".\nYou should no longer need to add the org to commands that normally require it.`
          )
          shadowNpmInject.updateConfigValue('defaultOrg', proceed)
        } else {
          logger.logger.log('OK. No changes made.')
        }
      } else if (key === 'enforcedOrgs') {
        const proceed = await prompts.select({
          message:
            'Would you like to update the enforced orgs in local config to this value?',
          choices: (Array.isArray(value) ? value : [value])
            .map(slug => ({
              name: 'Yes [' + slug + ']',
              value: slug,
              description: `Enforce the security policy of "${slug}" on this machine`
            }))
            .concat({
              name: 'No',
              value: '',
              description: 'Do not use any of these organizations'
            })
        })
        if (proceed) {
          logger.logger.log(`OK. Setting enforcedOrgs key to "${proceed}".`)
          shadowNpmInject.updateConfigValue('defaultOrg', proceed)
        } else {
          logger.logger.log('OK. No changes made.')
        }
      }
    }
  }
}

async function handleConfigAuto({ key, outputKind }) {
  const result = await discoverConfigValue(key)
  await outputConfigAuto(key, result, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$F } = constants
const config$I = {
  commandName: 'auto',
  description: 'Automatically discover and set the correct value config item',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Attempt to automatically discover the correct value for a certain config key.

    For certain keys it will request the value from server, for others it will
    reset the value to the default. For some keys this has no effect.

    Keys:

${Array.from(shadowNpmInject.supportedConfigKeys.entries())
  .map(([key, desc]) => `     - ${key} -- ${desc}`)
  .join('\n')}

    Examples
      $ ${command} auto defaultOrg
  `
}
const cmdConfigAuto = {
  description: config$I.description,
  hidden: config$I.hidden,
  run: run$I
}
async function run$I(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$I,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [key = ''] = cli.input
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: shadowNpmInject.supportedConfigKeys.has(key) && key !== 'test',
      message: 'Config key should be the first arg',
      pass: 'ok',
      fail: key ? 'invalid config key' : 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$F)
    return
  }
  await handleConfigAuto({
    key: key,
    outputKind
  })
}

async function outputConfigGet(
  key,
  value,
  readOnly,
  // Is config in read-only mode? (Overrides applied)
  outputKind
) {
  if (outputKind === 'json') {
    logger.logger.log(
      JSON.stringify({
        success: true,
        result: {
          key,
          value
        },
        readOnly
      })
    )
  } else if (outputKind === 'markdown') {
    logger.logger.log(`# Config Value`)
    logger.logger.log('')
    logger.logger.log(`Config key '${key}' has value '${value}`)
    if (readOnly) {
      logger.logger.log('')
      logger.logger.log(
        'Note: the config is in read-only mode, meaning at least one key was temporarily\n      overridden from an env var or command flag.'
      )
    }
  } else {
    logger.logger.log(`${key}: ${value}`)
    if (readOnly) {
      logger.logger.log('')
      logger.logger.log(
        'Note: the config is in read-only mode, meaning at least one key was temporarily overridden from an env var or command flag.'
      )
    }
  }
}

async function handleConfigGet({ key, outputKind }) {
  const value = shadowNpmInject.getConfigValue(key)
  const readOnly = shadowNpmInject.isReadOnlyConfig()
  await outputConfigGet(key, value, readOnly, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$E } = constants
const config$H = {
  commandName: 'get',
  description: 'Get the value of a local CLI config item',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Keys:

${Array.from(shadowNpmInject.supportedConfigKeys.entries())
  .map(([key, desc]) => `     - ${key} -- ${desc}`)
  .join('\n')}

    Examples
      $ ${command} FakeOrg --repoName=test-repo
  `
}
const cmdConfigGet = {
  description: config$H.description,
  hidden: config$H.hidden,
  run: run$H
}
async function run$H(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$H,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [key = ''] = cli.input
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: shadowNpmInject.supportedConfigKeys.has(key) || key === 'test',
      message: 'Config key should be the first arg',
      pass: 'ok',
      fail: key ? 'invalid config key' : 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$E)
    return
  }
  await handleConfigGet({
    key: key,
    outputKind
  })
}

async function outputConfigList({ full, outputKind }) {
  const readOnly = shadowNpmInject.isReadOnlyConfig()
  if (outputKind === 'json') {
    const obj = {}
    for (const key of shadowNpmInject.supportedConfigKeys.keys()) {
      let value = shadowNpmInject.getConfigValue(key)
      if (!full && shadowNpmInject.sensitiveConfigKeys.has(key)) {
        value = '********'
      }
      if (full || value !== undefined) {
        obj[key] = value ?? '<none>'
      }
    }
    logger.logger.log(
      JSON.stringify(
        {
          success: true,
          full,
          config: obj,
          readOnly
        },
        null,
        2
      )
    )
  } else {
    const maxWidth = Array.from(
      shadowNpmInject.supportedConfigKeys.keys()
    ).reduce((a, b) => Math.max(a, b.length), 0)
    logger.logger.log('# Local CLI Config')
    logger.logger.log('')
    logger.logger.log(`This is the local CLI config (full=${!!full}):`)
    logger.logger.log('')
    for (const key of shadowNpmInject.supportedConfigKeys.keys()) {
      let value = shadowNpmInject.getConfigValue(key)
      if (!full && shadowNpmInject.sensitiveConfigKeys.has(key)) {
        value = '********'
      }
      if (full || value !== undefined) {
        logger.logger.log(
          `- ${key}:${' '.repeat(Math.max(0, maxWidth - key.length + 3))} ${Array.isArray(value) ? value.join(', ') || '<none>' : (value ?? '<none>')}`
        )
      }
    }
    if (readOnly) {
      logger.logger.log('')
      logger.logger.log(
        'Note: the config is in read-only mode, meaning at least one key was temporarily\n      overridden from an env var or command flag.'
      )
    }
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$D } = constants
const config$G = {
  commandName: 'list',
  description: 'Show all local CLI config items and their values',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    full: {
      type: 'boolean',
      default: false,
      description: 'Show full tokens in plaintext (unsafe)'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Keys:

${Array.from(shadowNpmInject.supportedConfigKeys.entries())
  .map(([key, desc]) => `     - ${key} -- ${desc}`)
  .join('\n')}

    Examples
      $ ${command} FakeOrg --repoName=test-repo
  `
}
const cmdConfigList = {
  description: config$G.description,
  hidden: config$G.hidden,
  run: run$G
}
async function run$G(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$G,
    importMeta,
    parentName
  })
  const { full, json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const wasBadInput = checkCommandInput(outputKind, {
    nook: true,
    test: !json || !markdown,
    message:
      'The `--json` and `--markdown` flags can not be used at the same time',
    pass: 'ok',
    fail: 'bad'
  })
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$D)
    return
  }
  await outputConfigList({
    full: !!full,
    outputKind
  })
}

async function outputConfigSet(key, _value, readOnly, outputKind) {
  if (outputKind === 'json') {
    logger.logger.log(
      JSON.stringify({
        success: true,
        message: `Config key '${key}' was updated${readOnly ? ' (Note: since at least one value was overridden from flag/env, the config was not persisted)' : ''}`,
        readOnly
      })
    )
  } else if (outputKind === 'markdown') {
    logger.logger.log(`# Update config`)
    logger.logger.log('')
    logger.logger.log(`Config key '${key}' was updated`)
    if (readOnly) {
      logger.logger.log('')
      logger.logger.log(
        'Note: The change was not persisted because the config is in read-only mode,\n      meaning at least one key was temporarily overridden from an env var or\n      command flag.'
      )
    }
  } else {
    logger.logger.log(`OK`)
    if (readOnly) {
      logger.logger.log('')
      logger.logger.log(
        'Note: The change was not persisted because the config is in read-only mode, meaning at least one key was temporarily overridden from an env var or command flag.'
      )
    }
  }
}

async function handleConfigSet({ key, outputKind, value }) {
  shadowNpmInject.updateConfigValue(key, value)
  const readOnly = shadowNpmInject.isReadOnlyConfig()
  await outputConfigSet(key, value, readOnly, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$C } = constants
const config$F = {
  commandName: 'set',
  description: 'Update the value of a local CLI config item',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <key> <value>

    Options
      ${getFlagListOutput(config.flags, 6)}

    This is a crude way of updating the local configuration for this CLI tool.

    Note that updating a value here is nothing more than updating a key/value
    store entry. No validation is happening. The server may reject your config.

    Keys:

${Array.from(shadowNpmInject.supportedConfigKeys.entries())
  .map(([key, desc]) => `     - ${key} -- ${desc}`)
  .join('\n')}

    Examples
      $ ${command} apiProxy https://example.com
  `
}
const cmdConfigSet = {
  description: config$F.description,
  hidden: config$F.hidden,
  run: run$F
}
async function run$F(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$F,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [key = '', ...rest] = cli.input
  const value = rest.join(' ')
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: key === 'test' || shadowNpmInject.supportedConfigKeys.has(key),
      message: 'Config key should be the first arg',
      pass: 'ok',
      fail: key ? 'invalid config key' : 'missing'
    },
    {
      test: !!value,
      // This is a string, empty string is not ok
      message:
        'Key value should be the remaining args (use `unset` to unset a value)',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$C)
    return
  }
  await handleConfigSet({
    key: key,
    outputKind,
    value
  })
}

async function outputConfigUnset(key, outputKind) {
  if (outputKind === 'json') {
    logger.logger.log(
      JSON.stringify({
        success: true,
        message: `Config key '${key}' was unset`
      })
    )
  } else if (outputKind === 'markdown') {
    logger.logger.log(`# Update config`)
    logger.logger.log('')
    logger.logger.log(`Config key '${key}' was unset`)
  } else {
    logger.logger.log(`OK`)
  }
}

async function handleConfigUnset({ key, outputKind }) {
  shadowNpmInject.updateConfigValue(key, undefined)
  await outputConfigUnset(key, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$B } = constants
const config$E = {
  commandName: 'unset',
  description: 'Clear the value of a local CLI config item',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <org slug>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Keys:

${Array.from(shadowNpmInject.supportedConfigKeys.entries())
  .map(([key, desc]) => `     - ${key} -- ${desc}`)
  .join('\n')}

    Examples
      $ ${command} FakeOrg --repoName=test-repo
  `
}
const cmdConfigUnset = {
  description: config$E.description,
  hidden: config$E.hidden,
  run: run$E
}
async function run$E(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$E,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [key = ''] = cli.input
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: key === 'test' || shadowNpmInject.supportedConfigKeys.has(key),
      message: 'Config key should be the first arg',
      pass: 'ok',
      fail: key ? 'invalid config key' : 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$B)
    return
  }
  await handleConfigUnset({
    key: key,
    outputKind
  })
}

const description$7 = 'Commands related to the local CLI configuration'
const cmdConfig = {
  description: description$7,
  hidden: true,
  // [beta]
  async run(argv, importMeta, { parentName }) {
    await meowWithSubcommands(
      {
        auto: cmdConfigAuto,
        get: cmdConfigGet,
        list: cmdConfigList,
        set: cmdConfigSet,
        unset: cmdConfigUnset
      },
      {
        argv,
        description: description$7,
        importMeta,
        name: `${parentName} config`
      }
    )
  }
}

async function fetchDependencies({ limit, offset }) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching organization dependencies...')
  const result = await handleApiCall(
    sockSdk.searchDependencies({
      limit,
      offset
    }),
    'Searching dependencies'
  )
  spinner.successAndStop('Received organization dependencies response.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('searchDependencies', result)
  }
  return result.data
}

// @ts-ignore
async function outputDependencies(data, { limit, offset, outputKind }) {
  if (outputKind === 'json') {
    let json
    try {
      json = JSON.stringify(data, null, 2)
    } catch (e) {
      process.exitCode = 1
      logger.logger.fail(
        'There was a problem converting the data to JSON, please try without the `--json` flag'
      )
      return
    }
    logger.logger.log(json)
    return
  }
  logger.logger.log(
    'Request details: Offset:',
    offset,
    ', limit:',
    limit,
    ', is there more data after this?',
    data.end ? 'no' : 'yes'
  )
  const options = {
    columns: [
      {
        field: 'namespace',
        name: vendor.yoctocolorsCjsExports.cyan('Namespace')
      },
      {
        field: 'name',
        name: vendor.yoctocolorsCjsExports.cyan('Name')
      },
      {
        field: 'version',
        name: vendor.yoctocolorsCjsExports.cyan('Version')
      },
      {
        field: 'repository',
        name: vendor.yoctocolorsCjsExports.cyan('Repository')
      },
      {
        field: 'branch',
        name: vendor.yoctocolorsCjsExports.cyan('Branch')
      },
      {
        field: 'type',
        name: vendor.yoctocolorsCjsExports.cyan('Type')
      },
      {
        field: 'direct',
        name: vendor.yoctocolorsCjsExports.cyan('Direct')
      }
    ]
  }
  logger.logger.log(vendor.srcExports(options, data.rows))
}

async function handleDependencies({ limit, offset, outputKind }) {
  const data = await fetchDependencies({
    limit,
    offset
  })
  if (!data) {
    return
  }
  await outputDependencies(data, {
    limit,
    offset,
    outputKind
  })
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$A } = constants
const config$D = {
  commandName: 'dependencies',
  description:
    'Search for any dependency that is being used in your organization',
  hidden: false,
  flags: {
    ...commonFlags,
    limit: {
      type: 'number',
      shortFlag: 'l',
      default: 50,
      description: 'Maximum number of dependencies returned'
    },
    offset: {
      type: 'number',
      shortFlag: 'o',
      default: 0,
      description: 'Page number'
    },
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      ${command}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: none (does need token with access to target org)

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      ${command} --limit 20 --offset 10
  `
}
const cmdScanCreate$1 = {
  description: config$D.description,
  hidden: config$D.hidden,
  run: run$D
}
async function run$D(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$D,
    importMeta,
    parentName
  })
  const { json, limit, markdown, offset } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$A)
    return
  }
  await handleDependencies({
    limit: Number(limit || 0) || 0,
    offset: Number(offset || 0) || 0,
    outputKind
  })
}

async function fetchDiffScan$1({ after, before, orgSlug }) {
  const apiToken = shadowNpmInject.getDefaultToken()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching diff-scan...')
  const response = await queryApi(
    `orgs/${orgSlug}/full-scans/diff?before=${encodeURIComponent(before)}&after=${encodeURIComponent(after)}`,
    apiToken || ''
  )
  spinner.successAndStop('Received diff-scan response')
  if (!response.ok) {
    const err = await handleApiError(response.status)
    logger.logger.fail(failMsgWithBadge(response.statusText, err))
    return
  }
  const result = await handleApiCall(
    await response.json(),
    'Deserializing json'
  )
  return result
}

async function outputDiffScan$1(result, { depth, file, outputKind }) {
  const dashboardUrl = result.diff_report_url
  const dashboardMessage = dashboardUrl
    ? `\n View this diff scan in the Socket dashboard: ${vendor.yoctocolorsCjsExports.cyan(dashboardUrl)}`
    : ''

  // When forcing json, or dumping to file, serialize to string such that it
  // won't get truncated. The only way to dump the full raw JSON to stdout is
  // to use `--json --file -` (the dash is a standard notation for stdout)
  if (outputKind === 'json' || file) {
    let json
    try {
      json = JSON.stringify(result, null, 2)
    } catch (e) {
      process.exitCode = 1
      // Most likely caused by a circular reference (or OOM)
      logger.logger.fail('There was a problem converting the data to JSON')
      logger.logger.error(e)
      return
    }
    if (file && file !== '-') {
      logger.logger.log(`Writing json to \`${file}\``)
      fs$1.writeFile(file, JSON.stringify(result, null, 2), err => {
        if (err) {
          logger.logger.fail(`Writing to \`${file}\` failed...`)
          logger.logger.error(err)
        } else {
          logger.logger.log(`Data successfully written to \`${file}\``)
        }
        logger.logger.error(dashboardMessage)
      })
    } else {
      // TODO: expose different method for writing to stderr when simply dodging stdout
      logger.logger.error(`\n Diff scan result: \n`)
      logger.logger.log(json)
      logger.logger.error(dashboardMessage)
    }
    return
  }

  // In this case neither the --json nor the --file flag was passed
  // Dump the JSON to CLI and let NodeJS deal with truncation

  logger.logger.log('Diff scan result:')
  logger.logger.log(
    util.inspect(result, {
      showHidden: false,
      depth: depth > 0 ? depth : null,
      colors: true,
      maxArrayLength: null
    })
  )
  logger.logger.log(
    `\n  To display the detailed report in the terminal, use the --json flag \n`
  )
  logger.logger.log(dashboardMessage)
}

async function handleDiffScan$1({
  after,
  before,
  depth,
  file,
  orgSlug,
  outputKind
}) {
  const data = await fetchDiffScan$1({
    after,
    before,
    orgSlug
  })
  if (!data) {
    return
  }
  await outputDiffScan$1(data, {
    depth,
    file,
    outputKind
  })
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$z } = constants
const config$C = {
  commandName: 'get',
  description: 'Get a diff scan for an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    after: {
      type: 'string',
      shortFlag: 'a',
      default: '',
      description: 'The scan ID of the head scan'
    },
    before: {
      type: 'string',
      shortFlag: 'b',
      default: '',
      description: 'The scan ID of the base scan'
    },
    depth: {
      type: 'number',
      default: 2,
      description:
        'Max depth of JSON to display before truncating, use zero for no limit (without --json/--file)'
    },
    json: {
      type: 'boolean',
      shortFlag: 'j',
      default: false,
      description:
        'Output result as json. This can be big. Use --file to store it to disk without truncation.'
    },
    file: {
      type: 'string',
      shortFlag: 'f',
      default: '',
      description:
        'Path to a local file where the output should be saved. Use `-` to force stdout.'
    }
  },
  help: (command, config) =>
    shadowNpmInject.isTestingV1()
      ? 'This command will be removed in v1'
      : `
    Note: This command is deprecated, to be dropped in the next major bump.
          Please see \`socket scan diff\`

    Usage
      $ ${command} <org slug> --before=<before> --after=<after>

    API Token Requirements
      - Quota: 1 unit
      - Permissions: full-scans:list

    This command displays the package changes between two scans. The full output
    can be pretty large depending on the size of your repo and time range. It is
    best stored to disk to be further analyzed by other tools.

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} FakeCorp --before=aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 --after=aaa1aa1a-aaaa-1111-1a1a-1111111a11a1
  `
}
const cmdDiffScanGet = {
  description: config$C.description,
  hidden: config$C.hidden,
  run: run$C
}
async function run$C(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$C,
    importMeta,
    parentName
  })
  const { after, before, depth, file, json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const defaultOrgSlug = shadowNpmInject.getConfigValue('defaultOrg')
  const orgSlug = defaultOrgSlug || cli.input[0] || ''
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: !!(before && after),
      message:
        'Specify a before and after scan ID.\nThe args are expecting a full `aaa0aa0a-aaaa-0000-0a0a-0000000a00a0` scan ID.',
      pass: 'ok',
      fail:
        !before && !after
          ? 'missing before and after'
          : !before
            ? 'missing before'
            : 'missing after'
    },
    {
      test: !!orgSlug,
      nook: true,
      message: 'Org name as the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  logger.logger.fail(
    'Warning: this command is deprecated in favor of `socket scan diff` and will be removed in the next major bump.'
  )
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$z)
    return
  }
  await handleDiffScan$1({
    before: String(before || ''),
    after: String(after || ''),
    depth: Number(depth),
    orgSlug,
    outputKind,
    file: String(file || '')
  })
}

const description$6 = 'Diff scans related commands'
const cmdDiffScan = {
  description: description$6,
  // Hidden because it was broken all this time (nobody could be using it)
  // and we're not sure if it's useful to anyone in its current state.
  // Until we do, we'll hide this to keep the help tidier.
  // And later, we may simply move this under `scan`, anyways.
  hidden: true,
  async run(argv, importMeta, { parentName }) {
    await meowWithSubcommands(
      {
        get: cmdDiffScanGet
      },
      {
        argv,
        description: description$6,
        importMeta,
        name: parentName + ' diff-scan'
      }
    )
  }
}

function formatBranchName(str) {
  return str
    .replace(/[-_.\\/]+/g, '-')
    .replace(/[^-a-zA-Z0-9]+/g, '')
    .replace(/^-+|-+$/g, '')
}
function getPkgNameFromPurlObj(purlObj) {
  return `${purlObj.namespace ? `${purlObj.namespace}/` : ''}${purlObj.name}`
}
function getBaseGitBranch() {
  // Lazily access constants.ENV.GITHUB_REF_NAME.
  return (
    constants.ENV.GITHUB_REF_NAME ||
    // GitHub defaults to branch name "main"
    // https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches#about-the-default-branch
    'main'
  )
}
function getSocketBranchName(purl, newVersion, workspaceName) {
  const purlObj = vendor.packageurlJsExports.PackageURL.fromString(purl)
  const maybeWorkspaceName = workspaceName
    ? `${formatBranchName(workspaceName)}-`
    : ''
  const maybeNamespace = purlObj.namespace
    ? `${formatBranchName(purlObj.namespace)}-`
    : ''
  const fullName = `${maybeWorkspaceName}${maybeNamespace}${formatBranchName(purlObj.name)}`
  return `socket/${fullName}-${formatBranchName(newVersion)}`
}
function getSocketPullRequestTitle(purl, newVersion, workspaceName) {
  const purlObj = vendor.packageurlJsExports.PackageURL.fromString(purl)
  const pkgName = getPkgNameFromPurlObj(purlObj)
  const workspaceDetails = workspaceName ? ` in ${workspaceName}` : ''
  return `Bump ${pkgName} from ${purlObj.version} to ${newVersion}${workspaceDetails}`
}
function getSocketPullRequestBody(purl, newVersion, workspaceName) {
  const purlObj = vendor.packageurlJsExports.PackageURL.fromString(purl)
  const pkgName = getPkgNameFromPurlObj(purlObj)
  const workspaceDetails = workspaceName ? ` in ${workspaceName}` : ''
  return `Bumps [${pkgName}](https://socket.dev/${purlObj.type}/package/${pkgName}) from ${purlObj.version} to ${newVersion}${workspaceDetails}.`
}
function getSocketCommitMessage(purl, newVersion, workspaceName) {
  const purlObj = vendor.packageurlJsExports.PackageURL.fromString(purl)
  const pkgName = getPkgNameFromPurlObj(purlObj)
  const workspaceDetails = workspaceName ? ` in ${workspaceName}` : ''
  return `socket: Bump ${pkgName} from ${purlObj.version} to ${newVersion}${workspaceDetails}`
}
async function gitCreateAndPushBranchIfNeeded(
  branch,
  commitMsg,
  cwd = process.cwd()
) {
  if (await gitRemoteBranchExists(branch, cwd)) {
    logger.logger.warn(
      `Branch "${branch}" already exists remotely, skipping push.`
    )
    return true
  }
  const moddedFilepaths = (await gitUnstagedModifiedFiles(cwd)).filter(p => {
    const basename = path$1.basename(p)
    return (
      basename === 'package.json' ||
      basename === 'package-lock.json' ||
      basename === 'pnpm-lock.yaml'
    )
  })
  if (!moddedFilepaths.length) {
    logger.logger.warn('Nothing to commit, skipping push.')
    return false
  }
  await spawn.spawn('git', ['checkout', '-b', branch], {
    cwd
  })
  await spawn.spawn('git', ['add', ...moddedFilepaths], {
    cwd
  })
  await spawn.spawn('git', ['commit', '-m', commitMsg], {
    cwd
  })
  try {
    await spawn.spawn('git', ['push', '--set-upstream', 'origin', branch], {
      cwd
    })
    return true
  } catch {}
  logger.logger.warn(`Push failed for "${branch}", trying force-push`)
  try {
    await spawn.spawn(
      'git',
      ['push', '--force', '--set-upstream', 'origin', branch],
      {
        cwd
      }
    )
    return true
  } catch {}
  logger.logger.warn(`Force-push failed for "${branch}"`)
  return false
}
async function gitHardReset(branch = 'HEAD', cwd = process.cwd()) {
  await spawn.spawn('git', ['reset', '--hard', branch], {
    cwd
  })
}
async function gitCleanFdx(cwd = process.cwd()) {
  await spawn.spawn('git', ['clean', '-fdx'], {
    cwd
  })
}
async function gitRemoteBranchExists(branch, cwd = process.cwd()) {
  try {
    const { stdout } = await spawn.spawn(
      'git',
      ['ls-remote', '--heads', 'origin', branch],
      {
        cwd
      }
    )
    return stdout.trim().length > 0
  } catch {
    return false
  }
}
async function gitUnstagedModifiedFiles(cwd = process.cwd()) {
  const { stdout } = await spawn.spawn('git', ['diff', '--name-only'], {
    cwd
  })
  const rawFiles = stdout?.trim().split('\n') ?? []
  return rawFiles.map(relPath => path.normalizePath(relPath))
}

let _octokit
function getOctokit() {
  if (_octokit === undefined) {
    _octokit = new vendor.Octokit({
      // Lazily access constants.ENV.SOCKET_SECURITY_GITHUB_PAT.
      auth: constants.ENV.SOCKET_SECURITY_GITHUB_PAT
    })
  }
  return _octokit
}
let _octokitGraphql
function getOctokitGraphql() {
  if (!_octokitGraphql) {
    _octokitGraphql = vendor.graphql2.defaults({
      headers: {
        // Lazily access constants.ENV.SOCKET_SECURITY_GITHUB_PAT.
        authorization: `token ${constants.ENV.SOCKET_SECURITY_GITHUB_PAT}`
      }
    })
  }
  return _octokitGraphql
}
async function doesPullRequestExistForBranch(owner, repo, branch) {
  const octokit = getOctokit()
  try {
    const { data: prs } = await octokit.pulls.list({
      owner,
      repo,
      head: `${owner}:${branch}`,
      state: 'open'
    })
    return prs.length > 0
  } catch {}
  return false
}
async function enableAutoMerge({ node_id: prId, number: prNumber }) {
  const octokitGraphql = getOctokitGraphql()
  try {
    await octokitGraphql(
      `
mutation EnableAutoMerge($pullRequestId: ID!) {
  enablePullRequestAutoMerge(input: {
    pullRequestId: $pullRequestId,
    mergeMethod: SQUASH
  }) {
    pullRequest {
      number
      autoMergeRequest {
        enabledAt
      }
    }
  }
}
      `.trim(),
      {
        pullRequestId: prId
      }
    )
    logger.logger.info(`Auto-merge enabled for PR #${prNumber}`)
    return true
  } catch (e) {
    let message = `Failed to enable auto-merge for PR #${prNumber}`
    if (e instanceof vendor.GraphqlResponseError && e.errors) {
      const details = e.errors
        .map(({ message }) => ` - ${message.trim()}`)
        .join('\n')
      message += `:\n${details}`
    }
    logger.logger.error(message)
    return false
  }
}
function getGitHubEnvRepoInfo() {
  // Lazily access constants.ENV.GITHUB_REPOSITORY.
  const ownerSlashRepo = constants.ENV.GITHUB_REPOSITORY
  const slashIndex = ownerSlashRepo.indexOf('/')
  if (slashIndex === -1) {
    throw new Error('Missing GITHUB_REPOSITORY environment variable')
  }
  return {
    owner: ownerSlashRepo.slice(0, slashIndex),
    repo: ownerSlashRepo.slice(slashIndex + 1)
  }
}
async function openGitHubPullRequest(
  owner,
  repo,
  baseBranch,
  branch,
  purl,
  newVersion,
  options
) {
  const { cwd = process.cwd(), workspaceName } = {
    __proto__: null,
    ...options
  }
  // Lazily access constants.ENV.GITHUB_ACTIONS.
  if (constants.ENV.GITHUB_ACTIONS) {
    // Lazily access constants.ENV.SOCKET_SECURITY_GITHUB_PAT.
    const pat = constants.ENV.SOCKET_SECURITY_GITHUB_PAT
    if (!pat) {
      throw new Error('Missing SOCKET_SECURITY_GITHUB_PAT environment variable')
    }
    const url = `https://x-access-token:${pat}@github.com/${owner}/${repo}`
    await spawn.spawn('git', ['remote', 'set-url', 'origin', url], {
      cwd
    })
    const octokit = getOctokit()
    try {
      return await octokit.pulls.create({
        owner,
        repo,
        title: getSocketPullRequestTitle(purl, newVersion, workspaceName),
        head: branch,
        base: baseBranch,
        body: getSocketPullRequestBody(purl, newVersion, workspaceName)
      })
    } catch (e) {
      let message = `Failed to open pull request`
      if (e instanceof vendor.RequestError) {
        const restErrors = e.response?.data?.['errors']
        if (Array.isArray(restErrors)) {
          const details = restErrors
            .map(
              restErr =>
                `- ${restErr.message?.trim() ?? `${restErr.resource}.${restErr.field} (${restErr.code})`}`
            )
            .join('\n')
          message += `:\n${details}`
        }
      }
      logger.logger.error(message)
      return null
    }
  }
  throw new Error('Missing GITHUB_ACTIONS environment variable')
}

const CMD_NAME$1 = 'socket fix'
const alertMapOptions = Object.freeze({
  consolidate: true,
  include: {
    existing: true,
    unfixable: false,
    upgradable: false
  },
  nothrow: true
})
function normalizeFixOptions(options_) {
  const options = {
    __proto__: null,
    ...options_
  }
  if (typeof options.autopilot !== 'boolean') {
    options.autopilot = false
  }
  if (typeof options.autoMerge !== 'boolean') {
    options.autoMerge = !!options.autopilot
  }
  if (typeof options.cwd !== 'string') {
    options.cwd = process.cwd()
  }
  options.purls = Array.isArray(options.purls)
    ? options.purls.flatMap(p => p.split(/, */))
    : []
  if (typeof options.rangeStyle !== 'string') {
    options.rangeStyle = 'preserve'
  }
  if (typeof options.test !== 'boolean') {
    options.test = !!options.autopilot || !!options.testScript
  }
  if (typeof options.testScript !== 'string') {
    options.testScript = 'test'
  }
  return options
}

const { NPM: NPM$f } = constants
async function install$1(idealTree, options) {
  const { cwd = process.cwd() } = {
    __proto__: null,
    ...options
  }
  const arb = new shadowNpmInject.Arborist({
    path: cwd
  })
  arb.idealTree = idealTree
  await arb.reify()
}
async function npmFix(
  pkgEnvDetails,
  { autoMerge, cwd, purls, rangeStyle, spinner, test, testScript }
) {
  spinner?.start()
  const { pkgPath: rootPath } = pkgEnvDetails
  const arb = new shadowNpmInject.SafeArborist({
    path: rootPath,
    ...shadowNpmInject.SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES
  })
  // Calling arb.reify() creates the arb.diff object and nulls-out arb.idealTree.
  await arb.reify()
  const alertsMap = purls.length
    ? await shadowNpmInject.getAlertsMapFromPurls(purls, alertMapOptions)
    : await shadowNpmInject.getAlertsMapFromArborist(arb, alertMapOptions)
  const infoByPkg = shadowNpmInject.getCveInfoByAlertsMap(alertsMap)
  if (!infoByPkg) {
    spinner?.stop()
    logger.logger.info('No fixable vulnerabilities found.')
    return
  }

  // Lazily access constants.ENV.CI.
  const isCi = constants.ENV.CI
  const workspacePkgJsonPaths = await shadowNpmInject.globWorkspace(
    pkgEnvDetails.agent,
    rootPath
  )
  const pkgJsonPaths = [
    ...workspacePkgJsonPaths,
    // Process the workspace root last since it will add an override to package.json.
    pkgEnvDetails.editablePkgJson.filename
  ]
  for (const { 0: name, 1: infos } of infoByPkg) {
    debug.debugLog(`Processing vulnerable package: ${name}`)
    if (registry.getManifestData(NPM$f, name)) {
      spinner?.info(`Socket Optimize package for ${name} exists, skipping`)
      continue
    }
    if (!infos.length) {
      debug.debugLog(`No vuln info found for ${name}`)
      continue
    }
    // eslint-disable-next-line no-await-in-loop
    const packument = await packages.fetchPackagePackument(name)
    if (!packument) {
      debug.debugLog(`No packument found for ${name}`)
      continue
    }
    const availableVersions = Object.keys(packument.versions)
    const fixedSpecs = new Set()
    for (const pkgJsonPath of pkgJsonPaths) {
      const pkgPath = path$1.dirname(pkgJsonPath)
      const isWorkspaceRoot =
        pkgJsonPath === pkgEnvDetails.editablePkgJson.filename
      const workspaceName = isWorkspaceRoot
        ? 'root'
        : path$1.relative(rootPath, pkgPath)
      debug.debugLog(`Checking workspace: ${workspaceName}`)
      arb.idealTree = null
      // eslint-disable-next-line no-await-in-loop
      await arb.buildIdealTree()
      const oldVersions = arrays.arrayUnique(
        shadowNpmInject
          .findPackageNodes(arb.idealTree, name)
          .map(n => n.target?.version ?? n.version)
          .filter(Boolean)
      )
      if (!oldVersions.length) {
        debug.debugLog(`Lockfile entries not found for ${name}`)
        continue
      }

      // Always re-read the editable package.json to avoid stale mutations
      // across iterations.
      // eslint-disable-next-line no-await-in-loop
      const editablePkgJson = await packages.readPackageJson(pkgJsonPath, {
        editable: true
      })
      for (const oldVersion of oldVersions) {
        const oldId = `${name}@${oldVersion}`
        const oldPurl = shadowNpmInject.idToPurl(oldId)
        const node = shadowNpmInject.findPackageNode(
          arb.idealTree,
          name,
          oldVersion
        )
        if (!node) {
          debug.debugLog(`Arborist node not found, skipping ${oldId}`)
          continue
        }
        for (const {
          firstPatchedVersionIdentifier,
          vulnerableVersionRange
        } of infos) {
          const newVersion = shadowNpmInject.findBestPatchVersion(
            node,
            availableVersions,
            vulnerableVersionRange
          )
          const newVersionPackument = newVersion
            ? packument.versions[newVersion]
            : undefined
          if (!(newVersion && newVersionPackument)) {
            debug.debugLog(
              `No suitable update. ${oldId} needs >=${firstPatchedVersionIdentifier}, skipping`
            )
            continue
          }
          const newVersionRange = shadowNpmInject.applyRange(
            oldVersion,
            newVersion,
            rangeStyle
          )
          const newId = `${name}@${newVersionRange}`
          const newSpecKey = `${workspaceName}:${newId}`
          if (fixedSpecs.has(newSpecKey)) {
            debug.debugLog(
              `Already fixed ${newId} in ${workspaceName}, skipping`
            )
            continue
          }
          const revertData = {
            ...(editablePkgJson.content.dependencies && {
              dependencies: editablePkgJson.content.dependencies
            }),
            ...(editablePkgJson.content.optionalDependencies && {
              optionalDependencies: editablePkgJson.content.optionalDependencies
            }),
            ...(editablePkgJson.content.peerDependencies && {
              peerDependencies: editablePkgJson.content.peerDependencies
            })
          }
          shadowNpmInject.updateNode(node, newVersion, newVersionPackument)
          shadowNpmInject.updatePackageJsonFromNode(
            editablePkgJson,
            arb.idealTree,
            node,
            newVersion,
            rangeStyle
          )
          // eslint-disable-next-line no-await-in-loop
          if (!(await editablePkgJson.save())) {
            debug.debugLog(
              `Nothing changed for ${workspaceName}, skipping install`
            )
            continue
          }
          spinner?.info(`Installing ${newId} in ${workspaceName}`)
          let error
          let errored = false
          try {
            // eslint-disable-next-line no-await-in-loop
            await install$1(arb.idealTree, {
              cwd
            })
            if (test) {
              spinner?.info(`Testing ${newId} in ${workspaceName}`)
              // eslint-disable-next-line no-await-in-loop
              await npm.runScript(testScript, [], {
                spinner,
                stdio: 'ignore'
              })
            }
            fixedSpecs.add(newSpecKey)
            spinner?.successAndStop(`Fixed ${name} in ${workspaceName}`)
            spinner?.start()
          } catch (e) {
            errored = true
            error = e
          }
          const baseBranch = isCi ? getBaseGitBranch() : ''
          if (!errored && isCi) {
            const branch = getSocketBranchName(
              oldPurl,
              newVersion,
              workspaceName
            )
            try {
              const { owner, repo } = getGitHubEnvRepoInfo()
              if (
                // eslint-disable-next-line no-await-in-loop
                (await doesPullRequestExistForBranch(owner, repo, branch)) ||
                // eslint-disable-next-line no-await-in-loop
                !(await gitCreateAndPushBranchIfNeeded(
                  branch,
                  getSocketCommitMessage(oldPurl, newVersion, workspaceName),
                  cwd
                ))
              ) {
                continue
              }
              // eslint-disable-next-line no-await-in-loop
              const prResponse = await openGitHubPullRequest(
                owner,
                repo,
                baseBranch,
                branch,
                oldPurl,
                newVersion,
                {
                  cwd,
                  workspaceName
                }
              )
              if (prResponse) {
                const { data } = prResponse
                spinner?.info(`Opened PR #${data.number}.`)
                if (autoMerge) {
                  // eslint-disable-next-line no-await-in-loop
                  await enableAutoMerge(data)
                }
              }
            } catch (e) {
              error = e
              errored = true
            }
          }
          if (isCi) {
            // eslint-disable-next-line no-await-in-loop
            await gitHardReset(baseBranch, cwd)
            // eslint-disable-next-line no-await-in-loop
            await gitCleanFdx(cwd)
            // eslint-disable-next-line no-await-in-loop
            await install$1(arb.idealTree, {
              cwd
            })
          }
          if (errored) {
            if (!isCi) {
              editablePkgJson.update(revertData)
              // eslint-disable-next-line no-await-in-loop
              await Promise.all([
                shadowNpmInject.removeNodeModules(cwd),
                editablePkgJson.save()
              ])
              // eslint-disable-next-line no-await-in-loop
              await install$1(arb.idealTree, {
                cwd
              })
            }
            spinner?.failAndStop(
              `Update failed for ${oldId} in ${workspaceName}`,
              error
            )
          }
        }
      }
    }
  }
  spinner?.stop()
}

const {
  NPM: NPM$e,
  SOCKET_CLI_SAFE_BIN,
  SOCKET_CLI_SAFE_PROGRESS,
  SOCKET_IPC_HANDSHAKE
} = constants
function safeNpmInstall(options) {
  const {
    agentExecPath = shadowNpmPaths.getNpmBinPath(),
    args = [],
    ipc,
    spinner,
    ...spawnOptions
  } = {
    __proto__: null,
    ...options
  }
  let stdio = spawnOptions.stdio
  const useIpc = objects.isObject(ipc)
  // Include 'ipc' in the spawnOptions.stdio when an options.ipc object is provided.
  // See https://github.com/nodejs/node/blob/v23.6.0/lib/child_process.js#L161-L166
  // and https://github.com/nodejs/node/blob/v23.6.0/lib/internal/child_process.js#L238.
  if (typeof stdio === 'string') {
    stdio = useIpc ? [stdio, stdio, stdio, 'ipc'] : [stdio, stdio, stdio]
  } else if (useIpc && Array.isArray(stdio) && !stdio.includes('ipc')) {
    stdio = stdio.concat('ipc')
  }
  const useDebug = debug.isDebug()
  const terminatorPos = args.indexOf('--')
  const rawBinArgs = terminatorPos === -1 ? args : args.slice(0, terminatorPos)
  const progressArg =
    rawBinArgs.findLast(npm.isProgressFlag) !== '--no-progress'
  const binArgs = rawBinArgs.filter(
    a => !npm.isAuditFlag(a) && !npm.isFundFlag(a) && !npm.isProgressFlag(a)
  )
  const otherArgs = terminatorPos === -1 ? [] : args.slice(terminatorPos)
  const isSilent = !useDebug && !binArgs.some(npm.isLoglevelFlag)
  const logLevelArgs = isSilent ? ['--loglevel', 'silent'] : []
  const spawnPromise = spawn.spawn(
    // Lazily access constants.execPath.
    constants.execPath,
    [
      // Lazily access constants.nodeHardenFlags.
      ...constants.nodeHardenFlags,
      // Lazily access constants.nodeNoWarningsFlags.
      ...constants.nodeNoWarningsFlags,
      // Lazily access constants.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD.
      ...(constants.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD
        ? [
            '--require',
            // Lazily access constants.distInstrumentWithSentryPath.
            constants.distInstrumentWithSentryPath
          ]
        : []),
      '--require',
      // Lazily access constants.distShadowNpmInjectPath.
      constants.distShadowNpmInjectPath,
      agentExecPath,
      'install',
      // Avoid code paths for 'audit' and 'fund'.
      '--no-audit',
      '--no-fund',
      // Add '--no-progress' to fix input being swallowed by the npm spinner.
      '--no-progress',
      // Add '--loglevel=silent' if a loglevel flag is not provided and the
      // SOCKET_CLI_DEBUG environment variable is not truthy.
      ...logLevelArgs,
      ...binArgs,
      ...otherArgs
    ],
    {
      spinner,
      ...spawnOptions,
      stdio,
      env: {
        ...process$1.env,
        ...spawnOptions.env
      }
    }
  )
  if (useIpc) {
    spawnPromise.process.send({
      [SOCKET_IPC_HANDSHAKE]: {
        [SOCKET_CLI_SAFE_BIN]: NPM$e,
        [SOCKET_CLI_SAFE_PROGRESS]: progressArg,
        ...ipc
      }
    })
  }
  return spawnPromise
}

const { NPM: NPM$d, PNPM: PNPM$9 } = constants
function runAgentInstall(pkgEnvDetails, options) {
  const { agent, agentExecPath } = pkgEnvDetails
  // All package managers support the "install" command.
  if (agent === NPM$d) {
    return safeNpmInstall({
      agentExecPath,
      ...options
    })
  }
  const {
    args = [],
    spinner,
    ...spawnOptions
  } = {
    __proto__: null,
    ...options
  }
  const skipNodeHardenFlags =
    agent === PNPM$9 && pkgEnvDetails.agentVersion.major < 11
  return spawn.spawn(agentExecPath, ['install', ...args], {
    spinner,
    stdio: 'inherit',
    ...spawnOptions,
    env: {
      ...process.env,
      NODE_OPTIONS: cmdFlagsToString([
        ...(skipNodeHardenFlags
          ? []
          : // Lazily access constants.nodeHardenFlags.
            constants.nodeHardenFlags),
        // Lazily access constants.nodeNoWarningsFlags.
        ...constants.nodeNoWarningsFlags
      ]),
      ...spawnOptions.env
    }
  })
}

const { NPM: NPM$c, OVERRIDES: OVERRIDES$2, PNPM: PNPM$8 } = constants
async function getActualTree(cwd = process.cwd()) {
  const arb = new shadowNpmInject.SafeArborist({
    path: cwd,
    ...shadowNpmInject.SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES
  })
  return await arb.loadActual()
}
async function install(pkgEnvDetails, options) {
  const { cwd, spinner } = {
    __proto__: null,
    ...options
  }
  await runAgentInstall(pkgEnvDetails, {
    args: ['--no-frozen-lockfile'],
    spinner,
    stdio: debug.isDebug() ? 'inherit' : 'ignore'
  })
  return await getActualTree(cwd)
}
async function readLockfile(pkgPath) {
  return await vendor.libExports$4.readWantedLockfile(pkgPath, {
    ignoreIncompatible: false
  })
}
async function pnpmFix(
  pkgEnvDetails,
  { autoMerge, cwd, purls, rangeStyle, spinner, test, testScript }
) {
  spinner?.start()
  const { pkgPath: rootPath } = pkgEnvDetails
  let lockfile = await readLockfile(rootPath)
  if (!lockfile) {
    await install(pkgEnvDetails, {
      cwd,
      spinner
    })
    lockfile = await readLockfile(rootPath)
    if (!lockfile) {
      spinner?.stop()
      logger.logger.error('Required pnpm-lock.yaml not found.')
      return
    }
  }
  const alertsMap = purls.length
    ? await shadowNpmInject.getAlertsMapFromPurls(purls, alertMapOptions)
    : await shadowNpmInject.getAlertsMapFromPnpmLockfile(
        lockfile,
        alertMapOptions
      )
  const infoByPkg = shadowNpmInject.getCveInfoByAlertsMap(alertsMap)
  if (!infoByPkg) {
    spinner?.stop()
    logger.logger.info('No fixable vulnerabilities found.')
    return
  }

  // Lazily access constants.ENV.CI.
  const isCi = constants.ENV.CI
  const workspacePkgJsonPaths = await shadowNpmInject.globWorkspace(
    pkgEnvDetails.agent,
    rootPath
  )
  const pkgJsonPaths = [
    ...workspacePkgJsonPaths,
    // Process the workspace root last since it will add an override to package.json.
    pkgEnvDetails.editablePkgJson.filename
  ]
  for (const { 0: name, 1: infos } of infoByPkg) {
    debug.debugLog(`Processing vulnerable package: ${name}`)
    if (registry.getManifestData(NPM$c, name)) {
      spinner?.info(`Socket Optimize package for ${name} exists, skipping`)
      continue
    }
    if (!infos.length) {
      debug.debugLog(`No vuln info found for ${name}`)
      continue
    }
    // eslint-disable-next-line no-await-in-loop
    const packument = await packages.fetchPackagePackument(name)
    if (!packument) {
      debug.debugLog(`No packument found for ${name}`)
      continue
    }
    const availableVersions = Object.keys(packument.versions)
    const fixedSpecs = new Set()
    for (const pkgJsonPath of pkgJsonPaths) {
      const pkgPath = path$1.dirname(pkgJsonPath)
      const isWorkspaceRoot =
        pkgJsonPath === pkgEnvDetails.editablePkgJson.filename
      const workspaceName = isWorkspaceRoot
        ? 'root'
        : path$1.relative(rootPath, pkgPath)
      debug.debugLog(`Checking workspace: ${workspaceName}`)

      // eslint-disable-next-line no-await-in-loop
      let actualTree = await getActualTree(cwd)
      const oldVersions = arrays.arrayUnique(
        shadowNpmInject
          .findPackageNodes(actualTree, name)
          .map(n => n.target?.version ?? n.version)
          .filter(Boolean)
      )
      if (!oldVersions.length) {
        debug.debugLog(`Lockfile entries not found for ${name}`)
        continue
      }

      // Always re-read the editable package.json to avoid stale mutations
      // across iterations.
      // eslint-disable-next-line no-await-in-loop
      const editablePkgJson = await packages.readPackageJson(pkgJsonPath, {
        editable: true
      })
      // Get current overrides for revert logic
      const oldPnpmSection = editablePkgJson.content[PNPM$8]
      const oldOverrides = oldPnpmSection?.[OVERRIDES$2]
      for (const oldVersion of oldVersions) {
        const oldId = `${name}@${oldVersion}`
        const oldPurl = shadowNpmInject.idToPurl(oldId)
        const node = shadowNpmInject.findPackageNode(
          actualTree,
          name,
          oldVersion
        )
        if (!node) {
          debug.debugLog(`Arborist node not found, skipping ${oldId}`)
          continue
        }
        for (const {
          firstPatchedVersionIdentifier,
          vulnerableVersionRange
        } of infos) {
          const newVersion = shadowNpmInject.findBestPatchVersion(
            node,
            availableVersions,
            vulnerableVersionRange
          )
          const newVersionPackument = newVersion
            ? packument.versions[newVersion]
            : undefined
          if (!(newVersion && newVersionPackument)) {
            debug.debugLog(
              `No suitable update. ${oldId} needs >=${firstPatchedVersionIdentifier}, skipping`
            )
            continue
          }
          const overrideKey = `${name}@${vulnerableVersionRange}`
          const newVersionRange = shadowNpmInject.applyRange(
            oldOverrides?.[overrideKey] ?? oldVersion,
            newVersion,
            rangeStyle
          )
          const newId = `${name}@${newVersionRange}`
          const newSpecKey = `${workspaceName}:${newId}`
          if (fixedSpecs.has(newSpecKey)) {
            debug.debugLog(
              `Already fixed ${newId} in ${workspaceName}, skipping`
            )
            continue
          }
          const updateData = isWorkspaceRoot
            ? {
                [PNPM$8]: {
                  ...oldPnpmSection,
                  [OVERRIDES$2]: {
                    ...oldOverrides,
                    [overrideKey]: newVersionRange
                  }
                }
              }
            : undefined
          const revertData = {
            ...(isWorkspaceRoot
              ? {
                  [PNPM$8]: {
                    ...oldPnpmSection,
                    [OVERRIDES$2]:
                      oldOverrides && Object.keys(oldOverrides).length > 1
                        ? {
                            ...oldOverrides,
                            [overrideKey]: undefined
                          }
                        : undefined
                  }
                }
              : {}),
            ...(editablePkgJson.content.dependencies && {
              dependencies: editablePkgJson.content.dependencies
            }),
            ...(editablePkgJson.content.optionalDependencies && {
              optionalDependencies: editablePkgJson.content.optionalDependencies
            }),
            ...(editablePkgJson.content.peerDependencies && {
              peerDependencies: editablePkgJson.content.peerDependencies
            })
          }
          if (updateData) {
            editablePkgJson.update(updateData)
          }
          shadowNpmInject.updatePackageJsonFromNode(
            editablePkgJson,
            actualTree,
            node,
            newVersion,
            rangeStyle
          )
          // eslint-disable-next-line no-await-in-loop
          if (!(await editablePkgJson.save())) {
            debug.debugLog(
              `Nothing changed for ${workspaceName}, skipping install`
            )
            continue
          }
          spinner?.info(`Installing ${newId} in ${workspaceName}`)
          let error
          let errored = false
          try {
            // eslint-disable-next-line no-await-in-loop
            actualTree = await install(pkgEnvDetails, {
              cwd,
              spinner
            })
            if (test) {
              spinner?.info(`Testing ${newId} in ${workspaceName}`)
              // eslint-disable-next-line no-await-in-loop
              await npm.runScript(testScript, [], {
                spinner,
                stdio: 'ignore'
              })
            }
            fixedSpecs.add(newSpecKey)
            spinner?.successAndStop(`Fixed ${name} in ${workspaceName}`)
            spinner?.start()
          } catch (e) {
            error = e
            errored = true
          }
          const baseBranch = isCi ? getBaseGitBranch() : ''
          if (!errored && isCi) {
            const branch = getSocketBranchName(
              oldPurl,
              newVersion,
              workspaceName
            )
            try {
              const { owner, repo } = getGitHubEnvRepoInfo()
              if (
                // eslint-disable-next-line no-await-in-loop
                (await doesPullRequestExistForBranch(owner, repo, branch)) ||
                // eslint-disable-next-line no-await-in-loop
                !(await gitCreateAndPushBranchIfNeeded(
                  branch,
                  getSocketCommitMessage(oldPurl, newVersion, workspaceName),
                  cwd
                ))
              ) {
                continue
              }
              // eslint-disable-next-line no-await-in-loop
              const prResponse = await openGitHubPullRequest(
                owner,
                repo,
                baseBranch,
                branch,
                oldPurl,
                newVersion,
                {
                  cwd,
                  workspaceName
                }
              )
              if (prResponse) {
                const { data } = prResponse
                spinner?.info(`Opened PR #${data.number}.`)
                if (autoMerge) {
                  // eslint-disable-next-line no-await-in-loop
                  await enableAutoMerge(data)
                }
              }
            } catch (e) {
              error = e
              errored = true
            }
          }
          if (isCi) {
            // eslint-disable-next-line no-await-in-loop
            await gitHardReset(baseBranch, cwd)
            // eslint-disable-next-line no-await-in-loop
            await gitCleanFdx(cwd)
            // eslint-disable-next-line no-await-in-loop
            actualTree = await install(pkgEnvDetails, {
              cwd,
              spinner
            })
          }
          if (errored) {
            if (!isCi) {
              editablePkgJson.update(revertData)
              // eslint-disable-next-line no-await-in-loop
              await Promise.all([
                shadowNpmInject.removeNodeModules(cwd),
                editablePkgJson.save()
              ])
              // eslint-disable-next-line no-await-in-loop
              actualTree = await install(pkgEnvDetails, {
                cwd,
                spinner
              })
            }
            spinner?.failAndStop(
              `Update failed for ${oldId} in ${workspaceName}`,
              error
            )
          }
        }
      }
    }
  }
  spinner?.stop()
}

const {
  BINARY_LOCK_EXT,
  BUN: BUN$5,
  HIDDEN_PACKAGE_LOCK_JSON,
  LOCK_EXT: LOCK_EXT$1,
  NPM: NPM$b,
  NPM_BUGGY_OVERRIDES_PATCHED_VERSION: NPM_BUGGY_OVERRIDES_PATCHED_VERSION$1,
  PACKAGE_JSON,
  PNPM: PNPM$7,
  VLT: VLT$5,
  YARN,
  YARN_BERRY: YARN_BERRY$5,
  YARN_CLASSIC: YARN_CLASSIC$6
} = constants
const AGENTS = new Set([
  BUN$5,
  NPM$b,
  PNPM$7,
  YARN_BERRY$5,
  YARN_CLASSIC$6,
  VLT$5
])
const binByAgent = new Map([
  [BUN$5, BUN$5],
  [NPM$b, NPM$b],
  [PNPM$7, PNPM$7],
  [YARN_BERRY$5, YARN],
  [YARN_CLASSIC$6, YARN],
  [VLT$5, VLT$5]
])
async function getAgentExecPath(agent) {
  const binName = binByAgent.get(agent)
  return (
    (await vendor.libExports$3(binName, {
      nothrow: true
    })) ?? binName
  )
}
async function getAgentVersion(agentExecPath, cwd) {
  let result
  try {
    result =
      // Coerce version output into a valid semver version by passing it through
      // semver.coerce which strips leading v's, carets (^), comparators (<,<=,>,>=,=),
      // and tildes (~).
      vendor.semverExports.coerce(
        // All package managers support the "--version" flag.
        (
          await spawn.spawn(agentExecPath, ['--version'], {
            cwd
          })
        ).stdout
      ) ?? undefined
  } catch {}
  return result
}

// The order of LOCKS properties IS significant as it affects iteration order.
const LOCKS = {
  [`bun${LOCK_EXT$1}`]: BUN$5,
  [`bun${BINARY_LOCK_EXT}`]: BUN$5,
  // If both package-lock.json and npm-shrinkwrap.json are present in the root
  // of a project, npm-shrinkwrap.json will take precedence and package-lock.json
  // will be ignored.
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson
  'npm-shrinkwrap.json': NPM$b,
  'package-lock.json': NPM$b,
  'pnpm-lock.yaml': PNPM$7,
  'pnpm-lock.yml': PNPM$7,
  [`yarn${LOCK_EXT$1}`]: YARN_CLASSIC$6,
  'vlt-lock.json': VLT$5,
  // Lastly, look for a hidden lock file which is present if .npmrc has package-lock=false:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#hidden-lockfiles
  //
  // Unlike the other LOCKS keys this key contains a directory AND filename so
  // it has to be handled differently.
  'node_modules/.package-lock.json': NPM$b
}
const readLockFileByAgent = (() => {
  function wrapReader(reader) {
    return async (...args) => {
      try {
        return await reader(...args)
      } catch {}
      return undefined
    }
  }
  const binaryReader = wrapReader(shadowNpmInject.readFileBinary)
  const defaultReader = wrapReader(
    async lockPath => await shadowNpmInject.readFileUtf8(lockPath)
  )
  return new Map([
    [
      BUN$5,
      wrapReader(async (lockPath, agentExecPath) => {
        const ext = path$1.extname(lockPath)
        if (ext === LOCK_EXT$1) {
          return await defaultReader(lockPath)
        }
        if (ext === BINARY_LOCK_EXT) {
          const lockBuffer = await binaryReader(lockPath)
          if (lockBuffer) {
            try {
              return vendor.hyrious__bun_lockbExports.parse(lockBuffer)
            } catch {}
          }
          // To print a Yarn lockfile to your console without writing it to disk
          // use `bun bun.lockb`.
          // https://bun.sh/guides/install/yarnlock
          return (await spawn.spawn(agentExecPath, [lockPath])).stdout.trim()
        }
        return undefined
      })
    ],
    [NPM$b, defaultReader],
    [PNPM$7, defaultReader],
    [VLT$5, defaultReader],
    [YARN_BERRY$5, defaultReader],
    [YARN_CLASSIC$6, defaultReader]
  ])
})()
async function detectPackageEnvironment({
  cwd = process$1.cwd(),
  onUnknown
} = {}) {
  let lockPath = await shadowNpmInject.findUp(Object.keys(LOCKS), {
    cwd
  })
  let lockName = lockPath ? path$1.basename(lockPath) : undefined
  const isHiddenLockFile = lockName === HIDDEN_PACKAGE_LOCK_JSON
  const pkgJsonPath = lockPath
    ? path$1.resolve(
        lockPath,
        `${isHiddenLockFile ? '../' : ''}../${PACKAGE_JSON}`
      )
    : await shadowNpmInject.findUp(PACKAGE_JSON, {
        cwd
      })
  const pkgPath =
    pkgJsonPath && fs$1.existsSync(pkgJsonPath)
      ? path$1.dirname(pkgJsonPath)
      : undefined
  const editablePkgJson = pkgPath
    ? await packages.readPackageJson(pkgPath, {
        editable: true
      })
    : undefined
  // Read Corepack `packageManager` field in package.json:
  // https://nodejs.org/api/packages.html#packagemanager
  const pkgManager = strings.isNonEmptyString(
    editablePkgJson?.content?.packageManager
  )
    ? editablePkgJson.content.packageManager
    : undefined
  let agent
  let agentVersion
  if (pkgManager) {
    // A valid "packageManager" field value is "<package manager name>@<version>".
    // https://nodejs.org/api/packages.html#packagemanager
    const atSignIndex = pkgManager.lastIndexOf('@')
    if (atSignIndex !== -1) {
      const name = pkgManager.slice(0, atSignIndex)
      const version = pkgManager.slice(atSignIndex + 1)
      if (version && AGENTS.has(name)) {
        agent = name
      }
    }
  }
  if (
    agent === undefined &&
    !isHiddenLockFile &&
    typeof pkgJsonPath === 'string' &&
    typeof lockName === 'string'
  ) {
    agent = LOCKS[lockName]
  }
  if (agent === undefined) {
    agent = NPM$b
    onUnknown?.(pkgManager)
  }
  const agentExecPath = await getAgentExecPath(agent)
  const npmExecPath =
    agent === NPM$b ? agentExecPath : await getAgentExecPath(NPM$b)
  if (agentVersion === undefined) {
    agentVersion = await getAgentVersion(agentExecPath, cwd)
  }
  if (agent === YARN_CLASSIC$6 && (agentVersion?.major ?? 0) > 1) {
    agent = YARN_BERRY$5
  }
  // Lazily access constants.maintainedNodeVersions.
  const { maintainedNodeVersions } = constants
  // Lazily access constants.minimumVersionByAgent.
  const minSupportedAgentVersion = constants.minimumVersionByAgent.get(agent)
  const minSupportedNodeVersion = maintainedNodeVersions.last
  const nodeVersion = vendor.semverExports.coerce(process$1.version)
  let lockSrc
  let pkgAgentRange
  let pkgNodeRange
  let pkgMinAgentVersion = minSupportedAgentVersion
  let pkgMinNodeVersion = minSupportedNodeVersion
  if (editablePkgJson?.content) {
    const { engines } = editablePkgJson.content
    const engineAgentRange = engines?.[agent]
    const engineNodeRange = engines?.['node']
    if (strings.isNonEmptyString(engineAgentRange)) {
      pkgAgentRange = engineAgentRange
      // Roughly check agent range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      const coerced = vendor.semverExports.coerce(pkgAgentRange)
      if (coerced && vendor.semverExports.lt(coerced, pkgMinAgentVersion)) {
        pkgMinAgentVersion = coerced.version
      }
    }
    if (strings.isNonEmptyString(engineNodeRange)) {
      pkgNodeRange = engineNodeRange
      // Roughly check Node range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      const coerced = vendor.semverExports.coerce(pkgNodeRange)
      if (coerced && vendor.semverExports.lt(coerced, pkgMinNodeVersion)) {
        pkgMinNodeVersion = coerced.version
      }
    }
    const browserslistQuery = editablePkgJson.content['browserslist']
    if (Array.isArray(browserslistQuery)) {
      // List Node targets in ascending version order.
      const browserslistNodeTargets = vendor
        .browserslistExports(browserslistQuery)
        .filter(v => /^node /i.test(v))
        .map(v => v.slice(5 /*'node '.length*/))
        .sort(sorts.naturalCompare)
      if (browserslistNodeTargets.length) {
        // browserslistNodeTargets[0] is the lowest Node target version.
        const coerced = vendor.semverExports.coerce(browserslistNodeTargets[0])
        if (coerced && vendor.semverExports.lt(coerced, pkgMinNodeVersion)) {
          pkgMinNodeVersion = coerced.version
        }
      }
    }
    lockSrc =
      typeof lockPath === 'string'
        ? await readLockFileByAgent.get(agent)(lockPath, agentExecPath)
        : undefined
  } else {
    lockName = undefined
    lockPath = undefined
  }
  // Does the system agent version meet our minimum supported agent version?
  const agentSupported =
    !!agentVersion &&
    vendor.semverExports.satisfies(
      agentVersion,
      `>=${minSupportedAgentVersion}`
    )

  // Does the system Node version meet our minimum supported Node version?
  const nodeSupported = vendor.semverExports.satisfies(
    nodeVersion,
    `>=${minSupportedNodeVersion}`
  )
  const npmBuggyOverrides =
    agent === NPM$b &&
    !!agentVersion &&
    vendor.semverExports.lt(agentVersion, NPM_BUGGY_OVERRIDES_PATCHED_VERSION$1)
  return {
    agent,
    agentExecPath,
    agentSupported,
    agentVersion,
    editablePkgJson,
    features: {
      npmBuggyOverrides
    },
    lockName,
    lockPath,
    lockSrc,
    nodeSupported,
    nodeVersion,
    npmExecPath,
    pkgPath,
    pkgRequirements: {
      agent: pkgAgentRange ?? `>=${pkgMinAgentVersion}`,
      node: pkgNodeRange ?? `>=${pkgMinNodeVersion}`
    },
    pkgSupports: {
      // Does our minimum supported agent version meet the package's requirements?
      agent: vendor.semverExports.satisfies(
        minSupportedAgentVersion,
        `>=${pkgMinAgentVersion}`
      ),
      // Does our supported Node versions meet the package's requirements?
      node: maintainedNodeVersions.some(v =>
        vendor.semverExports.satisfies(v, `>=${pkgMinNodeVersion}`)
      )
    }
  }
}
async function detectAndValidatePackageEnvironment(cwd, options) {
  const {
    cmdName = '',
    logger,
    prod
  } = {
    __proto__: null,
    ...options
  }
  const details = await detectPackageEnvironment({
    cwd,
    onUnknown(pkgManager) {
      logger?.warn(
        cmdPrefixMessage(
          cmdName,
          `Unknown package manager${pkgManager ? ` ${pkgManager}` : ''}, defaulting to npm`
        )
      )
    }
  })
  const { agent, nodeVersion, pkgRequirements } = details
  const agentVersion = details.agentVersion ?? 'unknown'
  if (!details.agentSupported) {
    const minVersion = constants.minimumVersionByAgent.get(agent)
    logger?.fail(
      cmdPrefixMessage(
        cmdName,
        `Requires ${agent} >=${minVersion}. Current version: ${agentVersion}.`
      )
    )
    return
  }
  if (!details.nodeSupported) {
    const minVersion = constants.maintainedNodeVersions.last
    logger?.fail(
      cmdPrefixMessage(
        cmdName,
        `Requires Node >=${minVersion}. Current version: ${nodeVersion}.`
      )
    )
    return
  }
  if (!details.pkgSupports.agent) {
    logger?.fail(
      cmdPrefixMessage(
        cmdName,
        `Package engine "${agent}" requires ${pkgRequirements.agent}. Current version: ${agentVersion}`
      )
    )
    return
  }
  if (!details.pkgSupports.node) {
    logger?.fail(
      cmdPrefixMessage(
        cmdName,
        `Package engine "node" requires ${pkgRequirements.node}. Current version: ${nodeVersion}`
      )
    )
    return
  }
  if (agent === VLT$5) {
    logger?.fail(
      cmdPrefixMessage(
        cmdName,
        `${agent} does not support overrides. Soon, though `
      )
    )
    return
  }
  const lockName = details.lockName ?? 'lock file'
  if (details.lockName === undefined || details.lockSrc === undefined) {
    logger?.fail(cmdPrefixMessage(cmdName, `No ${lockName} found`))
    return
  }
  if (details.lockSrc.trim() === '') {
    logger?.fail(cmdPrefixMessage(cmdName, `${lockName} is empty`))
    return
  }
  if (details.pkgPath === undefined) {
    logger?.fail(cmdPrefixMessage(cmdName, `No ${PACKAGE_JSON} found`))
    return
  }
  if (prod && (agent === BUN$5 || agent === YARN_BERRY$5)) {
    logger?.fail(
      cmdPrefixMessage(
        cmdName,
        `--prod not supported for ${agent}${agentVersion ? `@${agentVersion}` : ''}`
      )
    )
    return
  }
  if (
    details.lockPath &&
    path$1.relative(cwd, details.lockPath).startsWith('.')
  ) {
    logger?.warn(
      cmdPrefixMessage(
        cmdName,
        `Package ${lockName} found at ${details.lockPath}`
      )
    )
  }
  return details
}

const { NPM: NPM$a, PNPM: PNPM$6 } = constants
async function runFix(options_) {
  const options = normalizeFixOptions(options_)
  const pkgEnvDetails = await detectAndValidatePackageEnvironment(options.cwd, {
    cmdName: CMD_NAME$1,
    logger: logger.logger
  })
  if (!pkgEnvDetails) {
    return
  }
  logger.logger.info(`Fixing packages for ${pkgEnvDetails.agent}`)
  const { agent } = pkgEnvDetails
  if (agent === NPM$a) {
    await npmFix(pkgEnvDetails, options)
  } else if (agent === PNPM$6) {
    await pnpmFix(pkgEnvDetails, options)
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$y } = constants
const config$B = {
  commandName: 'fix',
  description: 'Update dependencies with "fixable" Socket alerts',
  hidden: false,
  flags: {
    ...commonFlags,
    autopilot: {
      type: 'boolean',
      default: false,
      description: `Shorthand for --autoMerge --test`
    },
    autoMerge: {
      type: 'boolean',
      default: false,
      description: `Enable auto-merge for pull requests that Socket opens.\n                        See ${vendor.terminalLinkExports('GitHub documentation', 'https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-auto-merge-for-pull-requests-in-your-repository')} for managing auto-merge for pull requests in your repository.`
    },
    purl: {
      type: 'string',
      default: [],
      description: `Provide a list of ${vendor.terminalLinkExports('package URLs', 'https://github.com/package-url/purl-spec?tab=readme-ov-file#purl')} (PURLs) to fix, as either a comma separated value or as multiple flags,\n                        instead of querying the Socket API`,
      isMultiple: true,
      shortFlag: 'p'
    },
    rangeStyle: {
      type: 'string',
      default: 'preserve',
      description: `
                        Define how updated dependency versions should be written in package.json.
                        Available styles:
                          * caret - Use ^ range for compatible updates (e.g. ^1.2.3)
                          * gt - Use > to allow any newer version (e.g. >1.2.3)
                          * gte - Use >= to allow any newer version (e.g. >=1.2.3)
                          * lt - Use < to allow only lower versions (e.g. <1.2.3)
                          * lte - Use <= to allow only lower versions (e.g. <=1.2.3)
                          * pin - Use the exact version (e.g. 1.2.3)
                          * preserve - Retain the existing version range style as-is
                          * tilde - Use ~ range for patch/minor updates (e.g. ~1.2.3)
      `.trim()
    },
    test: {
      type: 'boolean',
      default: false,
      description: 'Verify the fix by running unit tests'
    },
    testScript: {
      type: 'string',
      default: 'test',
      description: 'The test script to run for each fix attempt'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}

    Options
      ${getFlagListOutput(config.flags, 6)}
  `
}
const cmdFix = {
  description: config$B.description,
  hidden: config$B.hidden,
  run: run$B
}
async function run$B(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$B,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  const wasBadInput = checkCommandInput(outputKind, {
    test: shadowNpmInject.RangeStyles.includes(cli.flags['rangeStyle']),
    message: `Expecting range style of ${arrays.joinOr(shadowNpmInject.RangeStyles)}`,
    pass: 'ok',
    fail: 'missing'
  })
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$y)
    return
  }

  // Lazily access constants.spinner.
  const { spinner } = constants
  await runFix({
    autoMerge: Boolean(cli.flags['autoMerge']),
    autopilot: Boolean(cli.flags['autopilot']),
    purls: Array.isArray(cli.flags['purl']) ? cli.flags['purl'] : [],
    spinner,
    rangeStyle: cli.flags['rangeStyle'] ?? undefined,
    test: Boolean(cli.flags['test']),
    testScript: cli.flags['testScript']
  })
}

async function fetchPackageInfo(pkgName, pkgVersion, includeAllIssues) {
  const sockSdk = await shadowNpmInject.setupSdk(
    shadowNpmInject.getPublicToken()
  )

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start(
    pkgVersion === 'latest'
      ? `Looking up data for the latest version of ${pkgName}`
      : `Looking up data for version ${pkgVersion} of ${pkgName}`
  )
  const result = await handleApiCall(
    sockSdk.getIssuesByNPMPackage(pkgName, pkgVersion),
    'looking up package'
  )
  const scoreResult = await handleApiCall(
    sockSdk.getScoreByNPMPackage(pkgName, pkgVersion),
    'looking up package score'
  )
  spinner.successAndStop('Data fetched')
  if (result.success === false) {
    handleUnsuccessfulApiResponse('getIssuesByNPMPackage', result)
  }
  if (scoreResult.success === false) {
    handleUnsuccessfulApiResponse('getScoreByNPMPackage', scoreResult)
  }
  const severityCount = shadowNpmInject.getSeverityCount(
    result.data,
    includeAllIssues ? undefined : 'high'
  )
  return {
    data: result.data,
    severityCount,
    score: scoreResult.data
  }
}

const { NPM: NPM$9 } = registryConstants
function formatScore$1(score) {
  if (score > 80) {
    return vendor.yoctocolorsCjsExports.green(`${score}`)
  } else if (score < 80 && score > 60) {
    return vendor.yoctocolorsCjsExports.yellow(`${score}`)
  }
  return vendor.yoctocolorsCjsExports.red(`${score}`)
}
function outputPackageIssuesDetails(packageData, outputMarkdown) {
  const issueDetails = packageData.filter(
    d =>
      d.value?.severity === shadowNpmInject.ALERT_SEVERITY.critical ||
      d.value?.severity === shadowNpmInject.ALERT_SEVERITY.high
  )
  const uniqueIssueDetails = issueDetails.reduce((acc, issue) => {
    const { type } = issue
    if (type) {
      const details = acc.get(type)
      if (details) {
        details.count += 1
      } else {
        acc.set(type, {
          label: issue.value?.label ?? '',
          count: 1
        })
      }
    }
    return acc
  }, new Map())
  const format = new shadowNpmInject.ColorOrMarkdown(outputMarkdown)
  for (const [type, details] of uniqueIssueDetails.entries()) {
    const issueWithLink = format.hyperlink(
      details.label,
      shadowNpmInject.getSocketDevAlertUrl(type),
      {
        fallbackToUrl: true
      }
    )
    if (details.count === 1) {
      logger.logger.log(`- ${issueWithLink}`)
    } else {
      logger.logger.log(`- ${issueWithLink}: ${details.count}`)
    }
  }
}
function outputPackageInfo(
  { data, score, severityCount },
  { commandName, outputKind, pkgName, pkgVersion }
) {
  if (outputKind === 'json') {
    logger.logger.log(JSON.stringify(data, undefined, 2))
    return
  }
  if (outputKind === 'markdown') {
    logger.logger.log(
      `
# Package report for ${pkgName}

Package report card:
    `.trim()
    )
  } else {
    logger.logger.log(`Package report card for ${pkgName}:`)
  }
  const scoreResult = {
    'Supply Chain Risk': Math.floor(score.supplyChainRisk.score * 100),
    Maintenance: Math.floor(score.maintenance.score * 100),
    Quality: Math.floor(score.quality.score * 100),
    Vulnerabilities: Math.floor(score.vulnerability.score * 100),
    License: Math.floor(score.license.score * 100)
  }
  logger.logger.log('\n')
  Object.entries(scoreResult).map(score =>
    logger.logger.log(`- ${score[0]}: ${formatScore$1(score[1])}`)
  )
  logger.logger.log('\n')
  if (objects.hasKeys(severityCount)) {
    if (outputKind === 'markdown') {
      logger.logger.log('# Issues\n')
    }
    logger.logger.log(
      `Package has these issues: ${shadowNpmInject.formatSeverityCount(severityCount)}\n`
    )
    outputPackageIssuesDetails(data, outputKind === 'markdown')
  } else {
    logger.logger.log('Package has no issues')
  }
  const format = new shadowNpmInject.ColorOrMarkdown(outputKind === 'markdown')
  const url = shadowNpmInject.getSocketDevPackageOverviewUrl(
    NPM$9,
    pkgName,
    pkgVersion
  )
  logger.logger.log('\n')
  if (pkgVersion === 'latest') {
    logger.logger.log(
      `Detailed info on socket.dev: ${format.hyperlink(`${pkgName}`, url, {
        fallbackToUrl: true
      })}`
    )
  } else {
    logger.logger.log(
      `Detailed info on socket.dev: ${format.hyperlink(
        `${pkgName} v${pkgVersion}`,
        url,
        {
          fallbackToUrl: true
        }
      )}`
    )
  }
  if (outputKind !== 'markdown') {
    logger.logger.log(
      vendor.yoctocolorsCjsExports.dim(
        `\nOr rerun ${vendor.yoctocolorsCjsExports.italic(commandName)} using the ${vendor.yoctocolorsCjsExports.italic('--json')} flag to get full JSON output`
      )
    )
  } else {
    logger.logger.log('')
  }
}

async function handlePackageInfo({
  commandName,
  includeAllIssues,
  outputKind,
  pkgName,
  pkgVersion,
  strict
}) {
  const packageData = await fetchPackageInfo(
    pkgName,
    pkgVersion,
    includeAllIssues
  )
  if (packageData) {
    outputPackageInfo(packageData, {
      commandName,
      outputKind,
      pkgName,
      pkgVersion
    })
    if (strict && objects.hasKeys(packageData.severityCount)) {
      // Let NodeJS exit gracefully but with exit(1)
      process$1.exitCode = 1
    }
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$x } = constants
const config$A = {
  commandName: 'info',
  description: 'Look up info regarding a package',
  hidden: true,
  // Deprecated
  flags: {
    ...commonFlags,
    ...outputFlags,
    ...validationFlags
  },
  help: (command, config) =>
    shadowNpmInject.isTestingV1()
      ? 'This command will be removed in v1'
      : `
    Usage
      $ ${command} <name>

    Note: this command will be deprecated in favor of \`socket package score\` soon

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} webtorrent
      $ ${command} webtorrent@1.9.1
  `
}
const cmdInfo = {
  description: config$A.description,
  hidden: config$A.hidden,
  run: run$A
}
async function run$A(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$A,
    importMeta,
    parentName
  })
  const { all, json, markdown, strict } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [rawPkgName = ''] = cli.input
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: !!rawPkgName,
      message: 'Expecting a package name',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: cli.input.length === 1,
      message: 'Can only accept one package at a time',
      pass: 'ok',
      fail: 'got ' + cli.input.length
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    }
  )
  if (wasBadInput) {
    return
  }
  const versionSeparator = rawPkgName.lastIndexOf('@')
  const pkgName =
    versionSeparator < 1 ? rawPkgName : rawPkgName.slice(0, versionSeparator)
  const pkgVersion =
    versionSeparator < 1 ? 'latest' : rawPkgName.slice(versionSeparator + 1)
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$x)
    return
  }
  await handlePackageInfo({
    commandName: `${parentName} ${config$A.commandName}`,
    includeAllIssues: Boolean(all),
    outputKind,
    pkgName,
    pkgVersion,
    strict: Boolean(strict)
  })
}

function applyLogin(apiToken, enforcedOrgs, apiBaseUrl, apiProxy) {
  shadowNpmInject.updateConfigValue('enforcedOrgs', enforcedOrgs)
  shadowNpmInject.updateConfigValue('apiToken', apiToken)
  shadowNpmInject.updateConfigValue('apiBaseUrl', apiBaseUrl)
  shadowNpmInject.updateConfigValue('apiProxy', apiProxy)
}

const { SOCKET_PUBLIC_API_TOKEN } = constants
async function attemptLogin(apiBaseUrl, apiProxy) {
  apiBaseUrl ??= shadowNpmInject.getConfigValue('apiBaseUrl') ?? undefined
  apiProxy ??= shadowNpmInject.getConfigValue('apiProxy') ?? undefined
  const apiToken =
    (await prompts.password({
      message: `Enter your ${vendor.terminalLinkExports('Socket.dev API key', 'https://docs.socket.dev/docs/api-keys')} (leave blank for a public key)`
    })) || SOCKET_PUBLIC_API_TOKEN
  // Lazily access constants.spinner.
  const { spinner } = constants
  const sdk = await shadowNpmInject.setupSdk(apiToken, apiBaseUrl, apiProxy)
  spinner.start('Verifying API key...')
  const result = await sdk.getOrganizations()
  spinner.successAndStop('Received response')
  if (!result.success) {
    logger.logger.fail('Authentication failed...')
    handleUnsuccessfulApiResponse('getOrganizations', result)
  }
  logger.logger.success('API key verified')
  const orgs = result.data
  const enforcedChoices = Object.values(orgs.organizations)
    .filter(org => org?.plan === 'enterprise')
    .map(org => ({
      name: org.name ?? 'undefined',
      value: org.id
    }))
  let enforcedOrgs = []
  if (enforcedChoices.length > 1) {
    const id = await prompts.select({
      message:
        "Which organization's policies should Socket enforce system-wide?",
      choices: enforcedChoices.concat({
        name: 'None',
        value: '',
        description: 'Pick "None" if this is a personal device'
      })
    })
    if (id) {
      enforcedOrgs = [id]
    }
  } else if (enforcedChoices.length) {
    if (
      await prompts.confirm({
        message: `Should Socket enforce ${enforcedChoices[0]?.name}'s security policies system-wide?`,
        default: true
      })
    ) {
      const existing = enforcedChoices[0]
      if (existing) {
        enforcedOrgs = [existing.value]
      }
    }
  }
  spinner.stop()
  const previousPersistedToken = shadowNpmInject.getConfigValue('apiToken')
  try {
    applyLogin(apiToken, enforcedOrgs, apiBaseUrl, apiProxy)
    logger.logger.success(
      `API credentials ${previousPersistedToken === apiToken ? 'refreshed' : previousPersistedToken ? 'updated' : 'set'}`
    )
    if (shadowNpmInject.isReadOnlyConfig()) {
      logger.logger.log('')
      logger.logger.warn(
        'Note: config is in read-only mode, at least one key was overridden through flag/env, so the login was not persisted!'
      )
    }
  } catch {
    logger.logger.fail(`API login failed`)
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$w } = constants
const config$z = {
  commandName: 'login',
  description: 'Socket API login',
  hidden: false,
  flags: {
    ...commonFlags,
    apiBaseUrl: {
      type: 'string',
      description: 'API server to connect to for login'
    },
    apiProxy: {
      type: 'string',
      description: 'Proxy to use when making connection to API server'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}

    API Token Requirements
      - Quota: 1 unit

    Logs into the Socket API by prompting for an API key

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}
      $ ${command} --api-proxy=http://localhost:1234
  `
}
const cmdLogin = {
  description: config$z.description,
  hidden: config$z.hidden,
  run: run$z
}
async function run$z(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$z,
    importMeta,
    parentName
  })
  const apiBaseUrl = cli.flags['apiBaseUrl']
  const apiProxy = cli.flags['apiProxy']
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$w)
    return
  }
  if (!vendor.isInteractiveExports()) {
    throw new shadowNpmInject.InputError(
      'Cannot prompt for credentials in a non-interactive shell'
    )
  }
  await attemptLogin(apiBaseUrl, apiProxy)
}

function applyLogout() {
  shadowNpmInject.updateConfigValue('apiToken', null)
  shadowNpmInject.updateConfigValue('apiBaseUrl', null)
  shadowNpmInject.updateConfigValue('apiProxy', null)
  shadowNpmInject.updateConfigValue('enforcedOrgs', null)
}

function attemptLogout() {
  try {
    applyLogout()
    logger.logger.success('Successfully logged out')
    if (shadowNpmInject.isReadOnlyConfig()) {
      logger.logger.log('')
      logger.logger.warn(
        'Note: config is in read-only mode, at least one key was overridden through flag/env, so the logout was not persisted!'
      )
    }
  } catch {
    logger.logger.fail('Failed to complete logout steps')
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$v } = constants
const config$y = {
  commandName: 'logout',
  description: 'Socket API logout',
  hidden: false,
  flags: {
    ...commonFlags
  },
  help: (command, _config) => `
    Usage
      $ ${command}

    Logs out of the Socket API and clears all Socket credentials from disk
  `
}
const cmdLogout = {
  description: config$y.description,
  hidden: config$y.hidden,
  run: run$y
}
async function run$y(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$y,
    importMeta,
    parentName
  })
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$v)
    return
  }
  attemptLogout()
}

async function convertCondaToRequirements(target, cwd, verbose) {
  let contents
  if (target === '-') {
    if (verbose) {
      logger.logger.error(`[VERBOSE] reading input from stdin`)
    }
    const buf = []
    contents = await new Promise((resolve, reject) => {
      process.stdin.on('data', chunk => {
        const input = chunk.toString()
        buf.push(input)
      })
      process.stdin.on('end', () => {
        resolve(buf.join(''))
      })
      process.stdin.on('error', e => {
        if (verbose) {
          logger.logger.error('Unexpected error while reading from stdin:', e)
        }
        reject(e)
      })
      process.stdin.on('close', () => {
        if (buf.length === 0) {
          if (verbose) {
            logger.logger.error('stdin closed explicitly without data received')
          }
          reject(new Error('No data received from stdin'))
        } else {
          if (verbose) {
            logger.logger.error(
              'warning: stdin closed explicitly with some data received'
            )
          }
          resolve(buf.join(''))
        }
      })
    })
    if (!contents) {
      return {
        ok: false,
        message: 'No data received from stdin',
        data: undefined
      }
    }
  } else {
    const f = path$1.resolve(cwd, target)
    if (verbose) {
      logger.logger.error(`[VERBOSE] target file: ${f}`)
    }
    if (!fs$1.existsSync(f)) {
      return {
        ok: false,
        message: `Input file not found at ${f}`,
        data: undefined
      }
    }
    contents = fs$1.readFileSync(target, 'utf8')
    if (!contents) {
      return {
        ok: false,
        message: 'File is empty',
        data: undefined
      }
    }
  }
  return {
    ok: true,
    message: '',
    data: {
      contents,
      pip: convertCondaToRequirementsFromInput(contents)
    }
  }
}

// Just extract the first pip block, if one exists at all.
function convertCondaToRequirementsFromInput(input) {
  const keeping = []
  let collecting = false
  let delim = '-'
  let indent = ''
  input.split('\n').some(line => {
    if (!line) {
      // Ignore empty lines
      return
    }
    if (collecting) {
      if (line.startsWith('#')) {
        // Ignore comment lines (keep?)
        return
      }
      if (line.startsWith(delim)) {
        // In this case we have a line with the same indentation as the
        // `- pip:` line, so we have reached the end of the pip block.
        return true // the end
      } else {
        if (!indent) {
          // Store the indentation of the block
          if (line.trim().startsWith('-')) {
            indent = line.split('-')[0] + '-'
            if (indent.length <= delim.length) {
              // The first line after the `pip:` line does not indent further
              // than that so the block is empty?
              return true
            }
          }
        }
        if (line.startsWith(indent)) {
          keeping.push(line.slice(indent.length).trim())
        } else {
          // Unexpected input. bail.
          return true
        }
      }
    } else {
      // Note: the line may end with a line comment so don't === it.
      if (line.trim().startsWith('- pip:')) {
        delim = line.split('-')[0] + '-'
        collecting = true
      }
    }
  })
  return keeping.join('\n')
}

async function outputRequirements(data, outputKind, out) {
  if (outputKind === 'json') {
    const json = JSON.stringify(
      {
        ok: true,
        data: {
          pip: data.pip
        }
      },
      undefined,
      2
    )
    if (out === '-') {
      logger.logger.log(json)
    } else {
      fs$1.writeFileSync(out, json, 'utf8')
    }
    return
  }
  if (outputKind === 'markdown') {
    const arr = []
    arr.push('# Converted Conda file')
    arr.push('')
    arr.push(
      'This is the Conda `environment.yml` file converted to python `requirements.txt`:'
    )
    arr.push('')
    arr.push('```file=requirements.txt')
    arr.push(data.pip)
    arr.push('```')
    arr.push('')
    const md = arr.join('\n')
    if (out === '-') {
      logger.logger.log(md)
    } else {
      fs$1.writeFileSync(out, md, 'utf8')
    }
    return
  }
  if (out === '-') {
    logger.logger.log(data.pip)
    logger.logger.log('')
  } else {
    fs$1.writeFileSync(out, data.pip, 'utf8')
  }
}

async function handleManifestConda(target, out, outputKind, cwd, verbose) {
  const data = await convertCondaToRequirements(target, cwd, verbose)
  if (!data) {
    return
  }
  if (!data.ok) {
    logger.logger.fail(data.message)
    return
  }
  await outputRequirements(data.data, outputKind, out)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$u } = constants
const config$x = {
  commandName: 'conda',
  description:
    '[beta] Convert a Conda environment.yml file to a python requirements.txt',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    out: {
      type: 'string',
      default: '-',
      description: 'Output target (use `-` or omit to print to stdout)'
    },
    verbose: {
      type: 'boolean',
      description: 'Print debug messages'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} FILE

    Warning: While we don't support Conda necessarily, this tool extracts the pip
             block from an environment.yml and outputs it as a requirements.txt
             which you can scan as if it were a pypi package.

    USE AT YOUR OWN RISK

    Note: FILE can be a dash (-) to indicate stdin. This way you can pipe the
          contents of a file to have it processed.

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples

      $ ${command} ./environment.yml
  `
}
const cmdManifestConda = {
  description: config$x.description,
  hidden: config$x.hidden,
  run: run$x
}
async function run$x(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$x,
    importMeta,
    parentName
  })
  const {
    cwd = process.cwd(),
    json = false,
    markdown = false,
    out = '-',
    verbose = false
  } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  const [target = ''] = cli.input
  if (verbose) {
    logger.logger.group('- ', parentName, config$x.commandName, ':')
    logger.logger.group('- flags:', cli.flags)
    logger.logger.groupEnd()
    logger.logger.log('- target:', target)
    logger.logger.log('- output:', out)
    logger.logger.groupEnd()
  }
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: !!target,
      message: 'The FILE arg is required',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: cli.input.length <= 1,
      message: 'Can only accept one DIR (make sure to escape spaces!)',
      pass: 'ok',
      fail: 'received ' + cli.input.length
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    }
  )
  if (wasBadInput) {
    return
  }
  logger.logger.error(
    'Warning: This will approximate your Conda dependencies using PyPI. We do not yet officially support Conda. Use at your own risk.'
  )
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$u)
    return
  }
  await handleManifestConda(
    target,
    String(out || ''),
    json ? 'json' : markdown ? 'markdown' : 'text',
    String(cwd),
    Boolean(verbose)
  )
}

async function convertGradleToMaven(target, bin, cwd, verbose, gradleOpts) {
  if (verbose) {
    logger.logger.log('[VERBOSE] Resolving:', [cwd, bin])
  }
  const rbin = path$1.resolve(cwd, bin)
  if (verbose) {
    logger.logger.log('[VERBOSE] Resolving:', [cwd, target])
  }
  const rtarget = path$1.resolve(cwd, target)
  const binExists = fs$1.existsSync(rbin)
  const targetExists = fs$1.existsSync(rtarget)
  logger.logger.group('gradle2maven:')
  if (verbose || debug.isDebug()) {
    logger.logger.log(
      `[VERBOSE] - Absolute bin path: \`${rbin}\` (${binExists ? 'found' : vendor.yoctocolorsCjsExports.red('not found!')})`
    )
    logger.logger.log(
      `[VERBOSE] - Absolute target path: \`${rtarget}\` (${targetExists ? 'found' : vendor.yoctocolorsCjsExports.red('not found!')})`
    )
  } else {
    logger.logger.log(`- executing: \`${rbin}\``)
    if (!binExists) {
      logger.logger.warn(
        'Warning: It appears the executable could not be found at this location. An error might be printed later because of that.'
      )
    }
    logger.logger.log(`- src dir: \`${rtarget}\``)
    if (!targetExists) {
      logger.logger.warn(
        'Warning: It appears the src dir could not be found at this location. An error might be printed later because of that.'
      )
    }
  }
  logger.logger.groupEnd()
  try {
    // Run gradlew with the init script we provide which should yield zero or more
    // pom files. We have to figure out where to store those pom files such that
    // we can upload them and predict them through the GitHub API. We could do a
    // .socket folder. We could do a socket.pom.gz with all the poms, although
    // I'd prefer something plain-text if it is to be committed.

    // Note: init.gradle will be exported by .config/rollup.dist.config.mjs
    const initLocation = path$1.join(constants.distPath, 'init.gradle')
    const commandArgs = ['--init-script', initLocation, ...gradleOpts, 'pom']
    if (verbose) {
      logger.logger.log('[VERBOSE] Executing:', [bin], ', args:', commandArgs)
    }
    logger.logger.log(
      `Converting gradle to maven from \`${bin}\` on \`${target}\` ...`
    )
    const output = await execGradleWithSpinner(rbin, commandArgs, rtarget, cwd)
    if (verbose) {
      logger.logger.group('[VERBOSE] gradle stdout:')
      logger.logger.log(output)
      logger.logger.groupEnd()
    }
    if (output.code !== 0) {
      process.exitCode = 1
      logger.logger.fail(`Gradle exited with exit code ${output.code}`)
      // (In verbose mode, stderr was printed above, no need to repeat it)
      if (!verbose) {
        logger.logger.group('stderr:')
        logger.logger.error(output.stderr)
        logger.logger.groupEnd()
      }
      return
    }
    logger.logger.success('Executed gradle successfully')
    logger.logger.log('Reported exports:')
    output.stdout.replace(/^POM file copied to: (.*)/gm, (_all, fn) => {
      logger.logger.log('- ', fn)
      return fn
    })
    logger.logger.log('')
    logger.logger.log(
      'Next step is to generate a Scan by running the `socket scan create` command on the same directory'
    )
  } catch (e) {
    process.exitCode = 1
    logger.logger.fail(
      'There was an unexpected error while generating manifests' +
        (verbose ? '' : '  (use --verbose for details)')
    )
    if (verbose) {
      logger.logger.group('[VERBOSE] error:')
      logger.logger.log(e)
      logger.logger.groupEnd()
    }
  }
}
async function execGradleWithSpinner(bin, commandArgs, target, cwd) {
  // Lazily access constants.spinner.
  const { spinner } = constants
  let pass = false
  try {
    spinner.start(
      `Running gradlew... (this can take a while, it depends on how long gradlew has to run)`
    )
    const output = await spawn.spawn(bin, commandArgs, {
      // We can pipe the output through to have the user see the result
      // of running gradlew, but then we can't (easily) gather the output
      // to discover the generated files... probably a flag we should allow?
      // stdio: isDebug() ? 'inherit' : undefined,
      cwd: target || cwd
    })
    pass = true
    const { code, stderr, stdout } = output
    return {
      code,
      stdout,
      stderr
    }
  } finally {
    if (pass) {
      spinner.successAndStop('Completed gradlew execution')
    } else {
      spinner.failAndStop('There was an error while trying to run gradlew.')
    }
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$t } = constants
const config$w = {
  commandName: 'gradle',
  description:
    '[beta] Use Gradle to generate a manifest file (`pom.xml`) for a Gradle/Java/Kotlin/etc project',
  hidden: false,
  flags: {
    ...commonFlags,
    bin: {
      type: 'string',
      description: 'Location of gradlew binary to use, default: CWD/gradlew'
    },
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    gradleOpts: {
      type: 'string',
      default: '',
      description:
        'Additional options to pass on to ./gradlew, see `./gradlew --help`'
    },
    task: {
      type: 'string',
      default: 'all',
      description: 'Task to target. By default targets all'
    },
    verbose: {
      type: 'boolean',
      description: 'Print debug messages'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} [--bin=path/to/gradle/binary] [--out=path/to/result] DIR

    Options
      ${getFlagListOutput(config.flags, 6)}

    Uses gradle, preferably through your local project \`gradlew\`, to generate a
    \`pom.xml\` file for each task. If you have no \`gradlew\` you can try the
    global \`gradle\` binary but that may not work (hard to predict).

    The \`pom.xml\` is a manifest file similar to \`package.json\` for npm or
    or requirements.txt for PyPi), but specifically for Maven, which is Java's
    dependency repository. Languages like Kotlin and Scala piggy back on it too.

    There are some caveats with the gradle to \`pom.xml\` conversion:

    - each task will generate its own xml file and by default it generates one xml
      for every task.

    - it's possible certain features don't translate well into the xml. If you
      think something is missing that could be supported please reach out.

    - it works with your \`gradlew\` from your repo and local settings and config

    Support is beta. Please report issues or give us feedback on what's missing.

    Examples

      $ ${command} .
      $ ${command} --bin=../gradlew .
  `
}
const cmdManifestGradle = {
  description: config$w.description,
  hidden: config$w.hidden,
  run: run$w
}
async function run$w(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$w,
    importMeta,
    parentName
  })
  const verbose = Boolean(cli.flags['verbose'])
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  if (verbose) {
    logger.logger.group('- ', parentName, config$w.commandName, ':')
    logger.logger.group('- flags:', cli.flags)
    logger.logger.groupEnd()
    logger.logger.log('- input:', cli.input)
    logger.logger.groupEnd()
  }
  const [target = ''] = cli.input

  // TODO: I'm not sure it's feasible to parse source file from stdin. We could
  //       try, store contents in a file in some folder, target that folder... what
  //       would the file name be?

  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: !!target && target !== '-',
      message: 'The DIR arg is required',
      pass: 'ok',
      fail: target === '-' ? 'stdin is not supported' : 'missing'
    },
    {
      nook: true,
      test: cli.input.length <= 1,
      message: 'Can only accept one DIR (make sure to escape spaces!)',
      pass: 'ok',
      fail: 'received ' + cli.input.length
    }
  )
  if (wasBadInput) {
    return
  }
  const { bin = path$1.join(target, 'gradlew'), cwd = process.cwd() } =
    cli.flags
  if (verbose) {
    logger.logger.group()
    logger.logger.log('- target:', target)
    logger.logger.log('- gradle bin:', bin)
    logger.logger.groupEnd()
  }
  let gradleOpts = []
  if (cli.flags['gradleOpts']) {
    gradleOpts = cli.flags['gradleOpts']
      .split(' ')
      .map(s => s.trim())
      .filter(Boolean)
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$t)
    return
  }
  await convertGradleToMaven(
    target,
    String(bin),
    String(cwd),
    verbose,
    gradleOpts
  )
}

async function convertSbtToMaven(target, bin, out, verbose, sbtOpts) {
  // Lazily access constants.spinner.
  const { spinner } = constants
  const rbin = path$1.resolve(bin)
  const rtarget = path$1.resolve(target)
  if (verbose) {
    logger.logger.group('sbt2maven:')
    logger.logger.log(`[VERBOSE] - Absolute bin path: \`${rbin}\``)
    logger.logger.log(`[VERBOSE] - Absolute target path: \`${rtarget}\``)
    // logger.log(`[VERBOSE] - Absolute out path: \`${rout}\``)
    logger.logger.groupEnd()
  } else {
    logger.logger.group('sbt2maven:')
    logger.logger.log(`- executing: \`${bin}\``)
    logger.logger.log(`- src dir: \`${target}\``)
    // logger.log(`- dst dir: \`${out}\``)
    logger.logger.groupEnd()
  }
  try {
    spinner.start(`Converting sbt to maven from \`${bin}\` on \`${target}\`...`)

    // Run sbt with the init script we provide which should yield zero or more
    // pom files. We have to figure out where to store those pom files such that
    // we can upload them and predict them through the GitHub API. We could do a
    // .socket folder. We could do a socket.pom.gz with all the poms, although
    // I'd prefer something plain-text if it is to be committed.
    const output = await spawn.spawn(bin, ['makePom'].concat(sbtOpts), {
      cwd: target || '.'
    })
    spinner.stop()
    if (verbose) {
      logger.logger.group('[VERBOSE] sbt stdout:')
      logger.logger.log(output)
      logger.logger.groupEnd()
    }
    if (output.stderr) {
      process.exitCode = 1
      logger.logger.fail('There were errors while running sbt')
      // (In verbose mode, stderr was printed above, no need to repeat it)
      if (!verbose) {
        logger.logger.group('[VERBOSE] stderr:')
        logger.logger.error(output.stderr)
        logger.logger.groupEnd()
      }
      return
    }
    const poms = []
    output.stdout.replace(/Wrote (.*?.pom)\n/g, (_all, fn) => {
      poms.push(fn)
      return fn
    })
    if (!poms.length) {
      process.exitCode = 1
      logger.logger.fail(
        'There were no errors from sbt but it seems to not have generated any poms either'
      )
      return
    }
    // Move the pom file to ...? initial cwd? loc will be an absolute path, or dump to stdout
    // TODO: what to do with multiple output files? Do we want to dump them to stdout? Raw or with separators or ?
    // TODO: maybe we can add an option to target a specific file to dump to stdout
    if (out === '-' && poms.length === 1) {
      logger.logger.log('Result:\n```')
      logger.logger.log(await shadowNpmInject.safeReadFile(poms[0]))
      logger.logger.log('```')
      logger.logger.success(`OK`)
    } else if (out === '-') {
      process.exitCode = 1
      logger.logger.fail(
        'Requested out target was stdout but there are multiple generated files'
      )
      poms.forEach(fn => logger.logger.error('-', fn))
      logger.logger.error('Exiting now...')
      return
    } else {
      // if (verbose) {
      //   logger.log(
      //     `Moving manifest file from \`${loc.replace(/^\/home\/[^/]*?\//, '~/')}\` to \`${out}\``
      //   )
      // } else {
      //   logger.log('Moving output pom file')
      // }
      // TODO: do we prefer fs-extra? renaming can be gnarly on windows and fs-extra's version is better
      // await renamep(loc, out)
      logger.logger.success(`Generated ${poms.length} pom files`)
      poms.forEach(fn => logger.logger.log('-', fn))
      logger.logger.success(`OK`)
    }
  } catch (e) {
    process.exitCode = 1
    spinner.stop()
    logger.logger.fail(
      'There was an unexpected error while running this' +
        (verbose ? '' : ' (use --verbose for details)')
    )
    if (verbose) {
      logger.logger.group('[VERBOSE] error:')
      logger.logger.log(e)
      logger.logger.groupEnd()
    }
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$s } = constants
const config$v = {
  commandName: 'scala',
  description:
    "[beta] Generate a manifest file (`pom.xml`) from Scala's `build.sbt` file",
  hidden: false,
  flags: {
    ...commonFlags,
    bin: {
      type: 'string',
      default: 'sbt',
      description: 'Location of sbt binary to use'
    },
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    out: {
      type: 'string',
      default: './socket.pom.xml',
      description:
        'Path of output file; where to store the resulting manifest, see also --stdout'
    },
    stdout: {
      type: 'boolean',
      description: 'Print resulting pom.xml to stdout (supersedes --out)'
    },
    sbtOpts: {
      type: 'string',
      default: '',
      description: 'Additional options to pass on to sbt, as per `sbt --help`'
    },
    verbose: {
      type: 'boolean',
      description: 'Print debug messages'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} [--bin=path/to/sbt/binary] [--out=path/to/result] FILE|DIR

    Options
      ${getFlagListOutput(config.flags, 6)}

    Uses \`sbt makePom\` to generate a \`pom.xml\` from your \`build.sbt\` file.
    This xml file is the dependency manifest (like a package.json
    for Node.js or requirements.txt for PyPi), but specifically for Scala.

    There are some caveats with \`build.sbt\` to \`pom.xml\` conversion:

    - the xml is exported as socket.pom.xml as to not confuse existing build tools
      but it will first hit your /target/sbt<version> folder (as a different name)

    - the pom.xml format (standard by Scala) does not support certain sbt features
      - \`excludeAll()\`, \`dependencyOverrides\`, \`force()\`, \`relativePath\`
      - For details: https://www.scala-sbt.org/1.x/docs/Library-Management.html

    - it uses your sbt settings and local configuration verbatim

    - it can only export one target per run, so if you have multiple targets like
      development and production, you must run them separately.

    You can optionally configure the path to the \`sbt\` bin to invoke.

    Support is beta. Please report issues or give us feedback on what's missing.

    This is only for SBT. If your Scala setup uses gradle, please see the help
    sections for \`socket manifest gradle\` or \`socket cdxgen\`.

    Examples

      $ ${command} ./build.sbt
      $ ${command} --bin=/usr/bin/sbt ./build.sbt
  `
}
const cmdManifestScala = {
  description: config$v.description,
  hidden: config$v.hidden,
  run: run$v
}
async function run$v(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$v,
    importMeta,
    parentName
  })
  const verbose = Boolean(cli.flags['verbose'])
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  if (verbose) {
    logger.logger.group('- ', parentName, config$v.commandName, ':')
    logger.logger.group('- flags:', cli.flags)
    logger.logger.groupEnd()
    logger.logger.log('- input:', cli.input)
    logger.logger.groupEnd()
  }
  const [target = ''] = cli.input

  // TODO: I'm not sure it's feasible to parse source file from stdin. We could
  //       try, store contents in a file in some folder, target that folder... what
  //       would the file name be?

  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: !!target && target !== '-',
      message: 'The DIR arg is required',
      pass: 'ok',
      fail: target === '-' ? 'stdin is not supported' : 'missing'
    },
    {
      nook: true,
      test: cli.input.length <= 1,
      message: 'Can only accept one DIR (make sure to escape spaces!)',
      pass: 'ok',
      fail: 'received ' + cli.input.length
    }
  )
  if (wasBadInput) {
    return
  }
  let bin = 'sbt'
  if (cli.flags['bin']) {
    bin = cli.flags['bin']
  }
  let out = './socket.pom.xml'
  if (cli.flags['out']) {
    out = cli.flags['out']
  }
  if (cli.flags['stdout']) {
    out = '-'
  }
  if (verbose) {
    logger.logger.group()
    logger.logger.log('- target:', target)
    logger.logger.log('- gradle bin:', bin)
    logger.logger.log('- out:', out)
    logger.logger.groupEnd()
  }
  let sbtOpts = []
  if (cli.flags['sbtOpts']) {
    sbtOpts = cli.flags['sbtOpts']
      .split(' ')
      .map(s => s.trim())
      .filter(Boolean)
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$s)
    return
  }
  await convertSbtToMaven(target, bin, out, verbose, sbtOpts)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$r } = constants
const config$u = {
  commandName: 'auto',
  description: 'Auto-detect build and attempt to generate manifest file',
  hidden: false,
  flags: {
    ...commonFlags,
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    verbose: {
      type: 'boolean',
      default: false,
      description: 'Enable debug output, may help when running into errors'
    }
    // TODO: support output flags
  },
  help: (command, config) => `
    Usage
      $ ${command}

    Options
      ${getFlagListOutput(config.flags, 6)}

    Tries to figure out what language your current repo uses. If it finds a
    supported case then it will try to generate the manifest file for that
    language with the default or detected settings.
  `
}
const cmdManifestAuto = {
  description: config$u.description,
  hidden: config$u.hidden,
  run: run$u
}
async function run$u(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$u,
    importMeta,
    parentName
  })
  const verbose = !!cli.flags['verbose']
  const cwd = cli.flags['cwd'] ?? process.cwd()
  // TODO: impl json/md

  if (verbose) {
    logger.logger.group('- ', parentName, config$u.commandName, ':')
    logger.logger.group('- flags:', cli.flags)
    logger.logger.groupEnd()
    logger.logger.log('- input:', cli.input)
    logger.logger.log('- cwd:', cwd)
    logger.logger.groupEnd()
  }
  const subArgs = []
  if (verbose) {
    subArgs.push('--verbose')
  }
  const dir = cwd
  if (fs$1.existsSync(path$1.join(dir, 'build.sbt'))) {
    logger.logger.log(
      'Detected a Scala sbt build, running default Scala generator...'
    )
    if (cwd) {
      subArgs.push('--cwd', cwd)
    }
    subArgs.push(dir)
    if (cli.flags['dryRun']) {
      logger.logger.log(DRY_RUN_BAIL_TEXT$r)
      return
    }
    await cmdManifestScala.run(subArgs, importMeta, {
      parentName
    })
    return
  }
  if (fs$1.existsSync(path$1.join(dir, 'gradlew'))) {
    logger.logger.log(
      'Detected a gradle build, running default gradle generator...'
    )
    if (cwd) {
      // This command takes the cwd as first arg.
      subArgs.push(cwd)
    }
    if (cli.flags['dryRun']) {
      logger.logger.log(DRY_RUN_BAIL_TEXT$r)
      return
    }
    await cmdManifestGradle.run(subArgs, importMeta, {
      parentName
    })
    return
  }
  const envyml = path$1.join(dir, 'environment.yml')
  const hasEnvyml = fs$1.existsSync(envyml)
  const envyaml = path$1.join(dir, 'environment.yaml')
  const hasEnvyaml = !hasEnvyml && fs$1.existsSync(envyaml)
  if (hasEnvyml || hasEnvyaml) {
    logger.logger.log(
      'Detected an environment.yml file, running default Conda generator...'
    )
    // This command takes the TARGET as first arg.
    subArgs.push(hasEnvyml ? envyml : hasEnvyaml ? envyaml : '')
    if (cli.flags['dryRun']) {
      logger.logger.log(DRY_RUN_BAIL_TEXT$r)
      return
    }
    await cmdManifestConda.run(subArgs, importMeta, {
      parentName
    })
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$r)
    return
  }

  // Show new help screen and exit.
  vendor
    .meow(
      `
    $ ${parentName} ${config$u.commandName}

    Unfortunately this script did not discover a supported language in the
    current folder.

    - Make sure this script would work with your target build
    - Make sure to run it from the correct folder
    - Make sure the necessary build tools are available (\`PATH\`)

    If that doesn't work, see \`${parentName} <lang> --help\` for config details for
    your target language.
  `,
      {
        argv: [],
        description: config$u.description,
        importMeta
      }
    )
    .showHelp()
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$q } = constants

// TODO: we may want to dedupe some pieces for all gradle languages. I think it
//       makes sense to have separate commands for them and I think it makes
//       sense for the help panels to note the requested language, rather than
//       `socket manifest kotlin` to print help screens with `gradle` as the
//       command. Room for improvement.
const config$t = {
  commandName: 'kotlin',
  description:
    '[beta] Use Gradle to generate a manifest file (`pom.xml`) for a Kotlin project',
  hidden: false,
  flags: {
    ...commonFlags,
    bin: {
      type: 'string',
      description: 'Location of gradlew binary to use, default: CWD/gradlew'
    },
    cwd: {
      type: 'string',
      description: 'Set the cwd, defaults to process.cwd()'
    },
    gradleOpts: {
      type: 'string',
      default: '',
      description:
        'Additional options to pass on to ./gradlew, see `./gradlew --help`'
    },
    task: {
      type: 'string',
      default: 'all',
      description: 'Task to target. By default targets all'
    },
    verbose: {
      type: 'boolean',
      description: 'Print debug messages'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} [--bin=path/to/gradle/binary] [--out=path/to/result] DIR

    Options
      ${getFlagListOutput(config.flags, 6)}

    Uses gradle, preferably through your local project \`gradlew\`, to generate a
    \`pom.xml\` file for each task. If you have no \`gradlew\` you can try the
    global \`gradle\` binary but that may not work (hard to predict).

    The \`pom.xml\` is a manifest file similar to \`package.json\` for npm or
    or requirements.txt for PyPi), but specifically for Maven, which is Java's
    dependency repository. Languages like Kotlin and Scala piggy back on it too.

    There are some caveats with the gradle to \`pom.xml\` conversion:

    - each task will generate its own xml file and by default it generates one xml
      for every task. (This may be a good thing!)

    - it's possible certain features don't translate well into the xml. If you
      think something is missing that could be supported please reach out.

    - it works with your \`gradlew\` from your repo and local settings and config

    Support is beta. Please report issues or give us feedback on what's missing.

    Examples

      $ ${command} .
      $ ${command} --bin=../gradlew .
  `
}
const cmdManifestKotlin = {
  description: config$t.description,
  hidden: config$t.hidden,
  run: run$t
}
async function run$t(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$t,
    importMeta,
    parentName
  })
  const verbose = Boolean(cli.flags['verbose'])
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  if (verbose) {
    logger.logger.group('- ', parentName, config$t.commandName, ':')
    logger.logger.group('- flags:', cli.flags)
    logger.logger.groupEnd()
    logger.logger.log('- input:', cli.input)
    logger.logger.groupEnd()
  }
  const [target = ''] = cli.input

  // TODO: I'm not sure it's feasible to parse source file from stdin. We could
  //       try, store contents in a file in some folder, target that folder... what
  //       would the file name be?

  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: !!target && target !== '-',
      message: 'The DIR arg is required',
      pass: 'ok',
      fail: target === '-' ? 'stdin is not supported' : 'missing'
    },
    {
      nook: true,
      test: cli.input.length <= 1,
      message: 'Can only accept one DIR (make sure to escape spaces!)',
      pass: 'ok',
      fail: 'received ' + cli.input.length
    }
  )
  if (wasBadInput) {
    return
  }
  const { bin = path$1.join(target, 'gradlew'), cwd = process.cwd() } =
    cli.flags
  if (verbose) {
    logger.logger.group()
    logger.logger.log('- target:', target)
    logger.logger.log('- gradle bin:', bin)
    logger.logger.groupEnd()
  }
  let gradleOpts = []
  if (cli.flags['gradleOpts']) {
    gradleOpts = cli.flags['gradleOpts']
      .split(' ')
      .map(s => s.trim())
      .filter(Boolean)
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$q)
    return
  }
  await convertGradleToMaven(
    target,
    String(bin),
    String(cwd),
    verbose,
    gradleOpts
  )
}

const config$s = {
  commandName: 'manifest',
  description: 'Generate a dependency manifest for given file or dir',
  hidden: false,
  flags: {
    ...commonFlags
  }
}
const cmdManifest = {
  description: config$s.description,
  hidden: config$s.hidden,
  run: run$s
}
async function run$s(argv, importMeta, { parentName }) {
  await meowWithSubcommands(
    {
      auto: cmdManifestAuto,
      conda: cmdManifestConda,
      scala: cmdManifestScala,
      gradle: cmdManifestGradle,
      kotlin: cmdManifestKotlin
    },
    {
      argv,
      aliases: {
        yolo: {
          description: config$s.description,
          hidden: true,
          argv: ['auto']
        }
      },
      description: config$s.description,
      importMeta,
      flags: config$s.flags,
      name: `${parentName} ${config$s.commandName}`
    }
  )
}

const { NPM: NPM$8 } = constants
async function wrapNpm(argv) {
  // Lazily access constants.distShadowNpmBinPath.
  const shadowBin = require(constants.distShadowNpmBinPath)
  await shadowBin(NPM$8, argv)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$p, NPM: NPM$7 } = constants
const config$r = {
  commandName: 'npm',
  description: `${NPM$7} wrapper functionality`,
  hidden: false,
  flags: {
    ...commonFlags
  },
  help: (command, _config) => `
    Usage
      $ ${command}
  `
}
const cmdNpm = {
  description: config$r.description,
  hidden: config$r.hidden,
  run: run$r
}
async function run$r(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    allowUnknownFlags: true,
    argv,
    config: config$r,
    importMeta,
    parentName
  })
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$p)
    return
  }
  await wrapNpm(argv)
}

const { NPX: NPX$2 } = constants
async function wrapNpx(argv) {
  // Lazily access constants.distShadowNpmBinPath.
  const shadowBin = require(constants.distShadowNpmBinPath)
  await shadowBin(NPX$2, argv)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$o, NPX: NPX$1 } = constants
const config$q = {
  commandName: 'npx',
  description: `${NPX$1} wrapper functionality`,
  hidden: false,
  flags: {
    ...commonFlags
  },
  help: (command, _config) => `
    Usage
      $ ${command}
  `
}
const cmdNpx = {
  description: config$q.description,
  hidden: config$q.hidden,
  run: run$q
}
async function run$q(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    allowUnknownFlags: true,
    argv,
    config: config$q,
    importMeta,
    parentName
  })
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$o)
    return
  }
  await wrapNpx(argv)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$n } = constants
const config$p = {
  commandName: 'oops',
  description: 'Trigger an intentional error (for development)',
  hidden: true,
  flags: {
    ...commonFlags
  },
  help: (parentName, config) => `
    Usage
      $ ${parentName} ${config.commandName}

    Don't run me.
  `
}
const cmdOops = {
  description: config$p.description,
  hidden: config$p.hidden,
  run: run$p
}
async function run$p(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$p,
    importMeta,
    parentName
  })

  // TODO: impl json/md

  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$n)
    return
  }
  throw new Error('This error was intentionally left blank')
}

const {
  BUN: BUN$4,
  NPM: NPM$6,
  PNPM: PNPM$5,
  VLT: VLT$4,
  YARN_BERRY: YARN_BERRY$4,
  YARN_CLASSIC: YARN_CLASSIC$5
} = constants
function matchLsCmdViewHumanStdout(stdout, name) {
  return stdout.includes(` ${name}@`)
}
function matchQueryCmdStdout(stdout, name) {
  return stdout.includes(`"${name}"`)
}
const depsIncludesByAgent = new Map([
  [BUN$4, matchLsCmdViewHumanStdout],
  [NPM$6, matchQueryCmdStdout],
  [PNPM$5, matchQueryCmdStdout],
  [VLT$4, matchQueryCmdStdout],
  [YARN_BERRY$4, matchLsCmdViewHumanStdout],
  [YARN_CLASSIC$5, matchLsCmdViewHumanStdout]
])

function getDependencyEntries(pkgEnvDetails) {
  const {
    dependencies,
    devDependencies,
    optionalDependencies,
    peerDependencies
  } = pkgEnvDetails.editablePkgJson.content
  return [
    [
      'dependencies',
      dependencies
        ? {
            __proto__: null,
            ...dependencies
          }
        : undefined
    ],
    [
      'devDependencies',
      devDependencies
        ? {
            __proto__: null,
            ...devDependencies
          }
        : undefined
    ],
    [
      'peerDependencies',
      peerDependencies
        ? {
            __proto__: null,
            ...peerDependencies
          }
        : undefined
    ],
    [
      'optionalDependencies',
      optionalDependencies
        ? {
            __proto__: null,
            ...optionalDependencies
          }
        : undefined
    ]
  ].filter(({ 1: o }) => o)
}

const {
  BUN: BUN$3,
  NPM: NPM$5,
  OVERRIDES: OVERRIDES$1,
  PNPM: PNPM$4,
  RESOLUTIONS: RESOLUTIONS$1,
  VLT: VLT$3,
  YARN_BERRY: YARN_BERRY$3,
  YARN_CLASSIC: YARN_CLASSIC$4
} = constants
function getOverridesDataBun(pkgEnvDetails) {
  const overrides = pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS$1] ?? {}
  return {
    type: YARN_BERRY$3,
    overrides
  }
}

// npm overrides documentation:
// https://docs.npmjs.com/cli/v10/configuring-npm/package-json#overrides
function getOverridesDataNpm(pkgEnvDetails) {
  const overrides = pkgEnvDetails.editablePkgJson.content?.[OVERRIDES$1] ?? {}
  return {
    type: NPM$5,
    overrides
  }
}

// pnpm overrides documentation:
// https://pnpm.io/package_json#pnpmoverrides
function getOverridesDataPnpm(pkgEnvDetails) {
  const overrides =
    pkgEnvDetails.editablePkgJson.content?.[PNPM$4]?.[OVERRIDES$1] ?? {}
  return {
    type: PNPM$4,
    overrides
  }
}
function getOverridesDataVlt(pkgEnvDetails) {
  const overrides = pkgEnvDetails.editablePkgJson.content?.[OVERRIDES$1] ?? {}
  return {
    type: VLT$3,
    overrides
  }
}

// Yarn resolutions documentation:
// https://yarnpkg.com/configuration/manifest#resolutions
function getOverridesDataYarn(pkgEnvDetails) {
  const overrides = pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS$1] ?? {}
  return {
    type: YARN_BERRY$3,
    overrides
  }
}

// Yarn resolutions documentation:
// https://classic.yarnpkg.com/en/docs/selective-version-resolutions
function getOverridesDataYarnClassic(pkgEnvDetails) {
  const overrides = pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS$1] ?? {}
  return {
    type: YARN_CLASSIC$4,
    overrides
  }
}
const overridesDataByAgent = new Map([
  [BUN$3, getOverridesDataBun],
  [NPM$5, getOverridesDataNpm],
  [PNPM$4, getOverridesDataPnpm],
  [VLT$3, getOverridesDataVlt],
  [YARN_BERRY$3, getOverridesDataYarn],
  [YARN_CLASSIC$4, getOverridesDataYarnClassic]
])

const {
  BUN: BUN$2,
  LOCK_EXT,
  NPM: NPM$4,
  PNPM: PNPM$3,
  VLT: VLT$2,
  YARN_BERRY: YARN_BERRY$2,
  YARN_CLASSIC: YARN_CLASSIC$3
} = constants
function includesNpm(lockSrc, name) {
  // Detects the package name in the following cases:
  //   "name":
  return lockSrc.includes(`"${name}":`)
}
function includesBun(lockSrc, name, lockName) {
  // This is a bit counterintuitive. When lockName ends with a .lockb
  // we treat it as a yarn.lock. When lockName ends with a .lock we
  // treat it as a package-lock.json. The bun.lock format is not identical
  // package-lock.json, however it close enough for npmLockIncludes to work.
  const lockfileScanner = lockName?.endsWith(LOCK_EXT)
    ? includesNpm
    : includesYarn
  return lockfileScanner(lockSrc, name)
}
function includesPnpm(lockSrc, name) {
  const escapedName = regexps.escapeRegExp(name)
  return new RegExp(
    // Detects the package name in the following cases:
    //   /name/
    //   'name'
    //   name:
    //   name@
    `(?<=^\\s*)(?:(['/])${escapedName}\\1|${escapedName}(?=[:@]))`,
    'm'
  ).test(lockSrc)
}
function includesVlt(lockSrc, name) {
  // Detects the package name in the following cases:
  //   "name"
  return lockSrc.includes(`"${name}"`)
}
function includesYarn(lockSrc, name) {
  const escapedName = regexps.escapeRegExp(name)
  return new RegExp(
    // Detects the package name in the following cases:
    //   "name@
    //   , "name@
    //   name@
    //   , name@
    `(?<=(?:^\\s*|,\\s*)"?)${escapedName}(?=@)`,
    'm'
  ).test(lockSrc)
}
const lockfileIncludesByAgent = new Map([
  [BUN$2, includesBun],
  [NPM$4, includesNpm],
  [PNPM$3, includesPnpm],
  [VLT$2, includesVlt],
  [YARN_BERRY$2, includesYarn],
  [YARN_CLASSIC$3, includesYarn]
])

const {
  BUN: BUN$1,
  NPM: NPM$3,
  PNPM: PNPM$2,
  VLT: VLT$1,
  YARN_BERRY: YARN_BERRY$1,
  YARN_CLASSIC: YARN_CLASSIC$2
} = constants
function cleanupQueryStdout(stdout) {
  if (stdout === '') {
    return ''
  }
  let pkgs
  try {
    pkgs = JSON.parse(stdout)
  } catch {}
  if (!Array.isArray(pkgs)) {
    return ''
  }
  const names = new Set()
  for (const { _id, name, pkgid } of pkgs) {
    // `npm query` results may not have a "name" property, in which case we
    // fallback to "_id" and then "pkgid".
    // `vlt ls --view json` results always have a "name" property.
    const fallback = _id ?? pkgid ?? ''
    const resolvedName = name ?? fallback.slice(0, fallback.indexOf('@', 1))
    // Add package names, except for those under the `@types` scope as those
    // are known to only be dev dependencies.
    if (resolvedName && !resolvedName.startsWith('@types/')) {
      names.add(resolvedName)
    }
  }
  return JSON.stringify([...names], null, 2)
}
function parsableToQueryStdout(stdout) {
  if (stdout === '') {
    return ''
  }
  // Convert the parsable stdout into a json array of unique names.
  // The matchAll regexp looks for a forward (posix) or backward (win32) slash
  // and matches one or more non-slashes until the newline.
  const names = new Set(stdout.matchAll(/(?<=[/\\])[^/\\]+(?=\n)/g))
  return JSON.stringify([...names], null, 2)
}
async function npmQuery(npmExecPath, cwd) {
  let stdout = ''
  try {
    stdout = (
      await spawn.spawn(npmExecPath, ['query', ':not(.dev)'], {
        cwd
      })
    ).stdout
  } catch {}
  return cleanupQueryStdout(stdout)
}
async function lsBun(pkgEnvDetails, cwd) {
  try {
    // Bun does not support filtering by production packages yet.
    // https://github.com/oven-sh/bun/issues/8283
    return (
      await spawn.spawn(pkgEnvDetails.agentExecPath, ['pm', 'ls', '--all'], {
        cwd
      })
    ).stdout
  } catch {}
  return ''
}
async function lsNpm(pkgEnvDetails, cwd) {
  return await npmQuery(pkgEnvDetails.agentExecPath, cwd)
}
async function lsPnpm(pkgEnvDetails, cwd, options) {
  const npmExecPath = options?.npmExecPath
  if (npmExecPath && npmExecPath !== NPM$3) {
    const result = await npmQuery(npmExecPath, cwd)
    if (result) {
      return result
    }
  }
  let stdout = ''
  try {
    stdout = (
      await spawn.spawn(
        pkgEnvDetails.agentExecPath,
        // Pnpm uses the alternative spelling of parsable.
        // https://en.wiktionary.org/wiki/parsable
        ['ls', '--parseable', '--prod', '--depth', 'Infinity'],
        {
          cwd
        }
      )
    ).stdout
  } catch {}
  return parsableToQueryStdout(stdout)
}
async function lsVlt(pkgEnvDetails, cwd) {
  let stdout = ''
  try {
    // See https://docs.vlt.sh/cli/commands/list#options.
    stdout = (
      await spawn.spawn(
        pkgEnvDetails.agentExecPath,
        ['ls', '--view', 'human', ':not(.dev)'],
        {
          cwd
        }
      )
    ).stdout
  } catch {}
  return cleanupQueryStdout(stdout)
}
async function lsYarnBerry(pkgEnvDetails, cwd) {
  try {
    return (
      // Yarn Berry does not support filtering by production packages yet.
      // https://github.com/yarnpkg/berry/issues/5117
      (
        await spawn.spawn(
          pkgEnvDetails.agentExecPath,
          ['info', '--recursive', '--name-only'],
          {
            cwd
          }
        )
      ).stdout.trim()
    )
  } catch {}
  return ''
}
async function lsYarnClassic(pkgEnvDetails, cwd) {
  try {
    // However, Yarn Classic does support it.
    // https://github.com/yarnpkg/yarn/releases/tag/v1.0.0
    // > Fix: Excludes dev dependencies from the yarn list output when the
    //   environment is production
    return (
      await spawn.spawn(pkgEnvDetails.agentExecPath, ['list', '--prod'], {
        cwd
      })
    ).stdout.trim()
  } catch {}
  return ''
}
const lsByAgent = new Map([
  [BUN$1, lsBun],
  [NPM$3, lsNpm],
  [PNPM$2, lsPnpm],
  [VLT$1, lsVlt],
  [YARN_BERRY$1, lsYarnBerry],
  [YARN_CLASSIC$2, lsYarnClassic]
])

const CMD_NAME = 'socket optimize'

const {
  BUN,
  NPM: NPM$2,
  OVERRIDES,
  PNPM: PNPM$1,
  RESOLUTIONS,
  VLT,
  YARN_BERRY,
  YARN_CLASSIC: YARN_CLASSIC$1
} = constants
const depFields = [
  'dependencies',
  'devDependencies',
  'peerDependencies',
  'peerDependenciesMeta',
  'optionalDependencies',
  'bundleDependencies'
]
function getEntryIndexes(entries, keys) {
  return keys
    .map(n => entries.findIndex(p => p[0] === n))
    .filter(n => n !== -1)
    .sort((a, b) => a - b)
}
function getLowestEntryIndex(entries, keys) {
  return getEntryIndexes(entries, keys)?.[0] ?? -1
}
function getHighestEntryIndex(entries, keys) {
  return getEntryIndexes(entries, keys).at(-1) ?? -1
}
function updatePkgJsonField(editablePkgJson, field, value) {
  const oldValue = editablePkgJson.content[field]
  if (oldValue) {
    // The field already exists so we simply update the field value.
    if (field === PNPM$1) {
      const isPnpmObj = objects.isObject(oldValue)
      if (objects.hasKeys(value)) {
        editablePkgJson.update({
          [field]: {
            ...(isPnpmObj ? oldValue : {}),
            overrides: {
              ...(isPnpmObj ? oldValue[OVERRIDES] : {}),
              ...value
            }
          }
        })
      } else {
        // Properties with undefined values are omitted when saved as JSON.
        editablePkgJson.update(
          objects.hasKeys(oldValue)
            ? {
                [field]: {
                  ...(isPnpmObj ? oldValue : {}),
                  overrides: undefined
                }
              }
            : {
                [field]: undefined
              }
        )
      }
    } else if (field === OVERRIDES || field === RESOLUTIONS) {
      // Properties with undefined values are omitted when saved as JSON.
      editablePkgJson.update({
        [field]: objects.hasKeys(value) ? value : undefined
      })
    } else {
      editablePkgJson.update({
        [field]: value
      })
    }
    return
  }
  if (
    (field === OVERRIDES || field === PNPM$1 || field === RESOLUTIONS) &&
    !objects.hasKeys(value)
  ) {
    return
  }
  // Since the field doesn't exist we want to insert it into the package.json
  // in a place that makes sense, e.g. close to the "dependencies" field. If
  // we can't find a place to insert the field we'll add it to the bottom.
  const entries = Object.entries(editablePkgJson.content)
  let insertIndex = -1
  let isPlacingHigher = false
  if (field === OVERRIDES) {
    insertIndex = getLowestEntryIndex(entries, [RESOLUTIONS])
    if (insertIndex === -1) {
      isPlacingHigher = true
      insertIndex = getHighestEntryIndex(entries, [...depFields, PNPM$1])
    }
  } else if (field === RESOLUTIONS) {
    isPlacingHigher = true
    insertIndex = getHighestEntryIndex(entries, [
      ...depFields,
      OVERRIDES,
      PNPM$1
    ])
  } else if (field === PNPM$1) {
    insertIndex = getLowestEntryIndex(entries, [OVERRIDES, RESOLUTIONS])
    if (insertIndex === -1) {
      isPlacingHigher = true
      insertIndex = getHighestEntryIndex(entries, depFields)
    }
  }
  if (insertIndex === -1) {
    insertIndex = getLowestEntryIndex(entries, ['engines', 'files'])
  }
  if (insertIndex === -1) {
    isPlacingHigher = true
    insertIndex = getHighestEntryIndex(entries, ['exports', 'imports', 'main'])
  }
  if (insertIndex === -1) {
    insertIndex = entries.length
  } else if (isPlacingHigher) {
    insertIndex += 1
  }
  entries.splice(insertIndex, 0, [
    field,
    field === PNPM$1
      ? {
          [OVERRIDES]: value
        }
      : value
  ])
  editablePkgJson.fromJSON(
    `${JSON.stringify(Object.fromEntries(entries), null, 2)}\n`
  )
}
function updateOverridesField(pkgEnvDetails, overrides) {
  updatePkgJsonField(pkgEnvDetails.editablePkgJson, OVERRIDES, overrides)
}
function updateResolutionsField(pkgEnvDetails, overrides) {
  updatePkgJsonField(pkgEnvDetails.editablePkgJson, RESOLUTIONS, overrides)
}
function updatePnpmField(pkgEnvDetails, overrides) {
  updatePkgJsonField(pkgEnvDetails.editablePkgJson, PNPM$1, overrides)
}
const updateManifestByAgent = new Map([
  [BUN, updateResolutionsField],
  [NPM$2, updateOverridesField],
  [PNPM$1, updatePnpmField],
  [VLT, updateOverridesField],
  [YARN_BERRY, updateResolutionsField],
  [YARN_CLASSIC$1, updateResolutionsField]
])

const { NPM: NPM$1, PNPM, YARN_CLASSIC } = constants
const manifestNpmOverrides = registry.getManifestData(NPM$1)
async function addOverrides(pkgEnvDetails, pkgPath, options) {
  const {
    agent,
    lockName,
    lockSrc,
    npmExecPath,
    pkgPath: rootPath
  } = pkgEnvDetails
  const {
    logger,
    pin,
    prod,
    spinner,
    state = {
      added: new Set(),
      addedInWorkspaces: new Set(),
      updated: new Set(),
      updatedInWorkspaces: new Set(),
      warnedPnpmWorkspaceRequiresNpm: false
    }
  } = {
    __proto__: null,
    ...options
  }
  const workspacePkgJsonPaths = await shadowNpmInject.globWorkspace(
    agent,
    pkgPath
  )
  const isWorkspace = workspacePkgJsonPaths.length > 0
  const isWorkspaceRoot = pkgPath === rootPath
  const isLockScanned = isWorkspaceRoot && !prod
  const workspaceName = isWorkspaceRoot
    ? 'root'
    : path$1.relative(rootPath, pkgPath)
  if (
    isWorkspace &&
    agent === PNPM &&
    // npmExecPath will === the agent name IF it CANNOT be resolved.
    npmExecPath === NPM$1 &&
    !state.warnedPnpmWorkspaceRequiresNpm
  ) {
    state.warnedPnpmWorkspaceRequiresNpm = true
    logger?.warn(
      cmdPrefixMessage(
        CMD_NAME,
        `${agent} workspace support requires \`npm ls\`, falling back to \`${agent} list\``
      )
    )
  }
  const overridesDataObjects = []
  if (isWorkspace || pkgEnvDetails.editablePkgJson.content['private']) {
    overridesDataObjects.push(overridesDataByAgent.get(agent)(pkgEnvDetails))
  } else {
    overridesDataObjects.push(
      overridesDataByAgent.get(NPM$1)(pkgEnvDetails),
      overridesDataByAgent.get(YARN_CLASSIC)(pkgEnvDetails)
    )
  }
  spinner?.setText(`Adding overrides to ${workspaceName}...`)
  const depAliasMap = new Map()
  const depEntries = getDependencyEntries(pkgEnvDetails)
  const manifestEntries = manifestNpmOverrides.filter(({ 1: data }) =>
    vendor.semverExports.satisfies(
      // Roughly check Node range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      vendor.semverExports.coerce(data.engines.node),
      pkgEnvDetails.pkgRequirements.node
    )
  )

  // Chunk package names to process them in parallel 3 at a time.
  await promises.pEach(manifestEntries, 3, async ({ 1: data }) => {
    const { name: sockRegPkgName, package: origPkgName, version } = data
    const major = vendor.semverExports.major(version)
    const sockOverridePrefix = `${NPM$1}:${sockRegPkgName}@`
    const sockOverrideSpec = `${sockOverridePrefix}${pin ? version : `^${major}`}`
    for (const { 1: depObj } of depEntries) {
      const sockSpec = objects.hasOwn(depObj, sockRegPkgName)
        ? depObj[sockRegPkgName]
        : undefined
      if (sockSpec) {
        depAliasMap.set(sockRegPkgName, sockSpec)
      }
      const origSpec = objects.hasOwn(depObj, origPkgName)
        ? depObj[origPkgName]
        : undefined
      if (origSpec) {
        let thisSpec = origSpec
        // Add package aliases for direct dependencies to avoid npm EOVERRIDE
        // errors...
        // https://docs.npmjs.com/cli/v8/using-npm/package-spec#aliases
        if (
          // ...if the spec doesn't start with a valid Socket override.
          !(
            thisSpec.startsWith(sockOverridePrefix) &&
            // Check the validity of the spec by passing it through npa and
            // seeing if it will coerce to a version.
            vendor.semverExports.coerce(vendor.npaExports(thisSpec).rawSpec)
              ?.version
          )
        ) {
          thisSpec = sockOverrideSpec
          depObj[origPkgName] = thisSpec
          state.added.add(sockRegPkgName)
          if (!isWorkspaceRoot) {
            state.addedInWorkspaces.add(workspaceName)
          }
        }
        depAliasMap.set(origPkgName, thisSpec)
      }
    }
    if (isWorkspaceRoot) {
      // The AgentDepsIncludesFn and AgentLockIncludesFn types overlap in their
      // first two parameters. AgentLockIncludesFn accepts an optional third
      // parameter which AgentDepsIncludesFn will ignore so we cast thingScanner
      // as an AgentLockIncludesFn type.
      const thingScanner = isLockScanned
        ? lockfileIncludesByAgent.get(agent)
        : depsIncludesByAgent.get(agent)
      const thingToScan = isLockScanned
        ? lockSrc
        : await lsByAgent.get(agent)(pkgEnvDetails, pkgPath, {
            npmExecPath
          })
      // Chunk package names to process them in parallel 3 at a time.
      await promises.pEach(
        overridesDataObjects,
        3,
        async ({ overrides, type }) => {
          const overrideExists = objects.hasOwn(overrides, origPkgName)
          if (
            overrideExists ||
            thingScanner(thingToScan, origPkgName, lockName)
          ) {
            const oldSpec = overrideExists ? overrides[origPkgName] : undefined
            const origDepAlias = depAliasMap.get(origPkgName)
            const sockRegDepAlias = depAliasMap.get(sockRegPkgName)
            const depAlias = sockRegDepAlias ?? origDepAlias
            let newSpec = sockOverrideSpec
            if (type === NPM$1 && depAlias) {
              // With npm one may not set an override for a package that one directly
              // depends on unless both the dependency and the override itself share
              // the exact same spec. To make this limitation easier to deal with,
              // overrides may also be defined as a reference to a spec for a direct
              // dependency by prefixing the name of the package to match the version
              // of with a $.
              // https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides
              newSpec = `$${sockRegDepAlias ? sockRegPkgName : origPkgName}`
            } else if (typeof oldSpec === 'string') {
              const thisSpec = oldSpec.startsWith('$')
                ? depAlias || newSpec
                : oldSpec || newSpec
              if (thisSpec.startsWith(sockOverridePrefix)) {
                if (
                  pin &&
                  vendor.semverExports.major(
                    // Check the validity of the spec by passing it through npa
                    // and seeing if it will coerce to a version. semver.coerce
                    // will strip leading v's, carets (^), comparators (<,<=,>,>=,=),
                    // and tildes (~). If not coerced to a valid version then
                    // default to the manifest entry version.
                    vendor.semverExports.coerce(
                      vendor.npaExports(thisSpec).rawSpec
                    )?.version ?? version
                  ) !== major
                ) {
                  const otherVersion = (
                    await packages.fetchPackageManifest(thisSpec)
                  )?.version
                  if (otherVersion && otherVersion !== version) {
                    newSpec = `${sockOverridePrefix}${pin ? otherVersion : `^${vendor.semverExports.major(otherVersion)}`}`
                  }
                }
              } else {
                newSpec = oldSpec
              }
            }
            if (newSpec !== oldSpec) {
              overrides[origPkgName] = newSpec
              const addedOrUpdated = overrideExists ? 'updated' : 'added'
              state[addedOrUpdated].add(sockRegPkgName)
            }
          }
        }
      )
    }
  })
  if (isWorkspace) {
    // Chunk package names to process them in parallel 3 at a time.
    await promises.pEach(
      workspacePkgJsonPaths,
      3,
      async workspacePkgJsonPath => {
        const otherState = await addOverrides(
          pkgEnvDetails,
          path$1.dirname(workspacePkgJsonPath),
          {
            logger,
            pin,
            prod,
            spinner
          }
        )
        for (const key of [
          'added',
          'addedInWorkspaces',
          'updated',
          'updatedInWorkspaces'
        ]) {
          for (const value of otherState[key]) {
            state[key].add(value)
          }
        }
      }
    )
  }
  if (state.added.size > 0 || state.updated.size > 0) {
    pkgEnvDetails.editablePkgJson.update(Object.fromEntries(depEntries))
    for (const { overrides, type } of overridesDataObjects) {
      updateManifestByAgent.get(type)(
        pkgEnvDetails,
        objects.toSortedObject(overrides)
      )
    }
    await pkgEnvDetails.editablePkgJson.save()
  }
  return state
}

const { NPM_BUGGY_OVERRIDES_PATCHED_VERSION } = constants
async function updateLockfile(pkgEnvDetails, options) {
  const {
    cmdName = '',
    logger,
    spinner
  } = {
    __proto__: null,
    ...options
  }
  const isSpinning = !!spinner?.['isSpinning']
  if (!isSpinning) {
    spinner?.start()
  }
  spinner?.setText(`Updating ${pkgEnvDetails.lockName}...`)
  try {
    await runAgentInstall(pkgEnvDetails, {
      spinner
    })
    if (pkgEnvDetails.features.npmBuggyOverrides) {
      spinner?.stop()
      logger?.log(
        ` Re-run ${cmdName ? `${cmdName} ` : ''}whenever ${pkgEnvDetails.lockName} changes.\n   This can be skipped for ${pkgEnvDetails.agent} >=${NPM_BUGGY_OVERRIDES_PATCHED_VERSION}.`
      )
    }
  } catch (e) {
    spinner?.stop()
    logger?.fail(
      cmdPrefixMessage(
        cmdName,
        `${pkgEnvDetails.agent} install failed to update ${pkgEnvDetails.lockName}`
      )
    )
    logger?.error(e)
  }
  if (isSpinning) {
    spinner?.start()
  } else {
    spinner?.stop()
  }
}

function createActionMessage(verb, overrideCount, workspaceCount) {
  return `${verb} ${overrideCount} Socket.dev optimized ${words.pluralize('override', overrideCount)}${workspaceCount ? ` in ${workspaceCount} ${words.pluralize('workspace', workspaceCount)}` : ''}`
}
async function applyOptimization(cwd, pin, prod) {
  const pkgEnvDetails = await detectAndValidatePackageEnvironment(cwd, {
    cmdName: CMD_NAME,
    logger: logger.logger,
    prod
  })
  if (!pkgEnvDetails) {
    return
  }
  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Socket optimizing...')
  const state = await addOverrides(pkgEnvDetails, pkgEnvDetails.pkgPath, {
    logger: logger.logger,
    pin,
    prod,
    spinner
  })
  const addedCount = state.added.size
  const updatedCount = state.updated.size
  const pkgJsonChanged = addedCount > 0 || updatedCount > 0
  if (pkgJsonChanged || pkgEnvDetails.features.npmBuggyOverrides) {
    await updateLockfile(pkgEnvDetails, {
      cmdName: CMD_NAME,
      logger: logger.logger,
      spinner
    })
  }
  spinner.stop()
  if (pkgJsonChanged) {
    if (updatedCount > 0) {
      logger.logger?.log(
        `${createActionMessage('Updated', updatedCount, state.updatedInWorkspaces.size)}${addedCount ? '.' : ''}`
      )
    }
    if (addedCount > 0) {
      logger.logger?.log(
        `${createActionMessage('Added', addedCount, state.addedInWorkspaces.size)} `
      )
    }
  } else {
    logger.logger?.log('Congratulations! Already Socket.dev optimized ')
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$m } = constants
const config$o = {
  commandName: 'optimize',
  description: 'Optimize dependencies with @socketregistry overrides',
  hidden: false,
  flags: {
    ...commonFlags,
    pin: {
      type: 'boolean',
      default: false,
      description: 'Pin overrides to their latest version'
    },
    prod: {
      type: 'boolean',
      default: false,
      description: 'Only add overrides for production dependencies'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}
      $ ${command} --pin
  `
}
const cmdOptimize = {
  description: config$o.description,
  hidden: config$o.hidden,
  run: run$o
}
async function run$o(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$o,
    importMeta,
    parentName
  })

  // TODO: impl json/md

  const cwd = process.cwd()
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$m)
    return
  }
  await applyOptimization(
    cwd,
    Boolean(cli.flags['pin']),
    Boolean(cli.flags['prod'])
  )
}

async function fetchOrganization() {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching organization list...')
  const result = await handleApiCall(
    sockSdk.getOrganizations(),
    'looking up organizations'
  )
  spinner.successAndStop('Received organization list response.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrganizations', result)
  }
  return result.data
}

async function outputOrganizationList(data, outputKind = 'text') {
  const organizations = Object.values(data.organizations)
  const apiToken = shadowNpmInject.getDefaultToken()
  const lastFiveOfApiToken = getLastFiveOfApiToken(apiToken ?? '?????')
  switch (outputKind) {
    case 'json': {
      logger.logger.log(
        JSON.stringify(
          organizations.map(o => ({
            name: o.name,
            id: o.id,
            plan: o.plan
          })),
          null,
          2
        )
      )
      return
    }
    case 'markdown': {
      // | Syntax      | Description |
      // | ----------- | ----------- |
      // | Header      | Title       |
      // | Paragraph   | Text        |
      let mw1 = 4
      let mw2 = 2
      let mw3 = 4
      for (const o of organizations) {
        mw1 = Math.max(mw1, o.name?.length ?? 0)
        mw2 = Math.max(mw2, o.id.length)
        mw3 = Math.max(mw3, o.plan.length)
      }
      logger.logger.log('# Organizations\n')
      logger.logger.log(
        `List of organizations associated with your API key, ending with: ${vendor.yoctocolorsCjsExports.italic(lastFiveOfApiToken)}\n`
      )
      logger.logger.log(
        `| Name${' '.repeat(mw1 - 4)} | ID${' '.repeat(mw2 - 2)} | Plan${' '.repeat(mw3 - 4)} |`
      )
      logger.logger.log(
        `| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} | ${'-'.repeat(mw3)} |`
      )
      for (const o of organizations) {
        logger.logger.log(
          `| ${(o.name || '').padEnd(mw1, ' ')} | ${(o.id || '').padEnd(mw2, ' ')} | ${(o.plan || '').padEnd(mw3, ' ')} |`
        )
      }
      logger.logger.log(
        `| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} | ${'-'.repeat(mw3)} |`
      )
      return
    }
    default: {
      logger.logger.log(
        `List of organizations associated with your API key, ending with: ${vendor.yoctocolorsCjsExports.italic(lastFiveOfApiToken)}\n`
      )
      // Just dump
      for (const o of organizations) {
        logger.logger.log(
          `- Name: ${vendor.yoctocolorsCjsExports.bold(o.name ?? 'undefined')}, ID: ${vendor.yoctocolorsCjsExports.bold(o.id)}, Plan: ${vendor.yoctocolorsCjsExports.bold(o.plan)}`
        )
      }
    }
  }
}

async function handleOrganizationList(outputKind = 'text') {
  const data = await fetchOrganization()
  if (!data) {
    return
  }
  await outputOrganizationList(data, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$l } = constants
const config$n = {
  commandName: 'list',
  description: 'List organizations associated with the API key used',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, _config) => `
    Usage
      $ ${command}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: none (does need a token)

    Options
      ${getFlagListOutput(config$n.flags, 6)}
  `
}
const cmdOrganizationList = {
  description: config$n.description,
  hidden: config$n.hidden,
  run: run$n
}
async function run$n(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$n,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$l)
    return
  }
  await handleOrganizationList(outputKind)
}

async function fetchLicensePolicy(orgSlug) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching organization license policy...')
  const result = await handleApiCall(
    sockSdk.getOrgLicensePolicy(orgSlug),
    'looking up organization quota'
  )
  spinner.successAndStop('Received organization license policy response.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgLicensePolicy', result)
  }
  return result.data
}

async function outputLicensePolicy(data, outputKind) {
  if (outputKind === 'json') {
    let json
    try {
      json = JSON.stringify(data, null, 2)
    } catch {
      console.error(
        'Failed to convert the server response to json, try running the same command without --json'
      )
      return
    }
    logger.logger.log(json)
    logger.logger.log('')
    return
  }
  logger.logger.error('Use --json to get the full result')
  logger.logger.log('# License policy')
  logger.logger.log('')
  logger.logger.log('This is the license policy for your organization:')
  logger.logger.log('')
  const rules = data.license_policy
  const entries = rules ? Object.entries(rules) : []
  const mapped = entries.map(([key, value]) => [
    key,
    value.allowed ? ' yes' : ' no'
  ])
  mapped.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))
  logger.logger.log(mdTableOfPairs(mapped, ['License Name', 'Allowed']))
  logger.logger.log('')
}

async function handleLicensePolicy(orgSlug, outputKind) {
  const data = await fetchLicensePolicy(orgSlug)
  if (!data) {
    return
  }
  await outputLicensePolicy(data, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$k } = constants

// TODO: secret toplevel alias `socket license policy`?
const config$m = {
  commandName: 'license',
  description: 'Retrieve the license policy of an organization',
  hidden: true,
  flags: {
    ...commonFlags,
    ...outputFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    }
  },
  help: (command, _config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: license-policy:read

    Options
      ${getFlagListOutput(config$m.flags, 6)}

    Your API token will need the \`license-policy:read\` permission otherwise
    the request will fail with an authentication error.

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' mycorp'}
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' mycorp'} --json
  `
}
const cmdOrganizationPolicyLicense = {
  description: config$m.description,
  hidden: config$m.hidden,
  run: run$m
}
async function run$m(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$m,
    importMeta,
    parentName
  })
  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [orgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$k)
    return
  }
  await handleLicensePolicy(orgSlug, outputKind)
}

async function fetchSecurityPolicy(orgSlug) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching organization security policy...')
  const result = await handleApiCall(
    sockSdk.getOrgSecurityPolicy(orgSlug),
    'looking up organization quota'
  )
  spinner.successAndStop('Received organization security policy response.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgSecurityPolicy', result)
  }
  return result.data
}

async function outputSecurityPolicy(data, outputKind) {
  if (outputKind === 'json') {
    let json
    try {
      json = JSON.stringify(data, null, 2)
    } catch {
      console.error(
        'Failed to convert the server response to json, try running the same command without --json'
      )
      return
    }
    logger.logger.log(json)
    logger.logger.log('')
    return
  }
  logger.logger.log('# Security policy')
  logger.logger.log('')
  logger.logger.log(
    `The default security policy setting is: "${data.securityPolicyDefault}"`
  )
  logger.logger.log('')
  logger.logger.log(
    'These are the security policies per setting for your organization:'
  )
  logger.logger.log('')
  const rules = data.securityPolicyRules
  const entries = rules ? Object.entries(rules) : []
  const mapped = entries.map(([key, value]) => [key, value.action])
  mapped.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))
  logger.logger.log(mdTableOfPairs(mapped, ['name', 'action']))
  logger.logger.log('')
}

async function handleSecurityPolicy(orgSlug, outputKind) {
  const data = await fetchSecurityPolicy(orgSlug)
  if (!data) {
    return
  }
  await outputSecurityPolicy(data, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$j } = constants

// TODO: secret toplevel alias `socket security policy`?
const config$l = {
  commandName: 'security',
  description: 'Retrieve the security policy of an organization',
  hidden: true,
  flags: {
    ...commonFlags,
    ...outputFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    }
  },
  help: (command, _config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: security-policy:read

    Options
      ${getFlagListOutput(config$l.flags, 6)}

    Your API token will need the \`security-policy:read\` permission otherwise
    the request will fail with an authentication error.

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' mycorp'}
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' mycorp'} --json
  `
}
const cmdOrganizationPolicyPolicy = {
  description: config$l.description,
  hidden: config$l.hidden,
  run: run$l
}
async function run$l(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$l,
    importMeta,
    parentName
  })
  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [orgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: 'Org name as the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$j)
    return
  }
  await handleSecurityPolicy(orgSlug, outputKind)
}

const description$5 = 'Organization policy details'
const cmdOrganizationPolicy = {
  description: description$5,
  // Hidden because it was broken all this time (nobody could be using it)
  // and we're not sure if it's useful to anyone in its current state.
  // Until we do, we'll hide this to keep the help tidier.
  // And later, we may simply move this under `scan`, anyways.
  hidden: true,
  async run(argv, importMeta, { parentName }) {
    await meowWithSubcommands(
      {
        security: cmdOrganizationPolicyPolicy,
        license: cmdOrganizationPolicyLicense
      },
      {
        argv,
        description: description$5,
        defaultSub: 'list',
        // Backwards compat
        importMeta,
        name: parentName + ' policy'
      }
    )
  }
}

async function fetchQuota() {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching organization quota...')
  const result = await handleApiCall(
    sockSdk.getQuota(),
    'looking up organization quota'
  )
  spinner.successAndStop('Received organization quota response.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('getQuota', result)
  }
  return result.data
}

async function outputQuota(data, outputKind = 'text') {
  if (outputKind === 'json') {
    let json
    try {
      json = JSON.stringify(data, null, 2)
    } catch {
      console.error(
        'Failed to convert the server response to json, try running the same command without --json'
      )
      return
    }
    logger.logger.log(json)
    logger.logger.log('')
    return
  }
  if (outputKind === 'markdown') {
    logger.logger.log('# Quota')
    logger.logger.log('')
    logger.logger.log(`Quota left on the current API token: ${data.quota}`)
    logger.logger.log('')
    return
  }
  logger.logger.log(`Quota left on the current API token: ${data.quota}`)
  logger.logger.log('')
}

async function handleQuota(outputKind = 'text') {
  const data = await fetchQuota()
  if (!data) {
    return
  }
  await outputQuota(data, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$i } = constants
const config$k = {
  commandName: 'quota',
  description: 'List organizations associated with the API key used',
  hidden: true,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, _config) => `
    Usage
      $ ${command}

    Options
      ${getFlagListOutput(config$k.flags, 6)}
  `
}
const cmdOrganizationQuota = {
  description: config$k.description,
  hidden: config$k.hidden,
  run: run$k
}
async function run$k(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$k,
    importMeta,
    parentName
  })
  const json = Boolean(cli.flags['json'])
  const markdown = Boolean(cli.flags['markdown'])
  const outputKind = getOutputKind(json, markdown)
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$i)
    return
  }
  await handleQuota(outputKind)
}

const description$4 = 'Account details'
const cmdOrganization = {
  description: description$4,
  // Hidden because it was broken all this time (nobody could be using it)
  // and we're not sure if it's useful to anyone in its current state.
  // Until we do, we'll hide this to keep the help tidier.
  // And later, we may simply move this under `scan`, anyways.
  hidden: true,
  async run(argv, importMeta, { parentName }) {
    await meowWithSubcommands(
      {
        list: cmdOrganizationList,
        quota: cmdOrganizationQuota,
        policy: cmdOrganizationPolicy
      },
      {
        argv,
        description: description$4,
        defaultSub: 'list',
        // Backwards compat
        importMeta,
        name: parentName + ' organization'
      }
    )
  }
}

const { SOCKET_CLI_ISSUES_URL } = constants
async function fetchPurlDeepScore(purl) {
  logger.logger.info(`Requesting deep score data for this purl: ${purl}`)
  const apiToken = shadowNpmInject.getDefaultToken()
  if (!apiToken) {
    throw new shadowNpmInject.AuthError(
      'User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.'
    )
  }

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Getting deep package score...')
  let result
  try {
    result = await queryApi(`purl/score/${encodeURIComponent(purl)}`, apiToken)
    spinner.successAndStop('Received deep package score response.')
  } catch (e) {
    spinner.failAndStop('The request was unsuccessful.')
    const msg = e?.message
    if (msg) {
      logger.logger.fail(msg)
      logger.logger.log(
        'Please report this if the error persists or use the cli version that includes error reporting to automate that'
      )
    } else {
      logger.logger.log(
        'An error happened but no reason was given. If this persists please let us know about it and what you were trying to achieve. Thank you.'
      )
    }
    return
  }
  if (!result.ok) {
    const err = await handleApiError(result.status)
    logger.logger.fail(failMsgWithBadge(result.statusText, err))
    process.exitCode = 1
    return
  }
  const data = await handleApiCall(await result.text(), 'Reading text')
  try {
    return JSON.parse(data)
  } catch (e) {
    throw new Error(
      `Unable to parse JSON response from the Socket API.\nPlease report to ${SOCKET_CLI_ISSUES_URL}`
    )
  }
}

async function outputPurlScore(purl, data, outputKind) {
  if (outputKind === 'json') {
    let json
    try {
      json = JSON.stringify(data, null, 2)
    } catch {
      console.error(
        'Failed to convert the server response to JSON... Please try again or reach out to customer support.'
      )
      process.exitCode = 1
      return
    }
    logger.logger.error(`Score report for "${purl}":\n`)
    logger.logger.log(json)
    logger.logger.log('')
    return
  }
  if (outputKind === 'markdown') {
    const {
      purl: requestedPurl,
      self: {
        alerts: selfAlerts,
        capabilities: selfCaps,
        purl,
        score: selfScore
      },
      transitively: {
        alerts,
        capabilities,
        dependencyCount,
        func,
        lowest,
        score
      }
    } = data
    logger.logger.error(`Score report for "${requestedPurl}" ("${purl}"):\n`)
    logger.logger.log('# Complete Package Score')
    logger.logger.log('')
    if (dependencyCount) {
      logger.logger.log(
        `This is a Socket report for the package *"${purl}"* and its *${dependencyCount}* direct/transitive dependencies.`
      )
    } else {
      logger.logger.log(
        `This is a Socket report for the package *"${purl}"*. It has *no dependencies*.`
      )
    }
    logger.logger.log('')
    if (dependencyCount) {
      logger.logger.log(
        `It will show you the shallow score for just the package itself and a deep score for all the transitives combined. Additionally you can see which capabilities were found and the top alerts as well as a package that was responsible for it.`
      )
    } else {
      logger.logger.log(
        `It will show you the shallow score for the package itself, which capabilities were found, and its top alerts.`
      )
      logger.logger.log('')
      logger.logger.log(
        'Since it has no dependencies, the shallow score is also the deep score.'
      )
    }
    logger.logger.log('')
    if (dependencyCount) {
      // This doesn't make much sense if there are no dependencies. Better to omit it.
      logger.logger.log(
        'The report should give you a good insight into the status of this package.'
      )
      logger.logger.log('')
      logger.logger.log('## Package itself')
      logger.logger.log('')
      logger.logger.log(
        'Here are results for the package itself (excluding data from dependencies).'
      )
    } else {
      logger.logger.log('## Report')
      logger.logger.log('')
      logger.logger.log(
        'The report should give you a good insight into the status of this package.'
      )
    }
    logger.logger.log('')
    logger.logger.log('### Shallow Score')
    logger.logger.log('')
    logger.logger.log('This score is just for the package itself:')
    logger.logger.log('')
    logger.logger.log('- Overall: ' + selfScore.overall)
    logger.logger.log('- Maintenance: ' + selfScore.maintenance)
    logger.logger.log('- Quality: ' + selfScore.quality)
    logger.logger.log('- Supply Chain: ' + selfScore.supplyChain)
    logger.logger.log('- Vulnerability: ' + selfScore.vulnerability)
    logger.logger.log('- License: ' + selfScore.license)
    logger.logger.log('')
    logger.logger.log('### Capabilities')
    logger.logger.log('')
    if (selfCaps.length) {
      logger.logger.log(
        'These are the capabilities detected in the package itself:'
      )
      logger.logger.log('')
      selfCaps.forEach(cap => {
        logger.logger.log(`- ${cap}`)
      })
    } else {
      logger.logger.log('No capabilities were found in the package.')
    }
    logger.logger.log('')
    logger.logger.log('### Alerts for this package')
    logger.logger.log('')
    if (selfAlerts.length) {
      if (dependencyCount) {
        logger.logger.log('These are the alerts found for the package itself:')
      } else {
        logger.logger.log('These are the alerts found for this package:')
      }
      logger.logger.log('')
      logger.logger.log(
        mdTable(selfAlerts, ['severity', 'name'], ['Severity', 'Alert Name'])
      )
    } else {
      logger.logger.log('There are currently no alerts for this package.')
    }
    logger.logger.log('')
    if (dependencyCount) {
      logger.logger.log('## Transitive Package Results')
      logger.logger.log('')
      logger.logger.log(
        'Here are results for the package and its direct/transitive dependencies.'
      )
      logger.logger.log('')
      logger.logger.log('### Deep Score')
      logger.logger.log('')
      logger.logger.log(
        'This score represents the package and and its direct/transitive dependencies:'
      )
      logger.logger.log(
        `The function used to calculate the values in aggregate is: *"${func}"*`
      )
      logger.logger.log('')
      logger.logger.log('- Overall: ' + score.overall)
      logger.logger.log('- Maintenance: ' + score.maintenance)
      logger.logger.log('- Quality: ' + score.quality)
      logger.logger.log('- Supply Chain: ' + score.supplyChain)
      logger.logger.log('- Vulnerability: ' + score.vulnerability)
      logger.logger.log('- License: ' + score.license)
      logger.logger.log('')
      logger.logger.log('### Capabilities')
      logger.logger.log('')
      logger.logger.log(
        'These are the packages with the lowest recorded score. If there is more than one with the lowest score, just one is shown here. This may help you figure out the source of low scores.'
      )
      logger.logger.log('')
      logger.logger.log('- Overall: ' + lowest.overall)
      logger.logger.log('- Maintenance: ' + lowest.maintenance)
      logger.logger.log('- Quality: ' + lowest.quality)
      logger.logger.log('- Supply Chain: ' + lowest.supplyChain)
      logger.logger.log('- Vulnerability: ' + lowest.vulnerability)
      logger.logger.log('- License: ' + lowest.license)
      logger.logger.log('')
      logger.logger.log('### Capabilities')
      logger.logger.log('')
      if (capabilities.length) {
        logger.logger.log(
          'These are the capabilities detected in at least one package:'
        )
        logger.logger.log('')
        capabilities.forEach(cap => {
          logger.logger.log(`- ${cap}`)
        })
      } else {
        logger.logger.log(
          'This package had no capabilities and neither did any of its direct/transitive dependencies.'
        )
      }
      logger.logger.log('')
      logger.logger.log('### Alerts')
      logger.logger.log('')
      if (alerts.length) {
        logger.logger.log('These are the alerts found:')
        logger.logger.log('')
        logger.logger.log(
          mdTable(
            alerts,
            ['severity', 'name', 'example'],
            ['Severity', 'Alert Name', 'Example package reporting it']
          )
        )
      } else {
        logger.logger.log(
          'This package had no alerts and neither did any of its direct/transitive dependencies'
        )
      }
      logger.logger.log('')
    }
    return
  }
  logger.logger.log(
    `Score report for "${purl}" (use --json for raw and --markdown for formatted reports):`
  )
  logger.logger.log(data)
  logger.logger.log('')
}

async function handlePurlDeepScore(purl, outputKind) {
  const data = await fetchPurlDeepScore(purl)
  if (!data) {
    return
  }
  await outputPurlScore(purl, data, outputKind)
}

// Either an ecosystem was given or all args must be (namespaced) purls
// The `pkg:` part is optional here. We'll scan for `eco/name@version`.
// Not hardcoding the namespace since we don't know what the server accepts.
// The ecosystem is considered as the first package if it is not an a-z string.
function parsePackageSpecifiers(ecosystem, pkgs) {
  let valid = true
  const purls = []
  if (!ecosystem) {
    valid = false
  } else if (/^[a-zA-Z]+$/.test(ecosystem)) {
    for (let i = 0; i < pkgs.length; ++i) {
      const pkg = pkgs[i] ?? ''
      if (!pkg) {
        valid = false
        break
      } else if (pkg.startsWith('pkg:')) {
        // keep
        purls.push(pkg)
      } else {
        purls.push('pkg:' + ecosystem + '/' + pkg)
      }
    }
    if (!purls.length) {
      valid = false
    }
  } else {
    // Assume ecosystem is a purl, too
    pkgs.unshift(ecosystem)
    for (let i = 0; i < pkgs.length; ++i) {
      const pkg = pkgs[i] ?? ''
      if (!/^(?:pkg:)?[a-zA-Z]+\/./.test(pkg)) {
        // At least one purl did not start with `pkg:eco/x` or `eco/x`
        valid = false
        break
      } else if (pkg.startsWith('pkg:')) {
        purls.push(pkg)
      } else {
        purls.push('pkg:' + pkg)
      }
    }
    if (!purls.length) {
      valid = false
    }
  }
  return {
    purls,
    valid
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$h } = constants
const config$j = {
  commandName: 'score',
  description:
    '[beta] Look up score for one package which reflects all of its transitive dependencies as well',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <<ecosystem> <name> | <purl>>

    API Token Requirements
      - Quota: 100 units
      - Permissions: packages:list

    Options
      ${getFlagListOutput(config.flags, 6)}

    Show deep scoring details for one package. The score will reflect the package
    itself, any of its dependencies, and any of its transitive dependencies.

    When you want to know whether to trust a package, this is the command to run.

    See also the \`socket package shallow\` command, which returns the shallow
    score for any number of packages. That will not reflect the dependency scores.

    Only a few ecosystems are supported like npm, golang, and maven.

    A "purl" is a standard package name formatting: \`pkg:eco/name@version\`
    This command will automatically prepend "pkg:" when not present.

    The version is optional but when given should be a direct match.

    Examples
      $ ${command} npm babel-cli
      $ ${command} npm babel-cli@1.9.1
      $ ${command} npm/babel-cli@1.9.1
      $ ${command} pkg:npm/babel-cli@1.9.1
  `
}
const cmdPackageScore = {
  description: config$j.description,
  hidden: config$j.hidden,
  run: run$j
}
async function run$j(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$j,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [ecosystem = '', purl] = cli.input
  const apiToken = shadowNpmInject.getDefaultToken()
  const { purls, valid } = parsePackageSpecifiers(ecosystem, purl ? [purl] : [])
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: valid,
      message: 'First parameter must be an ecosystem or the whole purl',
      pass: 'ok',
      fail: 'bad'
    },
    {
      test: purls.length === 1,
      message: 'Expecting at least one package',
      pass: 'ok',
      fail: purls.length === 0 ? 'missing' : 'too many'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$h)
    return
  }
  await handlePurlDeepScore(purls[0] || '', outputKind)
}

async function fetchPurlsShallowScore(purls) {
  logger.logger.info(
    `Requesting shallow score data for ${purls.length} package urls (purl): ${purls.join(', ')}`
  )
  const sockSdk = await shadowNpmInject.setupSdk(
    shadowNpmInject.getPublicToken()
  )

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start(`Requesting data ...`)
  const result = await handleApiCall(
    sockSdk.batchPackageFetch(
      {
        alerts: 'true'
      },
      {
        components: purls.map(purl => ({
          purl
        }))
      }
    ),
    'looking up package'
  )
  spinner.successAndStop('Request completed')
  if (!result.success) {
    handleUnsuccessfulApiResponse('batchPackageFetch', result)
  }
  return result
}

function outputPurlsShallowScore(purls, packageData, outputKind) {
  if (outputKind === 'json') {
    // In JSON simply return what the server responds with. Don't bother trying
    // to match the response with the requested packages/purls.
    logger.logger.log(JSON.stringify(packageData, undefined, 2))
    return
  }

  // Make some effort to match the requested data with the response

  const set = new Set()
  packageData.forEach(data => {
    set.add('pkg:' + data.type + '/' + data.name + '@' + data.version)
    set.add('pkg:' + data.type + '/' + data.name)
  })
  const missing = purls.filter(purl => {
    if (set.has(purl)) {
      return false
    }
    if (purl.endsWith('@latest') && set.has(purl.slice(0, -'@latest'.length))) {
      return false
    }
    return true // not found
  })
  if (outputKind === 'markdown') {
    logger.logger.log(
      `
# Shallow Package Report

This report contains the response for requesting data on some package url(s).

Please note: The listed scores are ONLY for the package itself. It does NOT
             reflect the scores of any dependencies, transitive or otherwise.

${missing.length ? `\n## Missing response\n\nAt least one package had no response or the purl was not canonical:\n\n${missing.map(purl => '- ' + purl + '\n').join('')}` : ''}

${packageData.map(data => '## ' + formatReportCard(data, false)).join('\n\n\n')}
    `.trim()
    )
    return
  }
  logger.logger.log(
    '\n' + vendor.yoctocolorsCjsExports.bold('Shallow Package Score') + '\n'
  )
  logger.logger.log(
    'Please note: The listed scores are ONLY for the package itself. It does NOT\n' +
      '             reflect the scores of any dependencies, transitive or otherwise.'
  )
  if (missing.length) {
    logger.logger.log(
      `\nAt least one package had no response or the purl was not canonical:\n${missing.map(purl => '\n- ' + vendor.yoctocolorsCjsExports.bold(purl)).join('')}`
    )
  }
  packageData.forEach(data => {
    logger.logger.log('\n')
    logger.logger.log(formatReportCard(data, true))
  })
  logger.logger.log('')
}
function formatReportCard(data, color) {
  const scoreResult = {
    'Supply Chain Risk': Math.floor((data.score?.supplyChain ?? 0) * 100),
    Maintenance: Math.floor((data.score?.maintenance ?? 0) * 100),
    Quality: Math.floor((data.score?.quality ?? 0) * 100),
    Vulnerabilities: Math.floor((data.score?.vulnerability ?? 0) * 100),
    License: Math.floor((data.score?.license ?? 0) * 100)
  }
  const alertString = getAlertString(data.alerts, !color)
  const purl = 'pkg:' + data.type + '/' + data.name + '@' + data.version
  return [
    'Package: ' + (color ? vendor.yoctocolorsCjsExports.bold(purl) : purl),
    '',
    ...Object.entries(scoreResult).map(
      score =>
        `- ${score[0]}:`.padEnd(20, ' ') +
        `  ${formatScore(score[1], !color, true)}`
    ),
    alertString
  ].join('\n')
}
function formatScore(score, noColor = false, pad = false) {
  const padded = String(score).padStart(pad ? 3 : 0, ' ')
  if (noColor) {
    return padded
  }
  if (score >= 80) {
    return vendor.yoctocolorsCjsExports.green(padded)
  }
  if (score >= 60) {
    return vendor.yoctocolorsCjsExports.yellow(padded)
  }
  return vendor.yoctocolorsCjsExports.red(padded)
}
function getAlertString(alerts, noColor = false) {
  if (!alerts?.length) {
    return noColor
      ? `- Alerts: none!`
      : `- Alerts: ${vendor.yoctocolorsCjsExports.green('none')}!`
  }
  const bad = alerts
    .filter(alert => alert.severity !== 'low' && alert.severity !== 'middle')
    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))
  const mid = alerts
    .filter(alert => alert.severity === 'middle')
    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))
  const low = alerts
    .filter(alert => alert.severity === 'low')
    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))

  // We need to create the no-color string regardless because the actual string
  // contains a bunch of invisible ANSI chars which would screw up length checks.
  const colorless = `- Alerts (${bad.length}/${mid.length.toString()}/${low.length}):`
  if (noColor) {
    return (
      colorless +
      ' '.repeat(Math.max(0, 20 - colorless.length)) +
      '  ' +
      [
        bad.map(alert => `[${alert.severity}] ` + alert.type).join(', '),
        mid.map(alert => `[${alert.severity}] ` + alert.type).join(', '),
        low.map(alert => `[${alert.severity}] ` + alert.type).join(', ')
      ]
        .filter(Boolean)
        .join(', ')
    )
  }
  return (
    `- Alerts (${vendor.yoctocolorsCjsExports.red(bad.length.toString())}/${vendor.yoctocolorsCjsExports.yellow(mid.length.toString())}/${low.length}):` +
    ' '.repeat(Math.max(0, 20 - colorless.length)) +
    '  ' +
    [
      bad
        .map(alert =>
          vendor.yoctocolorsCjsExports.red(
            vendor.yoctocolorsCjsExports.dim(`[${alert.severity}] `) +
              alert.type
          )
        )
        .join(', '),
      mid
        .map(alert =>
          vendor.yoctocolorsCjsExports.yellow(
            vendor.yoctocolorsCjsExports.dim(`[${alert.severity}] `) +
              alert.type
          )
        )
        .join(', '),
      low
        .map(
          alert =>
            vendor.yoctocolorsCjsExports.dim(`[${alert.severity}] `) +
            alert.type
        )
        .join(', ')
    ]
      .filter(Boolean)
      .join(', ')
  )
}

async function handlePurlsShallowScore({ outputKind, purls }) {
  const packageData = await fetchPurlsShallowScore(purls)
  if (!packageData) {
    return
  }
  outputPurlsShallowScore(purls, packageData.data, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$g } = constants
const config$i = {
  commandName: 'shallow',
  description:
    '[beta] Look up info regarding one or more packages but not their transitives',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} <<ecosystem> <name> [<name> ...] | <purl> [<purl> ...]>

    API Token Requirements
      - Quota: 100 units
      - Permissions: packages:list

    Options
      ${getFlagListOutput(config.flags, 6)}

    Show scoring details for one or more packages purely based on their own package.
    This means that any dependency scores are not reflected by the score. You can
    use the \`socket package score <pkg>\` command to get its full transitive score.

    Only a few ecosystems are supported like npm, golang, and maven.

    A "purl" is a standard package name formatting: \`pkg:eco/name@version\`
    This command will automatically prepend "pkg:" when not present.

    If the first arg is an ecosystem, remaining args that are not a purl are
    assumed to be scoped to that ecosystem.

    Examples
      $ ${command} npm webtorrent
      $ ${command} npm webtorrent@1.9.1
      $ ${command} npm/webtorrent@1.9.1
      $ ${command} pkg:npm/webtorrent@1.9.1
      $ ${command} maven webtorrent babel
      $ ${command} npm/webtorrent golang/babel
      $ ${command} npm npm/webtorrent@1.0.1 babel
  `
}
const cmdPackageShallow = {
  description: config$i.description,
  hidden: config$i.hidden,
  alias: {
    shallowScore: {
      description: config$i.description,
      hidden: true,
      argv: []
    }
  },
  run: run$i
}
async function run$i(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$i,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [ecosystem = '', ...pkgs] = cli.input
  const { purls, valid } = parsePackageSpecifiers(ecosystem, pkgs)
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: valid,
      message:
        'First parameter should be an ecosystem or all args must be purls',
      pass: 'ok',
      fail: 'bad'
    },
    {
      test: purls.length > 0,
      message: 'Expecting at least one package',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$g)
    return
  }
  await handlePurlsShallowScore({
    outputKind,
    purls
  })
}

const description$3 = 'Commands relating to looking up published packages'
const cmdPackage = {
  description: description$3,
  hidden: false,
  async run(argv, importMeta, { parentName }) {
    await meowWithSubcommands(
      {
        score: cmdPackageScore,
        shallow: cmdPackageShallow
      },
      {
        aliases: {
          deep: {
            description: description$3,
            hidden: true,
            argv: ['score']
          }
        },
        argv,
        description: description$3,
        importMeta,
        name: parentName + ' package'
      }
    )
  }
}

async function runRawNpm(argv) {
  const spawnPromise = spawn.spawn(shadowNpmPaths.getNpmBinPath(), argv, {
    stdio: 'inherit'
  })
  // See https://nodejs.org/api/all.html#all_child_process_event-exit.
  spawnPromise.process.on('exit', (code, signalName) => {
    if (signalName) {
      process$1.kill(process$1.pid, signalName)
    } else if (code !== null) {
      // eslint-disable-next-line n/no-process-exit
      process$1.exit(code)
    }
  })
  await spawnPromise
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$f, NPM } = constants
const config$h = {
  commandName: 'raw-npm',
  description: `Temporarily disable the Socket ${NPM} wrapper`,
  hidden: false,
  flags: {},
  help: command => `
    Usage
      $ ${command} <command>

    Examples
      $ ${command} install
  `
}
const cmdRawNpm = {
  description: config$h.description,
  hidden: config$h.hidden,
  run: run$h
}
async function run$h(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    allowUnknownFlags: true,
    argv,
    config: config$h,
    importMeta,
    parentName
  })
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$f)
    return
  }
  await runRawNpm(argv)
}

async function runRawNpx(argv) {
  const spawnPromise = spawn.spawn(shadowNpmPaths.getNpxBinPath(), argv, {
    stdio: 'inherit'
  })
  // See https://nodejs.org/api/all.html#all_child_process_event-exit.
  spawnPromise.process.on('exit', (code, signalName) => {
    if (signalName) {
      process$1.kill(process$1.pid, signalName)
    } else if (code !== null) {
      // eslint-disable-next-line n/no-process-exit
      process$1.exit(code)
    }
  })
  await spawnPromise
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$e, NPX } = constants
const config$g = {
  commandName: 'raw-npx',
  description: `Temporarily disable the Socket ${NPX} wrapper`,
  hidden: false,
  flags: {},
  help: command => `
    Usage
      $ ${command} <command>

    Examples
      $ ${command} install
  `
}
const cmdRawNpx = {
  description: config$g.description,
  hidden: config$g.hidden,
  run: run$g
}
async function run$g(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    allowUnknownFlags: true,
    argv,
    config: config$g,
    importMeta,
    parentName
  })
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$e)
    return
  }
  await runRawNpx(argv)
}

const config$f = {
  commandName: 'create',
  description: '[Deprecated] Create a project report',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: () => `
    This command is deprecated in favor of \`socket scan view\`.
    It will be removed in the next major release of the CLI.
  `
}
const cmdReportCreate = {
  description: config$f.description,
  hidden: config$f.hidden,
  run: run$f
}
async function run$f(argv, importMeta, { parentName }) {
  meowOrExit({
    argv,
    config: config$f,
    importMeta,
    parentName
  })
  logger.logger.fail(
    'This command has been sunset. Instead, please look at `socket scan create` to create scans and `socket scan report` to view a report of your scans.'
  )
  process.exitCode = 1
}

const config$e = {
  commandName: 'view',
  description: '[Deprecated] View a project report',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags
  },
  help: () => `
    This command is deprecated in favor of \`socket scan view\`.
    It will be removed in the next major release of the CLI.
  `
}
const cmdReportView = {
  description: config$e.description,
  hidden: config$e.hidden,
  run: run$e
}
async function run$e(argv, importMeta, { parentName }) {
  meowOrExit({
    argv,
    config: config$e,
    importMeta,
    parentName
  })
  logger.logger.fail(
    'This command has been sunset. Instead, please look at `socket scan create` to create scans and `socket scan report` to view a report of your scans.'
  )
  process.exitCode = 1
}

const description$2 = '[Deprecated] Project report related commands'
const cmdReport = {
  description: description$2,
  hidden: true,
  // Deprecated in favor of `scan`
  async run(argv, importMeta, { parentName }) {
    await meowWithSubcommands(
      {
        create: cmdReportCreate,
        view: cmdReportView
      },
      {
        argv,
        description: description$2,
        importMeta,
        name: parentName + ' report'
      }
    )
  }
}

async function fetchCreateRepo({
  default_branch,
  description,
  homepage,
  orgSlug,
  repoName,
  visibility
}) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Sending request ot create a repository...')
  const result = await handleApiCall(
    sockSdk.createOrgRepo(orgSlug, {
      name: repoName,
      description,
      homepage,
      default_branch,
      visibility
    }),
    'creating repository'
  )
  spinner.successAndStop('Received response requesting to create a repository.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('createOrgRepo', result)
  }
  return result.data
}

async function outputCreateRepo(_data) {
  logger.logger.success('Repository created successfully')
}

async function handleCreateRepo({
  default_branch,
  description,
  homepage,
  orgSlug,
  repoName,
  visibility
}) {
  const data = await fetchCreateRepo({
    default_branch,
    description,
    homepage,
    orgSlug,
    repoName,
    visibility
  })
  if (!data) {
    return
  }
  await outputCreateRepo()
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$d } = constants
const config$d = {
  commandName: 'create',
  description: 'Create a repository in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    defaultBranch: {
      type: 'string',
      shortFlag: 'b',
      default: 'main',
      description: 'Repository default branch'
    },
    homepage: {
      type: 'string',
      shortFlag: 'h',
      default: '',
      description: 'Repository url'
    },
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    repoDescription: {
      type: 'string',
      shortFlag: 'd',
      default: '',
      description: 'Repository description'
    },
    repoName: {
      type: 'string',
      shortFlag: 'n',
      default: '',
      description: 'Repository name'
    },
    visibility: {
      type: 'string',
      shortFlag: 'v',
      default: 'private',
      description: 'Repository visibility (Default Private)'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} ${shadowNpmInject.isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: repo:create

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} ${shadowNpmInject.isTestingV1() ? 'test-repo' : 'FakeOrg --repoName=test-repo'}
  `
}
const cmdReposCreate = {
  description: config$d.description,
  hidden: config$d.hidden,
  run: run$d
}
async function run$d(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$d,
    importMeta,
    parentName
  })
  const {
    dryRun,
    interactive,
    json,
    markdown,
    org: orgFlag,
    repoName: repoNameFlag
  } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  const [orgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const repoName =
    (shadowNpmInject.isTestingV1() ? cli.input[0] : repoNameFlag) || ''
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      test: !!repoName,
      message: shadowNpmInject.isTestingV1()
        ? 'Repository name as first argument'
        : 'Repository name using --repoName',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    },
    {
      nook: true,
      test: !shadowNpmInject.isTestingV1() || !repoNameFlag,
      message: 'In v1 the first arg should be the repo, not the flag',
      pass: 'ok',
      fail: 'received --repo-name flag'
    }
  )
  if (wasBadInput) {
    return
  }
  if (dryRun) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$d)
    return
  }
  await handleCreateRepo({
    orgSlug,
    repoName: String(repoName),
    description: String(cli.flags['repoDescription'] || ''),
    homepage: String(cli.flags['homepage'] || ''),
    default_branch: String(cli.flags['defaultBranch'] || ''),
    visibility: String(cli.flags['visibility'] || 'private')
  })
}

async function handleDeleteRepo(orgSlug, repoName) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Deleting repository...')
  const result = await handleApiCall(
    sockSdk.deleteOrgRepo(orgSlug, repoName),
    'deleting repository'
  )
  if (!result.success) {
    handleUnsuccessfulApiResponse('deleteOrgRepo', result)
  }
  spinner.successAndStop('Repository deleted successfully')
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$c } = constants
const config$c = {
  commandName: 'del',
  description: 'Delete a repository in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} ${shadowNpmInject.isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: repo:delete

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} ${shadowNpmInject.isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}
  `
}
const cmdReposDel = {
  description: config$c.description,
  hidden: config$c.hidden,
  run: run$c
}
async function run$c(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$c,
    importMeta,
    parentName
  })
  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const repoName =
    (defaultOrgSlug || shadowNpmInject.isTestingV1()
      ? cli.input[0]
      : cli.input[1]) || ''
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      test: !!repoName,
      message: shadowNpmInject.isTestingV1()
        ? 'Repository name as first argument'
        : 'Repository name using --repoName',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (dryRun) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$c)
    return
  }
  await handleDeleteRepo(orgSlug, repoName)
}

async function fetchListRepos({ direction, orgSlug, page, per_page, sort }) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching list of repositories...')
  const result = await handleApiCall(
    sockSdk.getOrgRepoList(orgSlug, {
      sort,
      direction,
      per_page: String(per_page),
      page: String(page)
    }),
    'listing repositories'
  )
  spinner.successAndStop('Received response for repository list.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgRepoList', result)
  }
  return result.data
}

// @ts-ignore
async function outputListRepos(data, outputKind) {
  if (outputKind === 'json') {
    const json = data.results.map(o => ({
      id: o.id,
      name: o.name,
      visibility: o.visibility,
      defaultBranch: o.default_branch,
      archived: o.archived
    }))
    logger.logger.log(JSON.stringify(json, null, 2))
    return
  }
  const options = {
    columns: [
      {
        field: 'id',
        name: vendor.yoctocolorsCjsExports.magenta('ID')
      },
      {
        field: 'name',
        name: vendor.yoctocolorsCjsExports.magenta('Name')
      },
      {
        field: 'visibility',
        name: vendor.yoctocolorsCjsExports.magenta('Visibility')
      },
      {
        field: 'default_branch',
        name: vendor.yoctocolorsCjsExports.magenta('Default branch')
      },
      {
        field: 'archived',
        name: vendor.yoctocolorsCjsExports.magenta('Archived')
      }
    ]
  }
  logger.logger.log(vendor.srcExports(options, data.results))
}

async function handleListRepos({
  direction,
  orgSlug,
  outputKind,
  page,
  per_page,
  sort
}) {
  const data = await fetchListRepos({
    direction,
    orgSlug,
    page,
    per_page,
    sort
  })
  if (!data) {
    return
  }
  await outputListRepos(data, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$b } = constants
const config$b = {
  commandName: 'list',
  description: 'List repositories in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    sort: {
      type: 'string',
      shortFlag: 's',
      default: 'created_at',
      description: 'Sorting option'
    },
    direction: {
      type: 'string',
      default: 'desc',
      description: 'Direction option'
    },
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    perPage: {
      type: 'number',
      shortFlag: 'pp',
      default: 30,
      description: 'Number of results per page'
    },
    page: {
      type: 'number',
      shortFlag: 'p',
      default: 1,
      description: 'Page number'
    },
    ...outputFlags
  },
  help: (command, config) => `
    Usage
      $ ${command} ${shadowNpmInject.isTestingV1() ? '' : '<org slug>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: repo:list

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} ${shadowNpmInject.isTestingV1() ? '' : '<org slug>'}
  `
}
const cmdReposList = {
  description: config$b.description,
  hidden: config$b.hidden,
  run: run$b
}
async function run$b(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$b,
    importMeta,
    parentName
  })
  const { json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const { dryRun, interactive, org: orgFlag } = cli.flags
  const [orgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$b)
    return
  }
  await handleListRepos({
    direction: cli.flags['direction'] === 'asc' ? 'asc' : 'desc',
    orgSlug,
    outputKind,
    page: Number(cli.flags['page']) || 1,
    per_page: Number(cli.flags['perPage']) || 30,
    sort: String(cli.flags['sort'] || 'created_at')
  })
}

async function fetchUpdateRepo({
  default_branch,
  description,
  homepage,
  orgSlug,
  repoName,
  visibility
}) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Sending request to update a repository...')
  const result = await handleApiCall(
    sockSdk.updateOrgRepo(orgSlug, repoName, {
      orgSlug,
      name: repoName,
      description,
      homepage,
      default_branch,
      visibility
    }),
    'updating repository'
  )
  spinner.successAndStop('Received response trying to update a repository')
  if (!result.success) {
    handleUnsuccessfulApiResponse('updateOrgRepo', result)
  }
  return result.data
}

async function outputUpdateRepo(_data) {
  logger.logger.success('Repository updated successfully')
}

async function handleUpdateRepo({
  default_branch,
  description,
  homepage,
  orgSlug,
  repoName,
  visibility
}) {
  const data = await fetchUpdateRepo({
    default_branch,
    description,
    homepage,
    orgSlug,
    repoName,
    visibility
  })
  if (!data) {
    return
  }
  await outputUpdateRepo()
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$a } = constants
const config$a = {
  commandName: 'update',
  description: 'Update a repository in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    defaultBranch: {
      type: 'string',
      shortFlag: 'b',
      default: 'main',
      description: 'Repository default branch'
    },
    homepage: {
      type: 'string',
      shortFlag: 'h',
      default: '',
      description: 'Repository url'
    },
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    repoName: {
      type: 'string',
      shortFlag: 'n',
      default: '',
      description: 'Repository name'
    },
    repoDescription: {
      type: 'string',
      shortFlag: 'd',
      default: '',
      description: 'Repository description'
    },
    visibility: {
      type: 'string',
      shortFlag: 'v',
      default: 'private',
      description: 'Repository visibility (Default Private)'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} ${shadowNpmInject.isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: repo:update

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} ${shadowNpmInject.isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}
  `
}
const cmdReposUpdate = {
  description: config$a.description,
  hidden: config$a.hidden,
  run: run$a
}
async function run$a(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$a,
    importMeta,
    parentName
  })
  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  const [orgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const repoNameFlag = cli.flags['repoName']
  const repoName =
    (shadowNpmInject.isTestingV1() ? cli.input[0] : repoNameFlag) || ''
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      test: !!repoName,
      message: shadowNpmInject.isTestingV1()
        ? 'Repository name as first argument'
        : 'Repository name using --repoName',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    },
    {
      nook: true,
      test: !shadowNpmInject.isTestingV1() || !repoNameFlag,
      message: 'In v1 the first arg should be the repo, not the flag',
      pass: 'ok',
      fail: 'received --repo-name flag'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$a)
    return
  }
  await handleUpdateRepo({
    orgSlug,
    repoName: String(repoName),
    description: String(cli.flags['repoDescription'] || ''),
    homepage: String(cli.flags['homepage'] || ''),
    default_branch: String(cli.flags['defaultBranch'] || ''),
    visibility: String(cli.flags['visibility'] || 'private')
  })
}

async function fetchViewRepo(orgSlug, repoName) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching repository data...')
  const result = await handleApiCall(
    sockSdk.getOrgRepo(orgSlug, repoName),
    'fetching repository'
  )
  spinner.successAndStop('Received response while fetched repository data.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgRepo', result)
  }
  return result.data
}

// @ts-ignore
async function outputViewRepo(data, outputKind) {
  if (outputKind === 'json') {
    const {
      archived,
      created_at,
      default_branch,
      homepage,
      id,
      name,
      visibility
    } = data
    logger.logger.log(
      JSON.stringify(
        {
          id,
          name,
          visibility,
          default_branch,
          homepage,
          archived,
          created_at
        },
        null,
        2
      )
    )
    return
  }
  const options = {
    columns: [
      {
        field: 'id',
        name: vendor.yoctocolorsCjsExports.magenta('ID')
      },
      {
        field: 'name',
        name: vendor.yoctocolorsCjsExports.magenta('Name')
      },
      {
        field: 'visibility',
        name: vendor.yoctocolorsCjsExports.magenta('Visibility')
      },
      {
        field: 'default_branch',
        name: vendor.yoctocolorsCjsExports.magenta('Default branch')
      },
      {
        field: 'homepage',
        name: vendor.yoctocolorsCjsExports.magenta('Homepage')
      },
      {
        field: 'archived',
        name: vendor.yoctocolorsCjsExports.magenta('Archived')
      },
      {
        field: 'created_at',
        name: vendor.yoctocolorsCjsExports.magenta('Created at')
      }
    ]
  }
  logger.logger.log(vendor.srcExports(options, [data]))
}

async function handleViewRepo(orgSlug, repoName, outputKind) {
  const data = await fetchViewRepo(orgSlug, repoName)
  if (!data) {
    return
  }
  await outputViewRepo(data, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$9 } = constants
const config$9 = {
  commandName: 'view',
  description: 'View repositories in an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    repoName: {
      description: 'The repository to check',
      default: '',
      type: 'string'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} ${shadowNpmInject.isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: repo:list

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} ${shadowNpmInject.isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}
  `
}
const cmdReposView = {
  description: config$9.description,
  hidden: config$9.hidden,
  run: run$9
}
async function run$9(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$9,
    importMeta,
    parentName
  })
  const {
    dryRun,
    interactive,
    json,
    markdown,
    org: orgFlag,
    repoName: repoNameFlag
  } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [orgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const repoName =
    (shadowNpmInject.isTestingV1() ? cli.input[0] : repoNameFlag) || ''
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      test: !!repoName,
      message: shadowNpmInject.isTestingV1()
        ? 'Repository name as first argument'
        : 'Repository name using --repoName',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    },
    {
      nook: true,
      test: !shadowNpmInject.isTestingV1() || !repoNameFlag,
      message: 'In v1 the first arg should be the repo, not the flag',
      pass: 'ok',
      fail: 'received --repo-name flag'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$9)
    return
  }
  await handleViewRepo(orgSlug, String(repoName), outputKind)
}

const description$1 = 'Repositories related commands'
const cmdRepos = {
  description: description$1,
  async run(argv, importMeta, { parentName }) {
    await meowWithSubcommands(
      {
        create: cmdReposCreate,
        view: cmdReposView,
        list: cmdReposList,
        del: cmdReposDel,
        update: cmdReposUpdate
      },
      {
        argv,
        description: description$1,
        importMeta,
        name: `${parentName} repos`
      }
    )
  }
}

async function suggestTarget() {
  // We could prefill this with sub-dirs of the current
  // dir ... but is that going to be useful?
  const proceed = await prompts.select({
    message: 'No TARGET given. Do you want to use the current directory?',
    choices: [
      {
        name: 'Yes',
        value: true,
        description: 'Target the current directory'
      },
      {
        name: 'No',
        value: false,
        description:
          'Do not use the current directory (this will end in a no-op)'
      }
    ]
  })
  if (proceed) {
    return ['.']
  }
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$8 } = constants
const config$8 = {
  commandName: 'create',
  description: 'Create a scan',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    branch: {
      type: 'string',
      shortFlag: 'b',
      default: 'socket-default-branch',
      description: 'Branch name'
    },
    commitMessage: {
      type: 'string',
      shortFlag: 'm',
      default: '',
      description: 'Commit message'
    },
    commitHash: {
      type: 'string',
      shortFlag: 'ch',
      default: '',
      description: 'Commit hash'
    },
    committers: {
      type: 'string',
      shortFlag: 'c',
      default: '',
      description: 'Committers'
    },
    cwd: {
      type: 'string',
      description: 'working directory, defaults to process.cwd()'
    },
    defaultBranch: {
      type: 'boolean',
      default: false,
      description:
        'Set the default branch of the repository to the branch of this full-scan. Should only need to be done once, for example for the "main" or "master" branch.'
    },
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    pendingHead: {
      type: 'boolean',
      default: true,
      description:
        'Designate this full-scan as the latest scan of a given branch. This must be set to have it show up in the dashboard.'
    },
    pullRequest: {
      type: 'number',
      shortFlag: 'pr',
      description: 'Commit hash'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    readOnly: {
      type: 'boolean',
      default: false,
      description:
        'Similar to --dry-run except it can read from remote, stops before it would create an actual report'
    },
    repo: {
      type: 'string',
      shortFlag: 'r',
      default: 'socket-default-repository',
      description: 'Repository name'
    },
    report: {
      type: 'boolean',
      default: false,
      description:
        'Wait for the scan creation to complete, then basically run `socket scan report` on it'
    },
    tmp: {
      type: 'boolean',
      shortFlag: 't',
      default: false,
      description:
        'Set the visibility (true/false) of the scan in your dashboard. Can not be used when --pendingHead is set.'
    }
  },
  // TODO: your project's "socket.yml" file's "projectIgnorePaths"
  help: (command, config) => `
    Usage
      $ ${command} [...options]${shadowNpmInject.isTestingV1() ? '' : ' <org>'} <TARGET> [TARGET...]

    API Token Requirements
      - Quota: 1 unit
      - Permissions: full-scans:create

    Uploads the specified "package.json" and lock files for JavaScript, Python,
    Go, Scala, Gradle, and Kotlin dependency manifests.
    If any folder is specified, the ones found in there recursively are uploaded.

    Supports globbing such as "**/package.json", "**/requirements.txt", etc.

    Ignores any file specified in your project's ".gitignore" and also has a
    sensible set of default ignores from the "ignore-by-default" module.

    TARGET should be a FILE or DIR that _must_ be inside the CWD.

    When a FILE is given only that FILE is targeted. Otherwise any eligible
    files in the given DIR will be considered.

    The --repo and --branch flags tell Socket to associate this Scan with that
    repo/branch. The names will show up on your dashboard on the Socket website.

    Note: for a first run you probably want to set --defaultBranch to indicate
          the default branch name, like "main" or "master".

    Note: --pendingHead is enabled by default and makes a scan show up in your
          dashboard. You can use \`--no-pendingHead\` to have it not show up.

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} .
      $ ${command} --repo=test-repo --branch=main${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} ./package.json
  `
}
const cmdScanCreate = {
  description: config$8.description,
  hidden: config$8.hidden,
  run: run$8
}
async function run$8(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$8,
    importMeta,
    parentName
  })
  const {
    branch: branchName = 'socket-default-branch',
    commitHash,
    commitMessage,
    committers,
    cwd: cwdOverride,
    defaultBranch,
    dryRun = false,
    interactive = true,
    json,
    markdown,
    org: orgFlag,
    pendingHead,
    pullRequest,
    readOnly,
    repo: repoName = 'socket-default-repository',
    report,
    tmp
  } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  let [orgSlug, defaultOrgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    interactive,
    dryRun
  )
  if (!defaultOrgSlug) {
    // Tmp. just for TS. will drop this later.
    defaultOrgSlug = ''
  }
  let targets = cli.input.slice(
    shadowNpmInject.isTestingV1() || defaultOrgSlug ? 0 : 1
  )
  const cwd =
    cwdOverride && cwdOverride !== 'process.cwd()'
      ? String(cwdOverride)
      : process.cwd()

  // We're going to need an api token to suggest data because those suggestions
  // must come from data we already know. Don't error on missing api token yet.
  // If the api-token is not set, ignore it for the sake of suggestions.
  const apiToken = shadowNpmInject.getDefaultToken()

  // If we updated any inputs then we should print the command line to repeat
  // the command without requiring user input, as a suggestion.
  let updatedInput = false
  if (!targets.length && !dryRun && interactive) {
    const received = await suggestTarget()
    targets = received ?? []
    updatedInput = true
  }

  // If the current cwd is unknown and is used as a repo slug anyways, we will
  // first need to register the slug before we can use it.
  // Only do suggestions with an apiToken and when not in dryRun mode
  if (apiToken && !dryRun && interactive) {
    if (!orgSlug) {
      const suggestion = await suggestOrgSlug()
      if (suggestion) {
        orgSlug = suggestion
      }
      updatedInput = true
    }
  }
  if (updatedInput && orgSlug && targets?.length) {
    logger.logger.error(
      'Note: You can invoke this command next time to skip the interactive questions:'
    )
    logger.logger.error('```')
    logger.logger.error(
      `    socket scan create [other flags...] ${defaultOrgSlug ? '' : orgSlug} ${targets.join(' ')}`
    )
    logger.logger.error('```\n')
  }
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: !shadowNpmInject.isTestingV1() && !!defaultOrgSlug,
      test: !!orgSlug && orgSlug !== '.',
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail:
        orgSlug === '.'
          ? 'dot is an invalid org, most likely you forgot the org name here?'
          : 'missing'
    },
    {
      test: !!targets.length,
      message: 'At least one TARGET (e.g. `.` or `./package.json`)',
      pass: 'ok',
      fail: 'missing (or perhaps you forgot the org slug?)'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message: 'This command requires an API token for access',
      pass: 'ok',
      fail: 'missing (try `socket login`)'
    },
    {
      nook: true,
      test: !pendingHead || !tmp,
      message: 'Can not use --pendingHead and --tmp at the same time',
      pass: 'ok',
      fail: 'remove at least one flag'
    },
    {
      nook: true,
      test: !pendingHead || !!branchName,
      message: 'When --pendingHead is set, --branch is mandatory',
      pass: 'ok',
      fail: 'missing branch name'
    },
    {
      nook: true,
      test: !defaultBranch || !!branchName,
      message: 'When --defaultBranch is set, --branch is mandatory',
      pass: 'ok',
      fail: 'missing branch name'
    }
  )
  if (wasBadInput) {
    return
  }

  // Note exiting earlier to skirt a hidden auth requirement
  if (dryRun) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$8)
    return
  }
  await handleCreateNewScan({
    branchName: branchName,
    commitHash: (commitHash && String(commitHash)) || '',
    commitMessage: (commitMessage && String(commitMessage)) || '',
    committers: (committers && String(committers)) || '',
    cwd,
    defaultBranch: Boolean(defaultBranch),
    interactive: Boolean(interactive),
    orgSlug,
    outputKind,
    pendingHead: Boolean(pendingHead),
    pullRequest: Number(pullRequest),
    readOnly: Boolean(readOnly),
    repoName: repoName,
    report,
    targets,
    tmp: Boolean(tmp)
  })
}

async function fetchDeleteOrgFullScan(orgSlug, scanId) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Requesting the scan to be deleted...')
  const result = await handleApiCall(
    sockSdk.deleteOrgFullScan(orgSlug, scanId),
    'Deleting scan'
  )
  spinner.successAndStop('Received response for deleting a scan.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('deleteOrgFullScan', result)
  }
  return result.data
}

async function outputDeleteScan(_data) {
  logger.logger.success('Scan deleted successfully')
}

async function handleDeleteScan(orgSlug, scanId) {
  const data = await fetchDeleteOrgFullScan(orgSlug, scanId)
  if (!data) {
    return
  }
  await outputDeleteScan()
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$7 } = constants
const config$7 = {
  commandName: 'del',
  description: 'Delete a scan',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'} <scan ID>

    API Token Requirements
      - Quota: 1 unit
      - Permissions: full-scans:delete

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0
  `
}
const cmdScanDel = {
  description: config$7.description,
  hidden: config$7.hidden,
  run: run$7
}
async function run$7(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$7,
    importMeta,
    parentName
  })
  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const scanId =
    (shadowNpmInject.isTestingV1() || defaultOrgSlug
      ? cli.input[0]
      : cli.input[1]) || ''
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: !!defaultOrgSlug,
      test: !!orgSlug && orgSlug !== '.',
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail:
        orgSlug === '.'
          ? 'dot is an invalid org, most likely you forgot the org name here?'
          : 'missing'
    },
    {
      test: !!scanId,
      message: 'Scan ID to delete',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$7)
    return
  }
  await handleDeleteScan(orgSlug, scanId)
}

async function fetchDiffScan({ id1, id2, orgSlug }) {
  const apiToken = shadowNpmInject.getDefaultToken()

  // Lazily access constants.spinner.
  const { spinner } = constants
  logger.logger.error('Scan ID 1:', id1)
  logger.logger.error('Scan ID 2:', id2)
  spinner.start('Fetching scan diff... (this may take a while)')
  const response = await queryApi(
    `orgs/${orgSlug}/full-scans/diff?before=${encodeURIComponent(id1)}&after=${encodeURIComponent(id2)}`,
    apiToken || ''
  )
  spinner.successAndStop('Received scan diff response')
  if (!response.ok) {
    const err = await handleApiError(response.status)
    logger.logger.fail(failMsgWithBadge(response.statusText, err))
    return
  }
  const result = await handleApiCall(
    await response.json(),
    'Deserializing json'
  )
  return result
}

const SOCKET_SBOM_URL_PREFIX$1 =
  'https://socket.dev/dashboard/org/SocketDev/sbom/'
async function outputDiffScan(result, { depth, file, outputKind }) {
  const dashboardUrl = result.diff_report_url
  const dashboardMessage = dashboardUrl
    ? `\n View this diff scan in the Socket dashboard: ${vendor.yoctocolorsCjsExports.cyan(dashboardUrl)}`
    : ''

  // When forcing json, or dumping to file, serialize to string such that it
  // won't get truncated. The only way to dump the full raw JSON to stdout is
  // to use `--json --file -` (the dash is a standard notation for stdout)
  if (outputKind === 'json' || file) {
    let json
    try {
      json = JSON.stringify(result, null, 2)
    } catch (e) {
      process.exitCode = 1
      // Most likely caused by a circular reference (or OOM)
      logger.logger.fail('There was a problem converting the data to JSON')
      logger.logger.error(e)
      return
    }
    if (file && file !== '-') {
      logger.logger.log(`Writing json to \`${file}\``)
      fs$1.writeFile(file, JSON.stringify(result, null, 2), err => {
        if (err) {
          logger.logger.fail(`Writing to \`${file}\` failed...`)
          logger.logger.error(err)
        } else {
          logger.logger.log(`Data successfully written to \`${file}\``)
        }
        logger.logger.error(dashboardMessage)
      })
    } else {
      // TODO: expose different method for writing to stderr when simply dodging stdout
      logger.logger.error(`\n Diff scan result: \n`)
      logger.logger.log(json)
      logger.logger.error(dashboardMessage)
    }
    return
  }
  if (outputKind === 'markdown') {
    logger.logger.log('# Scan diff result')
    logger.logger.log('')
    logger.logger.log(
      'This Socket.dev report shows the changes between two scans:'
    )
    logger.logger.log(
      `- [${result.before.id}](${SOCKET_SBOM_URL_PREFIX$1}${result.before.id})`
    )
    logger.logger.log(
      `- [${result.after.id}](${SOCKET_SBOM_URL_PREFIX$1}${result.after.id})`
    )
    logger.logger.log('')
    logger.logger.log(
      `You can [view this report in your dashboard](${result.diff_report_url})`
    )
    logger.logger.log('')
    logger.logger.log('## Changes')
    logger.logger.log('')
    logger.logger.log(
      `- directDependenciesChanged: ${result.directDependenciesChanged}`
    )
    logger.logger.log(`- Added packages: ${result.artifacts.added.length}`)
    if (result.artifacts.added.length > 0) {
      result.artifacts.added.slice(0, 10).forEach(artifact => {
        logger.logger.log(
          `  - ${artifact.type} ${artifact.name}@${artifact.version}`
        )
      })
      if (result.artifacts.added.length > 10) {
        logger.logger.log(
          `  ... and ${result.artifacts.added.length - 10} more`
        )
      }
    }
    logger.logger.log(`- Removed packages: ${result.artifacts.removed.length}`)
    if (result.artifacts.removed.length > 0) {
      result.artifacts.removed.slice(0, 10).forEach(artifact => {
        logger.logger.log(
          `  - ${artifact.type} ${artifact.name}@${artifact.version}`
        )
      })
      if (result.artifacts.removed.length > 10) {
        logger.logger.log(
          `  ... and ${result.artifacts.removed.length - 10} more`
        )
      }
    }
    logger.logger.log(
      `- Replaced packages: ${result.artifacts.replaced.length}`
    )
    if (result.artifacts.replaced.length > 0) {
      result.artifacts.replaced.slice(0, 10).forEach(artifact => {
        logger.logger.log(
          `  - ${artifact.type} ${artifact.name}@${artifact.version}`
        )
      })
      if (result.artifacts.replaced.length > 10) {
        logger.logger.log(
          `  ... and ${result.artifacts.replaced.length - 10} more`
        )
      }
    }
    logger.logger.log(`- Updated packages: ${result.artifacts.updated.length}`)
    if (result.artifacts.updated.length > 0) {
      result.artifacts.updated.slice(0, 10).forEach(artifact => {
        logger.logger.log(
          `  - ${artifact.type} ${artifact.name}@${artifact.version}`
        )
      })
      if (result.artifacts.updated.length > 10) {
        logger.logger.log(
          `  ... and ${result.artifacts.updated.length - 10} more`
        )
      }
    }
    logger.logger.log(
      `- Unchanged packages: ${result.artifacts.unchanged.length}`
    )
    if (result.artifacts.unchanged.length > 0) {
      result.artifacts.unchanged.slice(0, 10).forEach(artifact => {
        logger.logger.log(
          `  - ${artifact.type} ${artifact.name}@${artifact.version}`
        )
      })
      if (result.artifacts.unchanged.length > 10) {
        logger.logger.log(
          `  ... and ${result.artifacts.unchanged.length - 10} more`
        )
      }
    }
    logger.logger.log('')
    logger.logger.log(`## Scan ${result.before.id}`)
    logger.logger.log('')
    logger.logger.log(
      'This Scan was considered to be the "base" / "from" / "before" Scan.'
    )
    logger.logger.log('')
    for (const [key, value] of Object.entries(result.before)) {
      if (key === 'pull_request' && !value) {
        continue
      }
      if (!['id', 'organization_id', 'repository_id'].includes(key)) {
        logger.logger.group(
          `- ${key === 'repository_slug' ? 'repo' : key === 'organization_slug' ? 'org' : key}: ${value}`
        )
        logger.logger.groupEnd()
      }
    }
    logger.logger.log('')
    logger.logger.log(`## Scan ${result.after.id}`)
    logger.logger.log('')
    logger.logger.log(
      'This Scan was considered to be the "head" / "to" / "after" Scan.'
    )
    logger.logger.log('')
    for (const [key, value] of Object.entries(result.after)) {
      if (key === 'pull_request' && !value) {
        continue
      }
      if (!['id', 'organization_id', 'repository_id'].includes(key)) {
        logger.logger.group(
          `- ${key === 'repository_slug' ? 'repo' : key === 'organization_slug' ? 'org' : key}: ${value}`
        )
        logger.logger.groupEnd()
      }
    }
    logger.logger.log('')
    return
  }

  // In this case neither the --json nor the --file flag was passed
  // Dump the JSON to CLI and let NodeJS deal with truncation

  logger.logger.log('Diff scan result:')
  logger.logger.log(
    util.inspect(result, {
      showHidden: false,
      depth: depth > 0 ? depth : null,
      colors: true,
      maxArrayLength: null
    })
  )
  logger.logger.error(
    `\n  To display the detailed report in the terminal, use the --json flag. For a friendlier report, use the --markdown flag.\n`
  )
  logger.logger.log(dashboardMessage)
}

async function handleDiffScan({ depth, file, id1, id2, orgSlug, outputKind }) {
  const data = await fetchDiffScan({
    id1,
    id2,
    orgSlug
  })
  if (!data) {
    return
  }
  await outputDiffScan(data, {
    depth,
    file,
    outputKind
  })
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$6 } = constants
const SOCKET_SBOM_URL_PREFIX =
  'https://socket.dev/dashboard/org/SocketDev/sbom/'
const config$6 = {
  commandName: 'diff',
  description: 'See what changed between two Scans',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    depth: {
      type: 'number',
      default: 2,
      description:
        'Max depth of JSON to display before truncating, use zero for no limit (without --json/--file)'
    },
    file: {
      type: 'string',
      shortFlag: 'f',
      default: '',
      description:
        'Path to a local file where the output should be saved. Use `-` to force stdout.'
    },
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'} <ID1> <ID2>

    API Token Requirements
      - Quota: 1 unit
      - Permissions: full-scans:list

    This command displays the package changes between two scans. The full output
    can be pretty large depending on the size of your repo and time range. It is
    best stored to disk (with --json) to be further analyzed by other tools.

    Note: First Scan ID is assumed to be the older ID. This is only relevant for
          the added/removed list (similar to diffing two files with git).

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 aaa1aa1a-aaaa-1111-1a1a-1111111a11a1
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 aaa1aa1a-aaaa-1111-1a1a-1111111a11a1 --json
  `
}
const cmdScanDiff = {
  description: config$6.description,
  hidden: config$6.hidden,
  run: run$6
}
async function run$6(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$6,
    importMeta,
    parentName
  })
  const {
    depth,
    dryRun,
    file,
    interactive,
    json,
    markdown,
    org: orgFlag
  } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  let id1 = cli.input[defaultOrgSlug ? 0 : 1] || ''
  let id2 = cli.input[defaultOrgSlug ? 1 : 2] || ''
  if (id1.startsWith(SOCKET_SBOM_URL_PREFIX)) {
    id1 = id1.slice(SOCKET_SBOM_URL_PREFIX.length)
  }
  if (id2.startsWith(SOCKET_SBOM_URL_PREFIX)) {
    id2 = id2.slice(SOCKET_SBOM_URL_PREFIX.length)
  }
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: !!(id1 && id2),
      message:
        'Specify two Scan IDs.\nA Scan ID looks like `aaa0aa0a-aaaa-0000-0a0a-0000000a00a0`.',
      pass: 'ok',
      fail:
        !id1 && !id2
          ? 'missing both Scan IDs'
          : !id2
            ? 'missing second Scan ID'
            : 'missing first Scan ID' // Not sure how this can happen but ok.
    },
    {
      test: !!orgSlug,
      nook: true,
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$6)
    return
  }
  await handleDiffScan({
    id1: String(id1 || ''),
    id2: String(id2 || ''),
    depth: Number(depth),
    orgSlug,
    outputKind,
    file: String(file || '')
  })
}

async function fetchListScans({
  branch,
  direction,
  from_time,
  orgSlug,
  page,
  per_page,
  repo,
  sort
}) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching list of scans...')
  const result = await handleApiCall(
    sockSdk.getOrgFullScanList(orgSlug, {
      ...(branch
        ? {
            branch
          }
        : {}),
      ...(repo
        ? {
            repo
          }
        : {}),
      sort,
      direction,
      per_page: String(per_page),
      page: String(page),
      from: from_time
    }),
    'Listing scans'
  )
  spinner.successAndStop(`Received response for list of scans.`)
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgFullScanList', result)
  }
  return result.data
}

// @ts-ignore
async function outputListScans(data, outputKind) {
  if (outputKind === 'json') {
    logger.logger.log(data)
    return
  }
  const options = {
    columns: [
      {
        field: 'id',
        name: vendor.yoctocolorsCjsExports.magenta('ID')
      },
      {
        field: 'report_url',
        name: vendor.yoctocolorsCjsExports.magenta('Scan URL')
      },
      {
        field: 'repo',
        name: vendor.yoctocolorsCjsExports.magenta('Repo')
      },
      {
        field: 'branch',
        name: vendor.yoctocolorsCjsExports.magenta('Branch')
      },
      {
        field: 'created_at',
        name: vendor.yoctocolorsCjsExports.magenta('Created at')
      }
    ]
  }
  const formattedResults = data.results.map(d => {
    return {
      id: d.id,
      report_url: vendor.yoctocolorsCjsExports.underline(
        `${d.html_report_url}`
      ),
      created_at: d.created_at
        ? new Date(d.created_at).toLocaleDateString('en-us', {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric'
          })
        : '',
      repo: d.repo,
      branch: d.branch
    }
  })
  logger.logger.log(vendor.srcExports(options, formattedResults))
}

async function handleListScans({
  branch,
  direction,
  from_time,
  orgSlug,
  outputKind,
  page,
  per_page,
  repo,
  sort
}) {
  const data = await fetchListScans({
    branch,
    direction,
    from_time,
    orgSlug,
    page,
    per_page,
    repo,
    sort
  })
  if (!data) {
    return
  }
  await outputListScans(data, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$5 } = constants
const config$5 = {
  commandName: 'list',
  description: 'List the scans for an organization',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    branch: {
      type: 'string',
      description: 'Filter to show only scans with this branch name'
    },
    direction: {
      type: 'string',
      shortFlag: 'd',
      default: 'desc',
      description: 'Direction option (`desc` or `asc`) - Default is `desc`'
    },
    fromTime: {
      type: 'string',
      shortFlag: 'f',
      default: '',
      description: 'From time - as a unix timestamp'
    },
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    page: {
      type: 'number',
      shortFlag: 'p',
      default: 1,
      description: 'Page number - Default is 1'
    },
    perPage: {
      type: 'number',
      shortFlag: 'pp',
      default: 30,
      description: 'Results per page - Default is 30'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    repo: {
      type: 'string',
      description: 'Filter to show only scans with this repository name'
    },
    sort: {
      type: 'string',
      shortFlag: 's',
      default: 'created_at',
      description:
        'Sorting option (`name` or `created_at`) - default is `created_at`'
    },
    untilTime: {
      type: 'string',
      shortFlag: 'u',
      default: '',
      description: 'Until time - as a unix timestamp'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: full-scans:list

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'}
  `
}
const cmdScanList = {
  description: config$5.description,
  hidden: config$5.hidden,
  run: run$5
}
async function run$5(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$5,
    importMeta,
    parentName
  })
  const {
    branch,
    dryRun,
    interactive,
    json,
    markdown,
    org: orgFlag,
    repo
  } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: !!defaultOrgSlug,
      test: !!orgSlug && orgSlug !== '.',
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail:
        orgSlug === '.'
          ? 'dot is an invalid org, most likely you forgot the org name here?'
          : 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$5)
    return
  }
  await handleListScans({
    branch: branch ? String(branch) : '',
    direction: String(cli.flags['direction'] || ''),
    from_time: String(cli.flags['fromTime'] || ''),
    orgSlug,
    outputKind,
    page: Number(cli.flags['page'] || 1),
    per_page: Number(cli.flags['perPage'] || 30),
    repo: repo ? String(repo) : '',
    sort: String(cli.flags['sort'] || '')
  })
}

async function fetchScanMetadata(orgSlug, scanId) {
  const sockSdk = await shadowNpmInject.setupSdk()

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching meta data for a full scan...')
  const result = await handleApiCall(
    sockSdk.getOrgFullScanMetadata(orgSlug, scanId),
    'Listing scans'
  )
  spinner.successAndStop('Received response for scan meta data.')
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgFullScanMetadata', result)
  }
  return result.data
}

async function outputScanMetadata(data, scanId, outputKind) {
  if (outputKind === 'json') {
    logger.logger.log(data)
  } else {
    // Markdown = print
    if (outputKind === 'markdown') {
      logger.logger.log('# Scan meta data\n')
    }
    logger.logger.log(`Scan ID: ${scanId}\n`)
    for (const [key, value] of Object.entries(data)) {
      if (
        [
          'id',
          'updated_at',
          'organization_id',
          'repository_id',
          'commit_hash',
          'html_report_url'
        ].includes(key)
      ) {
        continue
      }
      logger.logger.log(`- ${key}:`, value)
    }
    if (outputKind === 'markdown') {
      logger.logger.log(
        `\nYou can view this report at: [${data.html_report_url}](${data.html_report_url})\n`
      )
    } else {
      logger.logger.log(
        `\nYou can view this report at: ${data.html_report_url}]\n`
      )
    }
  }
}

async function handleOrgScanMetadata(orgSlug, scanId, outputKind) {
  const data = await fetchScanMetadata(orgSlug, scanId)
  if (!data) {
    return
  }
  await outputScanMetadata(data, scanId, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$4 } = constants
const config$4 = {
  commandName: 'metadata',
  description: "Get a scan's metadata",
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'} <scan ID>

    API Token Requirements
      - Quota: 1 unit
      - Permissions: full-scans:list

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0
  `
}
const cmdScanMetadata = {
  description: config$4.description,
  hidden: config$4.hidden,
  run: run$4
}
async function run$4(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$4,
    importMeta,
    parentName
  })
  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const scanId =
    (shadowNpmInject.isTestingV1() || defaultOrgSlug
      ? cli.input[0]
      : cli.input[1]) || ''
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: !!defaultOrgSlug,
      test: !!orgSlug && orgSlug !== '.',
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail:
        orgSlug === '.'
          ? 'dot is an invalid org, most likely you forgot the org name here?'
          : 'missing'
    },
    {
      test: !!scanId,
      message: 'Scan ID to inspect as argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$4)
    return
  }
  await handleOrgScanMetadata(orgSlug, scanId, outputKind)
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$3 } = constants
const config$3 = {
  commandName: 'report',
  description:
    'Check whether a scan result passes the organizational policies (security, license)',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    fold: {
      type: 'string',
      default: 'none',
      description: 'Fold reported alerts to some degree'
    },
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    reportLevel: {
      type: 'string',
      default: 'warn',
      description: 'Which policy level alerts should be reported'
    },
    short: {
      type: 'boolean',
      default: false,
      description: 'Report only the healthy status'
    },
    license: {
      type: 'boolean',
      default: false,
      description: 'Also report the license policy status. Default: false'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'} <scan ID> [path to output file]

    API Token Requirements
      - Quota: 2 units
      - Permissions: full-scans:list security-policy:read

    Options
      ${getFlagListOutput(config.flags, 6)}

    By default the result is a nested object that looks like this:
      \`{[ecosystem]: {[pkgName]: {[version]: {[file]: {[type:loc]: policy}}}}\`
    You can fold this up to given level: 'pkg', 'version', 'file', and 'none'.

    By default only the warn and error policy level alerts are reported. You can
    override this and request more ('defer' < 'ignore' < 'monitor' < 'warn' < 'error')

    Short responses: JSON: \`{healthy:bool}\`, markdown: \`healthy = bool\`, text: \`OK/ERR\`

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 --json --fold=version
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 --license --markdown --short
  `
}
const cmdScanReport = {
  description: config$3.description,
  hidden: config$3.hidden,
  run: run$3
}
async function run$3(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$3,
    importMeta,
    parentName
  })
  const {
    fold = 'none',
    json,
    license,
    markdown,
    reportLevel = 'warn'
  } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const { dryRun, interactive, org: orgFlag } = cli.flags
  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const scanId =
    (shadowNpmInject.isTestingV1() || defaultOrgSlug
      ? cli.input[0]
      : cli.input[1]) || ''
  const file =
    (shadowNpmInject.isTestingV1() || defaultOrgSlug
      ? cli.input[1]
      : cli.input[2]) || '-'
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: !!defaultOrgSlug,
      test: !!orgSlug && orgSlug !== '.',
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail:
        orgSlug === '.'
          ? 'dot is an invalid org, most likely you forgot the org name here?'
          : 'missing'
    },
    {
      test: !!scanId,
      message: 'Scan ID to fetch',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$3)
    return
  }
  await handleScanReport({
    orgSlug,
    scanId: scanId,
    includeLicensePolicy: !!license,
    outputKind,
    filePath: file,
    fold: fold,
    short: !!cli.flags['short'],
    reportLevel: reportLevel
  })
}

async function fetchScan(orgSlug, scanId) {
  const apiToken = shadowNpmInject.getDefaultToken()
  if (!apiToken) {
    throw new shadowNpmInject.AuthError(
      'User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.'
    )
  }

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching scan data...')
  const response = await queryApi(
    `orgs/${orgSlug}/full-scans/${encodeURIComponent(scanId)}`,
    apiToken
  )
  spinner.successAndStop('Received response while fetching scan data.')
  if (!response.ok) {
    const err = await handleApiError(response.status)
    logger.logger.fail(
      failMsgWithBadge(response.statusText, `Fetch error: ${err}`)
    )
    return
  }

  // This is nd-json; each line is a json object
  const jsons = await response.text()
  const lines = jsons.split('\n').filter(Boolean)
  const data = lines.map(line => {
    try {
      return JSON.parse(line)
    } catch {
      console.error(
        'At least one line item was returned that could not be parsed as JSON...'
      )
      return {}
    }
  })
  return data
}

async function outputScanView(artifacts, orgSlug, scanId, filePath) {
  const display = artifacts.map(art => {
    const author = Array.isArray(art.author)
      ? `${art.author[0]}${art.author.length > 1 ? ' et.al.' : ''}`
      : art.author
    return {
      type: art.type,
      name: art.name,
      version: art.version,
      author,
      score: JSON.stringify(art.score)
    }
  })
  const md = mdTable(display, ['type', 'version', 'name', 'author', 'score'])
  const report =
    `
# Scan Details

These are the artifacts and their scores found.

Scan ID: ${scanId}

${md}

View this report at: https://socket.dev/dashboard/org/${orgSlug}/sbom/${scanId}
  `.trim() + '\n'
  if (filePath !== '-') {
    try {
      await fs.writeFile(filePath, report, 'utf8')
      logger.logger.log(`Data successfully written to ${filePath}`)
    } catch (e) {
      process.exitCode = 1
      logger.logger.fail('There was an error trying to write the json to disk')
      logger.logger.error(e)
    }
  } else {
    logger.logger.log(report)
  }
}

async function handleScanView(orgSlug, scanId, filePath) {
  const data = await fetchScan(orgSlug, scanId)
  if (!data) {
    return
  }
  await outputScanView(data, orgSlug, scanId, filePath)
}

async function streamScan(orgSlug, scanId, file) {
  // Lazily access constants.spinner.
  const { spinner } = constants
  const sockSdk = await shadowNpmInject.setupSdk()
  spinner.start('Fetching scan...')
  const data = await handleApiCall(
    sockSdk.getOrgFullScan(orgSlug, scanId, file === '-' ? undefined : file),
    'Fetching a scan'
  )
  spinner.successAndStop(`Full scan details written to ${file}`)
  if (!data?.success) {
    handleUnsuccessfulApiResponse('getOrgFullScan', data)
  }
  return data
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$2 } = constants
const config$2 = {
  commandName: 'view',
  description: 'View the raw results of a scan',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'} <scan ID> [path to output file]

    API Token Requirements
      - Quota: 1 unit
      - Permissions: full-scans:list

    When no output path is given the contents is sent to stdout.

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 ./stream.txt
  `
}
const cmdScanView = {
  description: config$2.description,
  hidden: config$2.hidden,
  run: run$2
}
async function run$2(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$2,
    importMeta,
    parentName
  })
  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const scanId =
    (shadowNpmInject.isTestingV1() || defaultOrgSlug
      ? cli.input[0]
      : cli.input[1]) || ''
  const file =
    (shadowNpmInject.isTestingV1() || defaultOrgSlug
      ? cli.input[1]
      : cli.input[2]) || '-'
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: !!defaultOrgSlug,
      test: !!orgSlug && orgSlug !== '.',
      message: shadowNpmInject.isTestingV1()
        ? 'Org name by default setting, --org, or auto-discovered'
        : 'Org name must be the first argument',
      pass: 'ok',
      fail:
        orgSlug === '.'
          ? 'dot is an invalid org, most likely you forgot the org name here?'
          : 'missing'
    },
    {
      test: !!scanId,
      message: 'Scan ID to delete',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message:
        'The `--json` and `--markdown` flags can not be used at the same time',
      pass: 'ok',
      fail: 'bad'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$2)
    return
  }
  if (json) {
    await streamScan(orgSlug, scanId, file)
  } else {
    await handleScanView(orgSlug, scanId, file)
  }
}

const description = 'Scan related commands'
const cmdScan = {
  description,
  async run(argv, importMeta, { parentName }) {
    await meowWithSubcommands(
      {
        create: cmdScanCreate,
        list: cmdScanList,
        del: cmdScanDel,
        diff: cmdScanDiff,
        metadata: cmdScanMetadata,
        report: cmdScanReport,
        view: cmdScanView
      },
      {
        aliases: {
          // Backwards compat. TODO: Drop next major bump
          stream: {
            description: cmdScanView.description,
            hidden: true,
            argv: ['view'] // Original args will be appended (!)
          }
        },
        argv,
        description,
        importMeta,
        name: parentName + ' scan'
      }
    )
  }
}

async function fetchThreatFeed({
  direction,
  ecosystem,
  filter,
  page,
  perPage
}) {
  const queryParams = new URLSearchParams([
    ['direction', direction],
    ['ecosystem', ecosystem],
    ['filter', filter],
    ['page', page],
    ['per_page', String(perPage)]
  ])
  const apiToken = shadowNpmInject.getDefaultToken()
  if (!apiToken) {
    throw new shadowNpmInject.AuthError(
      'User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.'
    )
  }

  // Lazily access constants.spinner.
  const { spinner } = constants
  spinner.start('Fetching Threat Feed data...')
  const response = await queryApi(`threat-feed?${queryParams}`, apiToken)
  spinner.successAndStop('Received response while fetching Threat Feed data.')
  const data = await response.json()
  return data
}

async function outputThreatFeed(data, { outputKind }) {
  if (outputKind === 'json') {
    logger.logger.log(data)
    return
  }
  if (!data?.results?.length) {
    logger.logger.error('Did not receive any data to display...')
    return
  }
  const formattedOutput = formatResults(data.results)
  const descriptions = data.results.map(d => d.description)

  // Note: this temporarily takes over the terminal (just like `man` does).
  const ScreenWidget = require('../external/blessed/lib/widgets/screen.js')
  // Lazily access constants.blessedOptions.
  const screen = new ScreenWidget({
    ...constants.blessedOptions
  })
  // Register these keys first so you can always exit, even when it gets stuck
  // If we don't do this and the code crashes, the user must hard-kill the
  // node process just to exit it. That's very bad UX.
  // eslint-disable-next-line n/no-process-exit
  screen.key(['escape', 'q', 'C-c'], () => process.exit(0))
  const TableWidget = require('../external/blessed-contrib/lib/widget/table.js')
  const table = new TableWidget({
    keys: 'true',
    fg: 'white',
    selectedFg: 'white',
    selectedBg: 'magenta',
    interactive: 'true',
    label: 'Threat feed',
    width: '100%',
    height: '70%',
    // Changed from 100% to 70%
    border: {
      type: 'line',
      fg: 'cyan'
    },
    columnWidth: [10, 30, 20, 18, 15, 200],
    // TODO: the truncation doesn't seem to work too well yet but when we add
    //       `pad` alignment fails, when we extend columnSpacing alignment fails
    columnSpacing: 1,
    truncate: '_'
  })

  // Create details box at the bottom
  const BoxWidget = require('../external/blessed/lib/widgets/box.js')
  const detailsBox = new BoxWidget({
    bottom: 0,
    height: '30%',
    width: '100%',
    border: {
      type: 'line',
      fg: 'cyan'
    },
    label: 'Details',
    content:
      'Use arrow keys to navigate. Press Enter to select a threat. Press q to exit.',
    style: {
      fg: 'white'
    }
  })
  table.setData({
    headers: [
      ' Ecosystem',
      ' Name',
      '  Version',
      '  Threat type',
      '  Detected at',
      ' Details'
    ],
    data: formattedOutput
  })

  // allow control the table with the keyboard
  table.focus()
  screen.append(table)
  screen.append(detailsBox)

  // Update details box when selection changes
  table.rows.on('select item', () => {
    const selectedIndex = table.rows.selected
    if (selectedIndex !== undefined && selectedIndex >= 0) {
      const selectedRow = formattedOutput[selectedIndex]
      if (selectedRow) {
        // Note: the spacing works around issues with the table; it refuses to pad!
        detailsBox.setContent(
          `Ecosystem: ${selectedRow[0]}\n` +
            `Name: ${selectedRow[1]}\n` +
            `Version:${selectedRow[2]}\n` +
            `Threat type:${selectedRow[3]}\n` +
            `Detected at:${selectedRow[4]}\n` +
            `Details: ${selectedRow[5]}\n` +
            `Description: ${descriptions[selectedIndex]}`
        )
        screen.render()
      }
    }
  })
  screen.render()
  screen.key(['return'], () => {
    const selectedIndex = table.rows.selected
    screen.destroy()
    const selectedRow = formattedOutput[selectedIndex]
    logger.logger.log('Last selection:\n', selectedRow)
  })
}
function formatResults(data) {
  return data.map(d => {
    const ecosystem = d.purl.split('pkg:')[1].split('/')[0]
    const name = d.purl.split('/')[1].split('@')[0]
    const version = d.purl.split('@')[1]
    const timeDiff = msAtHome(d.createdAt)

    // Note: the spacing works around issues with the table; it refuses to pad!
    return [
      ecosystem,
      decodeURIComponent(name),
      ` ${version}`,
      ` ${d.threatType}`,
      ` ${timeDiff}`,
      d.locationHtmlUrl
    ]
  })
}
function msAtHome(isoTimeStamp) {
  const timeStart = Date.parse(isoTimeStamp)
  const timeEnd = Date.now()
  const rtf = new Intl.RelativeTimeFormat('en', {
    numeric: 'always',
    style: 'short'
  })
  const delta = timeEnd - timeStart
  if (delta < 60 * 60 * 1000) {
    return rtf.format(-Math.round(delta / (60 * 1000)), 'minute')
    // return Math.round(delta / (60 * 1000)) + ' min ago'
  } else if (delta < 24 * 60 * 60 * 1000) {
    return rtf.format(-(delta / (60 * 60 * 1000)).toFixed(1), 'hour')
    // return (delta / (60 * 60 * 1000)).toFixed(1) + ' hr ago'
  } else if (delta < 7 * 24 * 60 * 60 * 1000) {
    return rtf.format(-(delta / (24 * 60 * 60 * 1000)).toFixed(1), 'day')
    // return (delta / (24 * 60 * 60 * 1000)).toFixed(1) + ' day ago'
  } else {
    return isoTimeStamp.slice(0, 10)
  }
}

async function handleThreatFeed({
  direction,
  ecosystem,
  filter,
  outputKind,
  page,
  perPage
}) {
  const data = await fetchThreatFeed({
    direction,
    ecosystem,
    filter,
    page,
    perPage
  })
  if (!data) {
    return
  }
  if ('error' in data && data.error) {
    logger.logger.fail(failMsgWithBadge('Server Error', data.error.message))
    return
  }
  await outputThreatFeed(data, {
    outputKind
  })
}

const { DRY_RUN_BAIL_TEXT: DRY_RUN_BAIL_TEXT$1 } = constants
const config$1 = {
  commandName: 'threat-feed',
  description: '[beta] View the threat feed',
  hidden: false,
  flags: {
    ...commonFlags,
    ...outputFlags,
    interactive: {
      type: 'boolean',
      default: true,
      description:
        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'
    },
    org: {
      type: 'string',
      description:
        'Force override the organization slug, overrides the default org from config'
    },
    perPage: {
      type: 'number',
      shortFlag: 'pp',
      default: 30,
      description: 'Number of items per page'
    },
    page: {
      type: 'string',
      shortFlag: 'p',
      default: '1',
      description: 'Page token'
    },
    direction: {
      type: 'string',
      shortFlag: 'd',
      default: 'desc',
      description: 'Order asc or desc by the createdAt attribute'
    },
    eco: {
      type: 'string',
      shortFlag: 'e',
      default: '',
      description: 'Only show threats for a particular ecosystem'
    },
    filter: {
      type: 'string',
      shortFlag: 'f',
      default: 'mal',
      description: 'Filter what type of threats to return'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' <org slug>'}

    API Token Requirements
      - Quota: 1 unit
      - Permissions: threat-feed:list
      - Special access

    This feature requires a Threat Feed license. Please contact
    sales@socket.dev if you are interested in purchasing this access.

    Options
      ${getFlagListOutput(config.flags, 6)}

    Valid filters:

      - anom    Anomaly
      - c       Do not filter
      - fp      False Positives
      - joke    Joke / Fake
      - mal     Malware and Possible Malware [default]
      - secret  Secrets
      - spy     Telemetry
      - tp      False Positives and Unreviewed
      - typo    Typo-squat
      - u       Unreviewed
      - vuln    Vulnerability

    Valid ecosystems:

      - gem
      - golang
      - maven
      - npm
      - nuget
      - pypi

    Examples
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'}
      $ ${command}${shadowNpmInject.isTestingV1() ? '' : ' FakeOrg'} --perPage=5 --page=2 --direction=asc --filter=joke
  `
}
const cmdThreatFeed = {
  description: config$1.description,
  hidden: config$1.hidden,
  run: run$1
}
async function run$1(argv, importMeta, { parentName }) {
  const cli = meowOrExit({
    argv,
    config: config$1,
    importMeta,
    parentName
  })
  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags
  const outputKind = getOutputKind(json, markdown)
  const [orgSlug] = await determineOrgSlug(
    String(orgFlag || ''),
    cli.input[0] || '',
    !!interactive,
    !!dryRun
  )
  const apiToken = shadowNpmInject.getDefaultToken()
  const wasBadInput = checkCommandInput(
    outputKind,
    {
      nook: true,
      test: !!orgSlug,
      message: 'Org name as the first argument',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !json || !markdown,
      message: 'The json and markdown flags cannot be both set, pick one',
      pass: 'ok',
      fail: 'omit one'
    },
    {
      nook: true,
      test: !!apiToken,
      message:
        'You need to be logged in to use this command. See `socket login`.',
      pass: 'ok',
      fail: 'missing API token'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT$1)
    return
  }
  await handleThreatFeed({
    direction: String(cli.flags['direction'] || 'desc'),
    ecosystem: String(cli.flags['eco'] || ''),
    filter: String(cli.flags['filter'] || 'mal'),
    outputKind,
    page: String(cli.flags['page'] || '1'),
    perPage: Number(cli.flags['perPage']) || 30
  })
}

function addSocketWrapper(file) {
  return fs$1.appendFile(
    file,
    'alias npm="socket npm"\nalias npx="socket npx"\n',
    err => {
      if (err) {
        return new Error(`There was an error setting up the alias: ${err}`)
      }
      // TODO: pretty sure you need to source the file or restart
      //       any terminal session before changes are reflected.
      logger.logger.log(
        `
The alias was added to ${file}. Running 'npm install' will now be wrapped in Socket's "safe npm" 
If you want to disable it at any time, run \`socket wrapper --disable\`
      `.trim()
      )
    }
  )
}

function checkSocketWrapperSetup(file) {
  const fileContent = fs$1.readFileSync(file, 'utf8')
  const linesWithSocketAlias = fileContent
    .split('\n')
    .filter(
      l => l === 'alias npm="socket npm"' || l === 'alias npx="socket npx"'
    )
  if (linesWithSocketAlias.length) {
    logger.logger.log(
      `The Socket npm/npx wrapper is set up in your bash profile (${file})`
    )
    return true
  }
  return false
}

async function postinstallWrapper() {
  // Lazily access constants.bashRcPath and constants.zshRcPath.
  const { bashRcPath, zshRcPath } = constants
  const socketWrapperEnabled =
    (fs$1.existsSync(bashRcPath) && checkSocketWrapperSetup(bashRcPath)) ||
    (fs$1.existsSync(zshRcPath) && checkSocketWrapperSetup(zshRcPath))
  if (!socketWrapperEnabled) {
    await installSafeNpm(
      `
The Socket CLI is now successfully installed! 

To better protect yourself against supply-chain attacks, our "safe npm" wrapper can warn you about malicious packages whenever you run 'npm install'.

Do you want to install "safe npm" (this will create an alias to the socket-npm command)?
    `.trim()
    )
  }
}
async function installSafeNpm(query) {
  logger.logger.log(`
 _____         _       _
|   __|___ ___| |_ ___| |_
|__   | . |  _| '_| -_|  _|
|_____|___|___|_,_|___|_|

`)
  if (
    await prompts.confirm({
      message: query,
      default: true
    })
  ) {
    // Lazily access constants.bashRcPath and constants.zshRcPath.
    const { bashRcPath, zshRcPath } = constants
    try {
      if (fs$1.existsSync(bashRcPath)) {
        addSocketWrapper(bashRcPath)
      }
      if (fs$1.existsSync(zshRcPath)) {
        addSocketWrapper(zshRcPath)
      }
    } catch (e) {
      throw new Error(
        `There was an issue setting up the alias: ${e?.['message']}`
      )
    }
  }
}

function removeSocketWrapper(file) {
  return fs$1.readFile(file, 'utf8', function (err, data) {
    if (err) {
      logger.logger.fail('There was an error removing the alias:')
      logger.logger.error(err)
      return
    }
    const linesWithoutSocketAlias = data
      .split('\n')
      .filter(
        l => l !== 'alias npm="socket npm"' && l !== 'alias npx="socket npx"'
      )
    const updatedFileContent = linesWithoutSocketAlias.join('\n')
    fs$1.writeFile(file, updatedFileContent, function (err) {
      if (err) {
        logger.logger.error(err)
        return
      }
      // TODO: pretty sure you need to source the file or restart
      //       any terminal session before changes are reflected.
      logger.logger.log(
        `The alias was removed from ${file}. Running 'npm install' will now run the standard npm command.`
      )
    })
  })
}

const { DRY_RUN_BAIL_TEXT } = constants
const config = {
  commandName: 'wrapper',
  description: 'Enable or disable the Socket npm/npx wrapper',
  hidden: false,
  flags: {
    ...commonFlags,
    enable: {
      type: 'boolean',
      default: false,
      description: 'Enables the Socket npm/npx wrapper'
    },
    disable: {
      type: 'boolean',
      default: false,
      description: 'Disables the Socket npm/npx wrapper'
    }
  },
  help: (command, config) => `
    Usage
      $ ${command} <flag>

    Options
      ${getFlagListOutput(config.flags, 6)}

    Examples
      $ ${command} --enable
      $ ${command} --disable
  `
}
const cmdWrapper = {
  description: config.description,
  hidden: config.hidden,
  run
}
async function run(argv, importMeta, { parentName }) {
  // I don't think meow would mess with this but ...
  if (argv[0] === '--postinstall') {
    await postinstallWrapper()
    return
  }
  const cli = meowOrExit({
    argv,
    config,
    importMeta,
    parentName
  })
  const { disable, enable, json, markdown } = cli.flags
  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further

  const wasBadInput = checkCommandInput(
    outputKind,
    {
      test: !!(enable || disable),
      message: 'Must use --enabled or --disable',
      pass: 'ok',
      fail: 'missing'
    },
    {
      nook: true,
      test: !enable || !disable,
      message: 'Do not use both --enable and --disable',
      pass: 'ok',
      fail: 'missing'
    }
  )
  if (wasBadInput) {
    return
  }
  if (cli.flags['dryRun']) {
    logger.logger.log(DRY_RUN_BAIL_TEXT)
    return
  }

  // Lazily access constants.bashRcPath and constants.zshRcPath.
  const { bashRcPath, zshRcPath } = constants
  if (enable) {
    if (fs$1.existsSync(bashRcPath) && !checkSocketWrapperSetup(bashRcPath)) {
      addSocketWrapper(bashRcPath)
    }
    if (fs$1.existsSync(zshRcPath) && !checkSocketWrapperSetup(zshRcPath)) {
      addSocketWrapper(zshRcPath)
    }
  } else {
    if (fs$1.existsSync(bashRcPath)) {
      removeSocketWrapper(bashRcPath)
    }
    if (fs$1.existsSync(zshRcPath)) {
      removeSocketWrapper(zshRcPath)
    }
  }
  if (!fs$1.existsSync(bashRcPath) && !fs$1.existsSync(zshRcPath)) {
    logger.logger.fail(
      'There was an issue setting up the alias in your bash profile'
    )
  }
}

const { SOCKET_CLI_BIN_NAME } = constants

// TODO: Add autocompletion using https://socket.dev/npm/package/omelette
void (async () => {
  await vendor.updater({
    name: SOCKET_CLI_BIN_NAME,
    // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION.
    version: constants.ENV.INLINED_SOCKET_CLI_VERSION,
    ttl: 86_400_000 /* 24 hours in milliseconds */
  })
  try {
    await meowWithSubcommands(
      {
        cdxgen: cmdCdxgen,
        ci: cmdCI,
        config: cmdConfig,
        fix: cmdFix,
        info: cmdInfo,
        login: cmdLogin,
        logout: cmdLogout,
        npm: cmdNpm,
        npx: cmdNpx,
        oops: cmdOops,
        optimize: cmdOptimize,
        organization: cmdOrganization,
        package: cmdPackage,
        'raw-npm': cmdRawNpm,
        'raw-npx': cmdRawNpx,
        report: cmdReport,
        wrapper: cmdWrapper,
        scan: cmdScan,
        'audit-log': cmdAuditLog,
        repos: cmdRepos,
        dependencies: cmdScanCreate$1,
        analytics: cmdAnalytics,
        'diff-scan': cmdDiffScan,
        'threat-feed': cmdThreatFeed,
        manifest: cmdManifest
      },
      {
        aliases: {},
        argv: process$1.argv.slice(2),
        name: SOCKET_CLI_BIN_NAME,
        importMeta: {
          url: `${require$$0.pathToFileURL(__filename)}`
        }
      }
    )
  } catch (e) {
    process$1.exitCode = 1
    let errorBody
    let errorTitle
    let errorMessage = ''
    if (e instanceof shadowNpmInject.AuthError) {
      errorTitle = 'Authentication error'
      errorMessage = e.message
    } else if (e instanceof shadowNpmInject.InputError) {
      errorTitle = 'Invalid input'
      errorMessage = e.message
      errorBody = e.body
    } else if (e instanceof Error) {
      errorTitle = 'Unexpected error'
      errorMessage = vendor.messageWithCauses(e)
      errorBody = vendor.stackWithCauses(e)
    } else {
      errorTitle = 'Unexpected error with no details'
    }
    logger.logger.error('\n') // Any-spinner-newline
    logger.logger.fail(failMsgWithBadge(errorTitle, errorMessage))
    if (errorBody) {
      debug.debugLog(`${errorBody}`)
    }
    await shadowNpmInject.captureException(e)
  }
})()
//# debugId=8451412f-46b1-41ad-a6d2-6ff3657b25f3
//# sourceMappingURL=cli.js.map
